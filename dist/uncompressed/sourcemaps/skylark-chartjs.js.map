{"version":3,"sources":["skylark-chartjs.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-chartjs.js","sourcesContent":["define('packages/color-name',[],function(){\r\n'use strict'\r\n\r\nreturn {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n});\ndefine('packages/color-convert/conversions',[\r\n\t'../color-name'\r\n],function(cssKeywords) {\r\n\r\n\t// NOTE: conversions should only return primitive values (i.e. arrays, or\r\n\t//       values that give correct `typeof` results).\r\n\t//       do not use box values types (i.e. Number(), String(), etc.)\r\n\r\n\tconst reverseKeywords = {};\r\n\tfor (const key of Object.keys(cssKeywords)) {\r\n\t\treverseKeywords[cssKeywords[key]] = key;\r\n\t}\r\n\r\n\tconst convert = {\r\n\t\trgb: {channels: 3, labels: 'rgb'},\r\n\t\thsl: {channels: 3, labels: 'hsl'},\r\n\t\thsv: {channels: 3, labels: 'hsv'},\r\n\t\thwb: {channels: 3, labels: 'hwb'},\r\n\t\tcmyk: {channels: 4, labels: 'cmyk'},\r\n\t\txyz: {channels: 3, labels: 'xyz'},\r\n\t\tlab: {channels: 3, labels: 'lab'},\r\n\t\tlch: {channels: 3, labels: 'lch'},\r\n\t\thex: {channels: 1, labels: ['hex']},\r\n\t\tkeyword: {channels: 1, labels: ['keyword']},\r\n\t\tansi16: {channels: 1, labels: ['ansi16']},\r\n\t\tansi256: {channels: 1, labels: ['ansi256']},\r\n\t\thcg: {channels: 3, labels: ['h', 'c', 'g']},\r\n\t\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\r\n\t\tgray: {channels: 1, labels: ['gray']}\r\n\t};\r\n\r\n\r\n\t// Hide .channels and .labels properties\r\n\tfor (const model of Object.keys(convert)) {\r\n\t\tif (!('channels' in convert[model])) {\r\n\t\t\tthrow new Error('missing channels property: ' + model);\r\n\t\t}\r\n\r\n\t\tif (!('labels' in convert[model])) {\r\n\t\t\tthrow new Error('missing channel labels property: ' + model);\r\n\t\t}\r\n\r\n\t\tif (convert[model].labels.length !== convert[model].channels) {\r\n\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\r\n\t\t}\r\n\r\n\t\tconst {channels, labels} = convert[model];\r\n\t\tdelete convert[model].channels;\r\n\t\tdelete convert[model].labels;\r\n\t\tObject.defineProperty(convert[model], 'channels', {value: channels});\r\n\t\tObject.defineProperty(convert[model], 'labels', {value: labels});\r\n\t}\r\n\r\n\tconvert.rgb.hsl = function (rgb) {\r\n\t\tconst r = rgb[0] / 255;\r\n\t\tconst g = rgb[1] / 255;\r\n\t\tconst b = rgb[2] / 255;\r\n\t\tconst min = Math.min(r, g, b);\r\n\t\tconst max = Math.max(r, g, b);\r\n\t\tconst delta = max - min;\r\n\t\tlet h;\r\n\t\tlet s;\r\n\r\n\t\tif (max === min) {\r\n\t\t\th = 0;\r\n\t\t} else if (r === max) {\r\n\t\t\th = (g - b) / delta;\r\n\t\t} else if (g === max) {\r\n\t\t\th = 2 + (b - r) / delta;\r\n\t\t} else if (b === max) {\r\n\t\t\th = 4 + (r - g) / delta;\r\n\t\t}\r\n\r\n\t\th = Math.min(h * 60, 360);\r\n\r\n\t\tif (h < 0) {\r\n\t\t\th += 360;\r\n\t\t}\r\n\r\n\t\tconst l = (min + max) / 2;\r\n\r\n\t\tif (max === min) {\r\n\t\t\ts = 0;\r\n\t\t} else if (l <= 0.5) {\r\n\t\t\ts = delta / (max + min);\r\n\t\t} else {\r\n\t\t\ts = delta / (2 - max - min);\r\n\t\t}\r\n\r\n\t\treturn [h, s * 100, l * 100];\r\n\t};\r\n\r\n\tconvert.rgb.hsv = function (rgb) {\r\n\t\tlet rdif;\r\n\t\tlet gdif;\r\n\t\tlet bdif;\r\n\t\tlet h;\r\n\t\tlet s;\r\n\r\n\t\tconst r = rgb[0] / 255;\r\n\t\tconst g = rgb[1] / 255;\r\n\t\tconst b = rgb[2] / 255;\r\n\t\tconst v = Math.max(r, g, b);\r\n\t\tconst diff = v - Math.min(r, g, b);\r\n\t\tconst diffc = function (c) {\r\n\t\t\treturn (v - c) / 6 / diff + 1 / 2;\r\n\t\t};\r\n\r\n\t\tif (diff === 0) {\r\n\t\t\th = 0;\r\n\t\t\ts = 0;\r\n\t\t} else {\r\n\t\t\ts = diff / v;\r\n\t\t\trdif = diffc(r);\r\n\t\t\tgdif = diffc(g);\r\n\t\t\tbdif = diffc(b);\r\n\r\n\t\t\tif (r === v) {\r\n\t\t\t\th = bdif - gdif;\r\n\t\t\t} else if (g === v) {\r\n\t\t\t\th = (1 / 3) + rdif - bdif;\r\n\t\t\t} else if (b === v) {\r\n\t\t\t\th = (2 / 3) + gdif - rdif;\r\n\t\t\t}\r\n\r\n\t\t\tif (h < 0) {\r\n\t\t\t\th += 1;\r\n\t\t\t} else if (h > 1) {\r\n\t\t\t\th -= 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn [\r\n\t\t\th * 360,\r\n\t\t\ts * 100,\r\n\t\t\tv * 100\r\n\t\t];\r\n\t};\r\n\r\n\tconvert.rgb.hwb = function (rgb) {\r\n\t\tconst r = rgb[0];\r\n\t\tconst g = rgb[1];\r\n\t\tlet b = rgb[2];\r\n\t\tconst h = convert.rgb.hsl(rgb)[0];\r\n\t\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\r\n\r\n\t\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\r\n\r\n\t\treturn [h, w * 100, b * 100];\r\n\t};\r\n\r\n\tconvert.rgb.cmyk = function (rgb) {\r\n\t\tconst r = rgb[0] / 255;\r\n\t\tconst g = rgb[1] / 255;\r\n\t\tconst b = rgb[2] / 255;\r\n\r\n\t\tconst k = Math.min(1 - r, 1 - g, 1 - b);\r\n\t\tconst c = (1 - r - k) / (1 - k) || 0;\r\n\t\tconst m = (1 - g - k) / (1 - k) || 0;\r\n\t\tconst y = (1 - b - k) / (1 - k) || 0;\r\n\r\n\t\treturn [c * 100, m * 100, y * 100, k * 100];\r\n\t};\r\n\r\n\tfunction comparativeDistance(x, y) {\r\n\t\t/*\r\n\t\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\r\n\t\t*/\r\n\t\treturn (\r\n\t\t\t((x[0] - y[0]) ** 2) +\r\n\t\t\t((x[1] - y[1]) ** 2) +\r\n\t\t\t((x[2] - y[2]) ** 2)\r\n\t\t);\r\n\t}\r\n\r\n\tconvert.rgb.keyword = function (rgb) {\r\n\t\tconst reversed = reverseKeywords[rgb];\r\n\t\tif (reversed) {\r\n\t\t\treturn reversed;\r\n\t\t}\r\n\r\n\t\tlet currentClosestDistance = Infinity;\r\n\t\tlet currentClosestKeyword;\r\n\r\n\t\tfor (const keyword of Object.keys(cssKeywords)) {\r\n\t\t\tconst value = cssKeywords[keyword];\r\n\r\n\t\t\t// Compute comparative distance\r\n\t\t\tconst distance = comparativeDistance(rgb, value);\r\n\r\n\t\t\t// Check if its less, if so set as closest\r\n\t\t\tif (distance < currentClosestDistance) {\r\n\t\t\t\tcurrentClosestDistance = distance;\r\n\t\t\t\tcurrentClosestKeyword = keyword;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn currentClosestKeyword;\r\n\t};\r\n\r\n\tconvert.keyword.rgb = function (keyword) {\r\n\t\treturn cssKeywords[keyword];\r\n\t};\r\n\r\n\tconvert.rgb.xyz = function (rgb) {\r\n\t\tlet r = rgb[0] / 255;\r\n\t\tlet g = rgb[1] / 255;\r\n\t\tlet b = rgb[2] / 255;\r\n\r\n\t\t// Assume sRGB\r\n\t\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\r\n\t\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\r\n\t\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\r\n\r\n\t\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\r\n\t\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\r\n\t\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\r\n\r\n\t\treturn [x * 100, y * 100, z * 100];\r\n\t};\r\n\r\n\tconvert.rgb.lab = function (rgb) {\r\n\t\tconst xyz = convert.rgb.xyz(rgb);\r\n\t\tlet x = xyz[0];\r\n\t\tlet y = xyz[1];\r\n\t\tlet z = xyz[2];\r\n\r\n\t\tx /= 95.047;\r\n\t\ty /= 100;\r\n\t\tz /= 108.883;\r\n\r\n\t\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\r\n\t\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\r\n\t\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\r\n\r\n\t\tconst l = (116 * y) - 16;\r\n\t\tconst a = 500 * (x - y);\r\n\t\tconst b = 200 * (y - z);\r\n\r\n\t\treturn [l, a, b];\r\n\t};\r\n\r\n\tconvert.hsl.rgb = function (hsl) {\r\n\t\tconst h = hsl[0] / 360;\r\n\t\tconst s = hsl[1] / 100;\r\n\t\tconst l = hsl[2] / 100;\r\n\t\tlet t2;\r\n\t\tlet t3;\r\n\t\tlet val;\r\n\r\n\t\tif (s === 0) {\r\n\t\t\tval = l * 255;\r\n\t\t\treturn [val, val, val];\r\n\t\t}\r\n\r\n\t\tif (l < 0.5) {\r\n\t\t\tt2 = l * (1 + s);\r\n\t\t} else {\r\n\t\t\tt2 = l + s - l * s;\r\n\t\t}\r\n\r\n\t\tconst t1 = 2 * l - t2;\r\n\r\n\t\tconst rgb = [0, 0, 0];\r\n\t\tfor (let i = 0; i < 3; i++) {\r\n\t\t\tt3 = h + 1 / 3 * -(i - 1);\r\n\t\t\tif (t3 < 0) {\r\n\t\t\t\tt3++;\r\n\t\t\t}\r\n\r\n\t\t\tif (t3 > 1) {\r\n\t\t\t\tt3--;\r\n\t\t\t}\r\n\r\n\t\t\tif (6 * t3 < 1) {\r\n\t\t\t\tval = t1 + (t2 - t1) * 6 * t3;\r\n\t\t\t} else if (2 * t3 < 1) {\r\n\t\t\t\tval = t2;\r\n\t\t\t} else if (3 * t3 < 2) {\r\n\t\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\r\n\t\t\t} else {\r\n\t\t\t\tval = t1;\r\n\t\t\t}\r\n\r\n\t\t\trgb[i] = val * 255;\r\n\t\t}\r\n\r\n\t\treturn rgb;\r\n\t};\r\n\r\n\tconvert.hsl.hsv = function (hsl) {\r\n\t\tconst h = hsl[0];\r\n\t\tlet s = hsl[1] / 100;\r\n\t\tlet l = hsl[2] / 100;\r\n\t\tlet smin = s;\r\n\t\tconst lmin = Math.max(l, 0.01);\r\n\r\n\t\tl *= 2;\r\n\t\ts *= (l <= 1) ? l : 2 - l;\r\n\t\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\r\n\t\tconst v = (l + s) / 2;\r\n\t\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\r\n\r\n\t\treturn [h, sv * 100, v * 100];\r\n\t};\r\n\r\n\tconvert.hsv.rgb = function (hsv) {\r\n\t\tconst h = hsv[0] / 60;\r\n\t\tconst s = hsv[1] / 100;\r\n\t\tlet v = hsv[2] / 100;\r\n\t\tconst hi = Math.floor(h) % 6;\r\n\r\n\t\tconst f = h - Math.floor(h);\r\n\t\tconst p = 255 * v * (1 - s);\r\n\t\tconst q = 255 * v * (1 - (s * f));\r\n\t\tconst t = 255 * v * (1 - (s * (1 - f)));\r\n\t\tv *= 255;\r\n\r\n\t\tswitch (hi) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn [v, t, p];\r\n\t\t\tcase 1:\r\n\t\t\t\treturn [q, v, p];\r\n\t\t\tcase 2:\r\n\t\t\t\treturn [p, v, t];\r\n\t\t\tcase 3:\r\n\t\t\t\treturn [p, q, v];\r\n\t\t\tcase 4:\r\n\t\t\t\treturn [t, p, v];\r\n\t\t\tcase 5:\r\n\t\t\t\treturn [v, p, q];\r\n\t\t}\r\n\t};\r\n\r\n\tconvert.hsv.hsl = function (hsv) {\r\n\t\tconst h = hsv[0];\r\n\t\tconst s = hsv[1] / 100;\r\n\t\tconst v = hsv[2] / 100;\r\n\t\tconst vmin = Math.max(v, 0.01);\r\n\t\tlet sl;\r\n\t\tlet l;\r\n\r\n\t\tl = (2 - s) * v;\r\n\t\tconst lmin = (2 - s) * vmin;\r\n\t\tsl = s * vmin;\r\n\t\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\r\n\t\tsl = sl || 0;\r\n\t\tl /= 2;\r\n\r\n\t\treturn [h, sl * 100, l * 100];\r\n\t};\r\n\r\n\t// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\r\n\tconvert.hwb.rgb = function (hwb) {\r\n\t\tconst h = hwb[0] / 360;\r\n\t\tlet wh = hwb[1] / 100;\r\n\t\tlet bl = hwb[2] / 100;\r\n\t\tconst ratio = wh + bl;\r\n\t\tlet f;\r\n\r\n\t\t// Wh + bl cant be > 1\r\n\t\tif (ratio > 1) {\r\n\t\t\twh /= ratio;\r\n\t\t\tbl /= ratio;\r\n\t\t}\r\n\r\n\t\tconst i = Math.floor(6 * h);\r\n\t\tconst v = 1 - bl;\r\n\t\tf = 6 * h - i;\r\n\r\n\t\tif ((i & 0x01) !== 0) {\r\n\t\t\tf = 1 - f;\r\n\t\t}\r\n\r\n\t\tconst n = wh + f * (v - wh); // Linear interpolation\r\n\r\n\t\tlet r;\r\n\t\tlet g;\r\n\t\tlet b;\r\n\t\t/* eslint-disable max-statements-per-line,no-multi-spaces */\r\n\t\tswitch (i) {\r\n\t\t\tdefault:\r\n\t\t\tcase 6:\r\n\t\t\tcase 0: r = v;  g = n;  b = wh; break;\r\n\t\t\tcase 1: r = n;  g = v;  b = wh; break;\r\n\t\t\tcase 2: r = wh; g = v;  b = n; break;\r\n\t\t\tcase 3: r = wh; g = n;  b = v; break;\r\n\t\t\tcase 4: r = n;  g = wh; b = v; break;\r\n\t\t\tcase 5: r = v;  g = wh; b = n; break;\r\n\t\t}\r\n\t\t/* eslint-enable max-statements-per-line,no-multi-spaces */\r\n\r\n\t\treturn [r * 255, g * 255, b * 255];\r\n\t};\r\n\r\n\tconvert.cmyk.rgb = function (cmyk) {\r\n\t\tconst c = cmyk[0] / 100;\r\n\t\tconst m = cmyk[1] / 100;\r\n\t\tconst y = cmyk[2] / 100;\r\n\t\tconst k = cmyk[3] / 100;\r\n\r\n\t\tconst r = 1 - Math.min(1, c * (1 - k) + k);\r\n\t\tconst g = 1 - Math.min(1, m * (1 - k) + k);\r\n\t\tconst b = 1 - Math.min(1, y * (1 - k) + k);\r\n\r\n\t\treturn [r * 255, g * 255, b * 255];\r\n\t};\r\n\r\n\tconvert.xyz.rgb = function (xyz) {\r\n\t\tconst x = xyz[0] / 100;\r\n\t\tconst y = xyz[1] / 100;\r\n\t\tconst z = xyz[2] / 100;\r\n\t\tlet r;\r\n\t\tlet g;\r\n\t\tlet b;\r\n\r\n\t\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\r\n\t\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\r\n\t\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\r\n\r\n\t\t// Assume sRGB\r\n\t\tr = r > 0.0031308\r\n\t\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\r\n\t\t\t: r * 12.92;\r\n\r\n\t\tg = g > 0.0031308\r\n\t\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\r\n\t\t\t: g * 12.92;\r\n\r\n\t\tb = b > 0.0031308\r\n\t\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\r\n\t\t\t: b * 12.92;\r\n\r\n\t\tr = Math.min(Math.max(0, r), 1);\r\n\t\tg = Math.min(Math.max(0, g), 1);\r\n\t\tb = Math.min(Math.max(0, b), 1);\r\n\r\n\t\treturn [r * 255, g * 255, b * 255];\r\n\t};\r\n\r\n\tconvert.xyz.lab = function (xyz) {\r\n\t\tlet x = xyz[0];\r\n\t\tlet y = xyz[1];\r\n\t\tlet z = xyz[2];\r\n\r\n\t\tx /= 95.047;\r\n\t\ty /= 100;\r\n\t\tz /= 108.883;\r\n\r\n\t\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\r\n\t\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\r\n\t\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\r\n\r\n\t\tconst l = (116 * y) - 16;\r\n\t\tconst a = 500 * (x - y);\r\n\t\tconst b = 200 * (y - z);\r\n\r\n\t\treturn [l, a, b];\r\n\t};\r\n\r\n\tconvert.lab.xyz = function (lab) {\r\n\t\tconst l = lab[0];\r\n\t\tconst a = lab[1];\r\n\t\tconst b = lab[2];\r\n\t\tlet x;\r\n\t\tlet y;\r\n\t\tlet z;\r\n\r\n\t\ty = (l + 16) / 116;\r\n\t\tx = a / 500 + y;\r\n\t\tz = y - b / 200;\r\n\r\n\t\tconst y2 = y ** 3;\r\n\t\tconst x2 = x ** 3;\r\n\t\tconst z2 = z ** 3;\r\n\t\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\r\n\t\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\r\n\t\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\r\n\r\n\t\tx *= 95.047;\r\n\t\ty *= 100;\r\n\t\tz *= 108.883;\r\n\r\n\t\treturn [x, y, z];\r\n\t};\r\n\r\n\tconvert.lab.lch = function (lab) {\r\n\t\tconst l = lab[0];\r\n\t\tconst a = lab[1];\r\n\t\tconst b = lab[2];\r\n\t\tlet h;\r\n\r\n\t\tconst hr = Math.atan2(b, a);\r\n\t\th = hr * 360 / 2 / Math.PI;\r\n\r\n\t\tif (h < 0) {\r\n\t\t\th += 360;\r\n\t\t}\r\n\r\n\t\tconst c = Math.sqrt(a * a + b * b);\r\n\r\n\t\treturn [l, c, h];\r\n\t};\r\n\r\n\tconvert.lch.lab = function (lch) {\r\n\t\tconst l = lch[0];\r\n\t\tconst c = lch[1];\r\n\t\tconst h = lch[2];\r\n\r\n\t\tconst hr = h / 360 * 2 * Math.PI;\r\n\t\tconst a = c * Math.cos(hr);\r\n\t\tconst b = c * Math.sin(hr);\r\n\r\n\t\treturn [l, a, b];\r\n\t};\r\n\r\n\tconvert.rgb.ansi16 = function (args, saturation = null) {\r\n\t\tconst [r, g, b] = args;\r\n\t\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\r\n\r\n\t\tvalue = Math.round(value / 50);\r\n\r\n\t\tif (value === 0) {\r\n\t\t\treturn 30;\r\n\t\t}\r\n\r\n\t\tlet ansi = 30\r\n\t\t\t+ ((Math.round(b / 255) << 2)\r\n\t\t\t| (Math.round(g / 255) << 1)\r\n\t\t\t| Math.round(r / 255));\r\n\r\n\t\tif (value === 2) {\r\n\t\t\tansi += 60;\r\n\t\t}\r\n\r\n\t\treturn ansi;\r\n\t};\r\n\r\n\tconvert.hsv.ansi16 = function (args) {\r\n\t\t// Optimization here; we already know the value and don't need to get\r\n\t\t// it converted for us.\r\n\t\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\r\n\t};\r\n\r\n\tconvert.rgb.ansi256 = function (args) {\r\n\t\tconst r = args[0];\r\n\t\tconst g = args[1];\r\n\t\tconst b = args[2];\r\n\r\n\t\t// We use the extended greyscale palette here, with the exception of\r\n\t\t// black and white. normal palette only has 4 greyscale shades.\r\n\t\tif (r === g && g === b) {\r\n\t\t\tif (r < 8) {\r\n\t\t\t\treturn 16;\r\n\t\t\t}\r\n\r\n\t\t\tif (r > 248) {\r\n\t\t\t\treturn 231;\r\n\t\t\t}\r\n\r\n\t\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\r\n\t\t}\r\n\r\n\t\tconst ansi = 16\r\n\t\t\t+ (36 * Math.round(r / 255 * 5))\r\n\t\t\t+ (6 * Math.round(g / 255 * 5))\r\n\t\t\t+ Math.round(b / 255 * 5);\r\n\r\n\t\treturn ansi;\r\n\t};\r\n\r\n\tconvert.ansi16.rgb = function (args) {\r\n\t\tlet color = args % 10;\r\n\r\n\t\t// Handle greyscale\r\n\t\tif (color === 0 || color === 7) {\r\n\t\t\tif (args > 50) {\r\n\t\t\t\tcolor += 3.5;\r\n\t\t\t}\r\n\r\n\t\t\tcolor = color / 10.5 * 255;\r\n\r\n\t\t\treturn [color, color, color];\r\n\t\t}\r\n\r\n\t\tconst mult = (~~(args > 50) + 1) * 0.5;\r\n\t\tconst r = ((color & 1) * mult) * 255;\r\n\t\tconst g = (((color >> 1) & 1) * mult) * 255;\r\n\t\tconst b = (((color >> 2) & 1) * mult) * 255;\r\n\r\n\t\treturn [r, g, b];\r\n\t};\r\n\r\n\tconvert.ansi256.rgb = function (args) {\r\n\t\t// Handle greyscale\r\n\t\tif (args >= 232) {\r\n\t\t\tconst c = (args - 232) * 10 + 8;\r\n\t\t\treturn [c, c, c];\r\n\t\t}\r\n\r\n\t\targs -= 16;\r\n\r\n\t\tlet rem;\r\n\t\tconst r = Math.floor(args / 36) / 5 * 255;\r\n\t\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\r\n\t\tconst b = (rem % 6) / 5 * 255;\r\n\r\n\t\treturn [r, g, b];\r\n\t};\r\n\r\n\tconvert.rgb.hex = function (args) {\r\n\t\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\r\n\t\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\r\n\t\t\t+ (Math.round(args[2]) & 0xFF);\r\n\r\n\t\tconst string = integer.toString(16).toUpperCase();\r\n\t\treturn '000000'.substring(string.length) + string;\r\n\t};\r\n\r\n\tconvert.hex.rgb = function (args) {\r\n\t\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\r\n\t\tif (!match) {\r\n\t\t\treturn [0, 0, 0];\r\n\t\t}\r\n\r\n\t\tlet colorString = match[0];\r\n\r\n\t\tif (match[0].length === 3) {\r\n\t\t\tcolorString = colorString.split('').map(char => {\r\n\t\t\t\treturn char + char;\r\n\t\t\t}).join('');\r\n\t\t}\r\n\r\n\t\tconst integer = parseInt(colorString, 16);\r\n\t\tconst r = (integer >> 16) & 0xFF;\r\n\t\tconst g = (integer >> 8) & 0xFF;\r\n\t\tconst b = integer & 0xFF;\r\n\r\n\t\treturn [r, g, b];\r\n\t};\r\n\r\n\tconvert.rgb.hcg = function (rgb) {\r\n\t\tconst r = rgb[0] / 255;\r\n\t\tconst g = rgb[1] / 255;\r\n\t\tconst b = rgb[2] / 255;\r\n\t\tconst max = Math.max(Math.max(r, g), b);\r\n\t\tconst min = Math.min(Math.min(r, g), b);\r\n\t\tconst chroma = (max - min);\r\n\t\tlet grayscale;\r\n\t\tlet hue;\r\n\r\n\t\tif (chroma < 1) {\r\n\t\t\tgrayscale = min / (1 - chroma);\r\n\t\t} else {\r\n\t\t\tgrayscale = 0;\r\n\t\t}\r\n\r\n\t\tif (chroma <= 0) {\r\n\t\t\thue = 0;\r\n\t\t} else\r\n\t\tif (max === r) {\r\n\t\t\thue = ((g - b) / chroma) % 6;\r\n\t\t} else\r\n\t\tif (max === g) {\r\n\t\t\thue = 2 + (b - r) / chroma;\r\n\t\t} else {\r\n\t\t\thue = 4 + (r - g) / chroma + 4;\r\n\t\t}\r\n\r\n\t\thue /= 6;\r\n\t\thue %= 1;\r\n\r\n\t\treturn [hue * 360, chroma * 100, grayscale * 100];\r\n\t};\r\n\r\n\tconvert.hsl.hcg = function (hsl) {\r\n\t\tconst s = hsl[1] / 100;\r\n\t\tconst l = hsl[2] / 100;\r\n\r\n\t\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\r\n\r\n\t\tlet f = 0;\r\n\t\tif (c < 1.0) {\r\n\t\t\tf = (l - 0.5 * c) / (1.0 - c);\r\n\t\t}\r\n\r\n\t\treturn [hsl[0], c * 100, f * 100];\r\n\t};\r\n\r\n\tconvert.hsv.hcg = function (hsv) {\r\n\t\tconst s = hsv[1] / 100;\r\n\t\tconst v = hsv[2] / 100;\r\n\r\n\t\tconst c = s * v;\r\n\t\tlet f = 0;\r\n\r\n\t\tif (c < 1.0) {\r\n\t\t\tf = (v - c) / (1 - c);\r\n\t\t}\r\n\r\n\t\treturn [hsv[0], c * 100, f * 100];\r\n\t};\r\n\r\n\tconvert.hcg.rgb = function (hcg) {\r\n\t\tconst h = hcg[0] / 360;\r\n\t\tconst c = hcg[1] / 100;\r\n\t\tconst g = hcg[2] / 100;\r\n\r\n\t\tif (c === 0.0) {\r\n\t\t\treturn [g * 255, g * 255, g * 255];\r\n\t\t}\r\n\r\n\t\tconst pure = [0, 0, 0];\r\n\t\tconst hi = (h % 1) * 6;\r\n\t\tconst v = hi % 1;\r\n\t\tconst w = 1 - v;\r\n\t\tlet mg = 0;\r\n\r\n\t\t/* eslint-disable max-statements-per-line */\r\n\t\tswitch (Math.floor(hi)) {\r\n\t\t\tcase 0:\r\n\t\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\r\n\t\t\tcase 1:\r\n\t\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\r\n\t\t\tcase 2:\r\n\t\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\r\n\t\t\tcase 3:\r\n\t\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\r\n\t\t\tcase 4:\r\n\t\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\r\n\t\t\tdefault:\r\n\t\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\r\n\t\t}\r\n\t\t/* eslint-enable max-statements-per-line */\r\n\r\n\t\tmg = (1.0 - c) * g;\r\n\r\n\t\treturn [\r\n\t\t\t(c * pure[0] + mg) * 255,\r\n\t\t\t(c * pure[1] + mg) * 255,\r\n\t\t\t(c * pure[2] + mg) * 255\r\n\t\t];\r\n\t};\r\n\r\n\tconvert.hcg.hsv = function (hcg) {\r\n\t\tconst c = hcg[1] / 100;\r\n\t\tconst g = hcg[2] / 100;\r\n\r\n\t\tconst v = c + g * (1.0 - c);\r\n\t\tlet f = 0;\r\n\r\n\t\tif (v > 0.0) {\r\n\t\t\tf = c / v;\r\n\t\t}\r\n\r\n\t\treturn [hcg[0], f * 100, v * 100];\r\n\t};\r\n\r\n\tconvert.hcg.hsl = function (hcg) {\r\n\t\tconst c = hcg[1] / 100;\r\n\t\tconst g = hcg[2] / 100;\r\n\r\n\t\tconst l = g * (1.0 - c) + 0.5 * c;\r\n\t\tlet s = 0;\r\n\r\n\t\tif (l > 0.0 && l < 0.5) {\r\n\t\t\ts = c / (2 * l);\r\n\t\t} else\r\n\t\tif (l >= 0.5 && l < 1.0) {\r\n\t\t\ts = c / (2 * (1 - l));\r\n\t\t}\r\n\r\n\t\treturn [hcg[0], s * 100, l * 100];\r\n\t};\r\n\r\n\tconvert.hcg.hwb = function (hcg) {\r\n\t\tconst c = hcg[1] / 100;\r\n\t\tconst g = hcg[2] / 100;\r\n\t\tconst v = c + g * (1.0 - c);\r\n\t\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\r\n\t};\r\n\r\n\tconvert.hwb.hcg = function (hwb) {\r\n\t\tconst w = hwb[1] / 100;\r\n\t\tconst b = hwb[2] / 100;\r\n\t\tconst v = 1 - b;\r\n\t\tconst c = v - w;\r\n\t\tlet g = 0;\r\n\r\n\t\tif (c < 1) {\r\n\t\t\tg = (v - c) / (1 - c);\r\n\t\t}\r\n\r\n\t\treturn [hwb[0], c * 100, g * 100];\r\n\t};\r\n\r\n\tconvert.apple.rgb = function (apple) {\r\n\t\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\r\n\t};\r\n\r\n\tconvert.rgb.apple = function (rgb) {\r\n\t\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\r\n\t};\r\n\r\n\tconvert.gray.rgb = function (args) {\r\n\t\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\r\n\t};\r\n\r\n\tconvert.gray.hsl = function (args) {\r\n\t\treturn [0, 0, args[0]];\r\n\t};\r\n\r\n\tconvert.gray.hsv = convert.gray.hsl;\r\n\r\n\tconvert.gray.hwb = function (gray) {\r\n\t\treturn [0, 100, gray[0]];\r\n\t};\r\n\r\n\tconvert.gray.cmyk = function (gray) {\r\n\t\treturn [0, 0, 0, gray[0]];\r\n\t};\r\n\r\n\tconvert.gray.lab = function (gray) {\r\n\t\treturn [gray[0], 0, 0];\r\n\t};\r\n\r\n\tconvert.gray.hex = function (gray) {\r\n\t\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\r\n\t\tconst integer = (val << 16) + (val << 8) + val;\r\n\r\n\t\tconst string = integer.toString(16).toUpperCase();\r\n\t\treturn '000000'.substring(string.length) + string;\r\n\t};\r\n\r\n\tconvert.rgb.gray = function (rgb) {\r\n\t\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\r\n\t\treturn [val / 255 * 100];\r\n\t};\r\n\r\n\treturn convert;\r\n\r\n});\ndefine('packages/color-convert/route',[\r\n\t'./conversions'\r\n],function(conversions) {\r\n\r\n\t/*\r\n\t\tThis function routes a model to all other models.\r\n\r\n\t\tall functions that are routed have a property `.conversion` attached\r\n\t\tto the returned synthetic function. This property is an array\r\n\t\tof strings, each with the steps in between the 'from' and 'to'\r\n\t\tcolor models (inclusive).\r\n\r\n\t\tconversions that are not possible simply are not included.\r\n\t*/\r\n\r\n\tfunction buildGraph() {\r\n\t\tconst graph = {};\r\n\t\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\r\n\t\tconst models = Object.keys(conversions);\r\n\r\n\t\tfor (let len = models.length, i = 0; i < len; i++) {\r\n\t\t\tgraph[models[i]] = {\r\n\t\t\t\t// http://jsperf.com/1-vs-infinity\r\n\t\t\t\t// micro-opt, but this is simple.\r\n\t\t\t\tdistance: -1,\r\n\t\t\t\tparent: null\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn graph;\r\n\t}\r\n\r\n\t// https://en.wikipedia.org/wiki/Breadth-first_search\r\n\tfunction deriveBFS(fromModel) {\r\n\t\tconst graph = buildGraph();\r\n\t\tconst queue = [fromModel]; // Unshift -> queue -> pop\r\n\r\n\t\tgraph[fromModel].distance = 0;\r\n\r\n\t\twhile (queue.length) {\r\n\t\t\tconst current = queue.pop();\r\n\t\t\tconst adjacents = Object.keys(conversions[current]);\r\n\r\n\t\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\r\n\t\t\t\tconst adjacent = adjacents[i];\r\n\t\t\t\tconst node = graph[adjacent];\r\n\r\n\t\t\t\tif (node.distance === -1) {\r\n\t\t\t\t\tnode.distance = graph[current].distance + 1;\r\n\t\t\t\t\tnode.parent = current;\r\n\t\t\t\t\tqueue.unshift(adjacent);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn graph;\r\n\t}\r\n\r\n\tfunction link(from, to) {\r\n\t\treturn function (args) {\r\n\t\t\treturn to(from(args));\r\n\t\t};\r\n\t}\r\n\r\n\tfunction wrapConversion(toModel, graph) {\r\n\t\tconst path = [graph[toModel].parent, toModel];\r\n\t\tlet fn = conversions[graph[toModel].parent][toModel];\r\n\r\n\t\tlet cur = graph[toModel].parent;\r\n\t\twhile (graph[cur].parent) {\r\n\t\t\tpath.unshift(graph[cur].parent);\r\n\t\t\tfn = link(conversions[graph[cur].parent][cur], fn);\r\n\t\t\tcur = graph[cur].parent;\r\n\t\t}\r\n\r\n\t\tfn.conversion = path;\r\n\t\treturn fn;\r\n\t}\r\n\r\n\treturn function (fromModel) {\r\n\t\tconst graph = deriveBFS(fromModel);\r\n\t\tconst conversion = {};\r\n\r\n\t\tconst models = Object.keys(graph);\r\n\t\tfor (let len = models.length, i = 0; i < len; i++) {\r\n\t\t\tconst toModel = models[i];\r\n\t\t\tconst node = graph[toModel];\r\n\r\n\t\t\tif (node.parent === null) {\r\n\t\t\t\t// No possible conversion, or this node is the source model.\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconversion[toModel] = wrapConversion(toModel, graph);\r\n\t\t}\r\n\r\n\t\treturn conversion;\r\n\t};\r\n});\r\n\ndefine('packages/color-convert/index',[\r\n\t'./conversions',\r\n\t'./route'\r\n],function(conversions,route) {\r\n\r\n\tconst convert = {};\r\n\r\n\tconst models = Object.keys(conversions);\r\n\r\n\tfunction wrapRaw(fn) {\r\n\t\tconst wrappedFn = function (...args) {\r\n\t\t\tconst arg0 = args[0];\r\n\t\t\tif (arg0 === undefined || arg0 === null) {\r\n\t\t\t\treturn arg0;\r\n\t\t\t}\r\n\r\n\t\t\tif (arg0.length > 1) {\r\n\t\t\t\targs = arg0;\r\n\t\t\t}\r\n\r\n\t\t\treturn fn(args);\r\n\t\t};\r\n\r\n\t\t// Preserve .conversion property if there is one\r\n\t\tif ('conversion' in fn) {\r\n\t\t\twrappedFn.conversion = fn.conversion;\r\n\t\t}\r\n\r\n\t\treturn wrappedFn;\r\n\t}\r\n\r\n\tfunction wrapRounded(fn) {\r\n\t\tconst wrappedFn = function (...args) {\r\n\t\t\tconst arg0 = args[0];\r\n\r\n\t\t\tif (arg0 === undefined || arg0 === null) {\r\n\t\t\t\treturn arg0;\r\n\t\t\t}\r\n\r\n\t\t\tif (arg0.length > 1) {\r\n\t\t\t\targs = arg0;\r\n\t\t\t}\r\n\r\n\t\t\tconst result = fn(args);\r\n\r\n\t\t\t// We're assuming the result is an array here.\r\n\t\t\t// see notice in conversions.js; don't use box types\r\n\t\t\t// in conversion functions.\r\n\t\t\tif (typeof result === 'object') {\r\n\t\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\r\n\t\t\t\t\tresult[i] = Math.round(result[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t};\r\n\r\n\t\t// Preserve .conversion property if there is one\r\n\t\tif ('conversion' in fn) {\r\n\t\t\twrappedFn.conversion = fn.conversion;\r\n\t\t}\r\n\r\n\t\treturn wrappedFn;\r\n\t}\r\n\r\n\tmodels.forEach(fromModel => {\r\n\t\tconvert[fromModel] = {};\r\n\r\n\t\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\r\n\t\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\r\n\r\n\t\tconst routes = route(fromModel);\r\n\t\tconst routeModels = Object.keys(routes);\r\n\r\n\t\trouteModels.forEach(toModel => {\r\n\t\t\tconst fn = routes[toModel];\r\n\r\n\t\t\tconvert[fromModel][toModel] = wrapRounded(fn);\r\n\t\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\r\n\t\t});\r\n\t});\r\n\r\n\treturn  convert;\r\n\r\n});\r\n\r\n\ndefine('packages/chartjs-color-string',[\r\n  './color-name'\r\n],function(colorNames){\r\n \r\n   function getRgba(string) {\r\n     if (!string) {\r\n        return;\r\n     }\r\n     var abbr =  /^#([a-fA-F0-9]{3,4})$/i,\r\n         hex =  /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,\r\n         rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\r\n         per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\r\n         keyword = /(\\w+)/;\r\n\r\n     var rgb = [0, 0, 0],\r\n         a = 1,\r\n         match = string.match(abbr),\r\n         hexAlpha = \"\";\r\n     if (match) {\r\n        match = match[1];\r\n        hexAlpha = match[3];\r\n        for (var i = 0; i < rgb.length; i++) {\r\n           rgb[i] = parseInt(match[i] + match[i], 16);\r\n        }\r\n        if (hexAlpha) {\r\n           a = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;\r\n        }\r\n     }\r\n     else if (match = string.match(hex)) {\r\n        hexAlpha = match[2];\r\n        match = match[1];\r\n        for (var i = 0; i < rgb.length; i++) {\r\n           rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\r\n        }\r\n        if (hexAlpha) {\r\n           a = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;\r\n        }\r\n     }\r\n     else if (match = string.match(rgba)) {\r\n        for (var i = 0; i < rgb.length; i++) {\r\n           rgb[i] = parseInt(match[i + 1]);\r\n        }\r\n        a = parseFloat(match[4]);\r\n     }\r\n     else if (match = string.match(per)) {\r\n        for (var i = 0; i < rgb.length; i++) {\r\n           rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\r\n        }\r\n        a = parseFloat(match[4]);\r\n     }\r\n     else if (match = string.match(keyword)) {\r\n        if (match[1] == \"transparent\") {\r\n           return [0, 0, 0, 0];\r\n        }\r\n        rgb = colorNames[match[1]];\r\n        if (!rgb) {\r\n           return;\r\n        }\r\n     }\r\n\r\n     for (var i = 0; i < rgb.length; i++) {\r\n        rgb[i] = scale(rgb[i], 0, 255);\r\n     }\r\n     if (!a && a != 0) {\r\n        a = 1;\r\n     }\r\n     else {\r\n        a = scale(a, 0, 1);\r\n     }\r\n     rgb[3] = a;\r\n     return rgb;\r\n  }\r\n\r\n  function getHsla(string) {\r\n     if (!string) {\r\n        return;\r\n     }\r\n     var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n     var match = string.match(hsl);\r\n     if (match) {\r\n        var alpha = parseFloat(match[4]);\r\n        var h = scale(parseInt(match[1]), 0, 360),\r\n            s = scale(parseFloat(match[2]), 0, 100),\r\n            l = scale(parseFloat(match[3]), 0, 100),\r\n            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n        return [h, s, l, a];\r\n     }\r\n  }\r\n\r\n  function getHwb(string) {\r\n     if (!string) {\r\n        return;\r\n     }\r\n     var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n     var match = string.match(hwb);\r\n     if (match) {\r\n      var alpha = parseFloat(match[4]);\r\n        var h = scale(parseInt(match[1]), 0, 360),\r\n            w = scale(parseFloat(match[2]), 0, 100),\r\n            b = scale(parseFloat(match[3]), 0, 100),\r\n            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n        return [h, w, b, a];\r\n     }\r\n  }\r\n\r\n  function getRgb(string) {\r\n     var rgba = getRgba(string);\r\n     return rgba && rgba.slice(0, 3);\r\n  }\r\n\r\n  function getHsl(string) {\r\n    var hsla = getHsla(string);\r\n    return hsla && hsla.slice(0, 3);\r\n  }\r\n\r\n  function getAlpha(string) {\r\n     var vals = getRgba(string);\r\n     if (vals) {\r\n        return vals[3];\r\n     }\r\n     else if (vals = getHsla(string)) {\r\n        return vals[3];\r\n     }\r\n     else if (vals = getHwb(string)) {\r\n        return vals[3];\r\n     }\r\n  }\r\n\r\n  // generators\r\n  function hexString(rgba, a) {\r\n     var a = (a !== undefined && rgba.length === 3) ? a : rgba[3];\r\n     return \"#\" + hexDouble(rgba[0]) \r\n                + hexDouble(rgba[1])\r\n                + hexDouble(rgba[2])\r\n                + (\r\n                   (a >= 0 && a < 1)\r\n                   ? hexDouble(Math.round(a * 255))\r\n                   : \"\"\r\n                );\r\n  }\r\n\r\n  function rgbString(rgba, alpha) {\r\n     if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n        return rgbaString(rgba, alpha);\r\n     }\r\n     return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\r\n  }\r\n\r\n  function rgbaString(rgba, alpha) {\r\n     if (alpha === undefined) {\r\n        alpha = (rgba[3] !== undefined ? rgba[3] : 1);\r\n     }\r\n     return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\r\n             + \", \" + alpha + \")\";\r\n  }\r\n\r\n  function percentString(rgba, alpha) {\r\n     if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n        return percentaString(rgba, alpha);\r\n     }\r\n     var r = Math.round(rgba[0]/255 * 100),\r\n         g = Math.round(rgba[1]/255 * 100),\r\n         b = Math.round(rgba[2]/255 * 100);\r\n\r\n     return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\r\n  }\r\n\r\n  function percentaString(rgba, alpha) {\r\n     var r = Math.round(rgba[0]/255 * 100),\r\n         g = Math.round(rgba[1]/255 * 100),\r\n         b = Math.round(rgba[2]/255 * 100);\r\n     return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\r\n  }\r\n\r\n  function hslString(hsla, alpha) {\r\n     if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\r\n        return hslaString(hsla, alpha);\r\n     }\r\n     return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\r\n  }\r\n\r\n  function hslaString(hsla, alpha) {\r\n     if (alpha === undefined) {\r\n        alpha = (hsla[3] !== undefined ? hsla[3] : 1);\r\n     }\r\n     return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\r\n             + alpha + \")\";\r\n  }\r\n\r\n  // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\r\n  // (hwb have alpha optional & 1 is default value)\r\n  function hwbString(hwb, alpha) {\r\n     if (alpha === undefined) {\r\n        alpha = (hwb[3] !== undefined ? hwb[3] : 1);\r\n     }\r\n     return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\r\n             + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\r\n  }\r\n\r\n  function keyword(rgb) {\r\n    return reverseNames[rgb.slice(0, 3)];\r\n  }\r\n\r\n  // helpers\r\n  function scale(num, min, max) {\r\n     return Math.min(Math.max(min, num), max);\r\n  }\r\n\r\n  function hexDouble(num) {\r\n    var str = num.toString(16).toUpperCase();\r\n    return (str.length < 2) ? \"0\" + str : str;\r\n  }\r\n\r\n\r\n  //create a list of reverse color names\r\n  var reverseNames = {};\r\n  for (var name in colorNames) {\r\n     reverseNames[colorNames[name]] = name;\r\n  }\r\n\r\n return {\r\n     getRgba: getRgba,\r\n     getHsla: getHsla,\r\n     getRgb: getRgb,\r\n     getHsl: getHsl,\r\n     getHwb: getHwb,\r\n     getAlpha: getAlpha,\r\n\r\n     hexString: hexString,\r\n     rgbString: rgbString,\r\n     rgbaString: rgbaString,\r\n     percentString: percentString,\r\n     percentaString: percentaString,\r\n     hslString: hslString,\r\n     hslaString: hslaString,\r\n     hwbString: hwbString,\r\n     keyword: keyword\r\n  }\r\n\r\n});\r\n\ndefine('packages/chartjs-color',[\r\n\t\"./color-convert/index\",\r\n\t\"./chartjs-color-string\"\r\n],function(convert,string){\r\n\r\n\tvar Color = function (obj) {\r\n\t\tif (obj instanceof Color) {\r\n\t\t\treturn obj;\r\n\t\t}\r\n\t\tif (!(this instanceof Color)) {\r\n\t\t\treturn new Color(obj);\r\n\t\t}\r\n\r\n\t\tthis.valid = false;\r\n\t\tthis.values = {\r\n\t\t\trgb: [0, 0, 0],\r\n\t\t\thsl: [0, 0, 0],\r\n\t\t\thsv: [0, 0, 0],\r\n\t\t\thwb: [0, 0, 0],\r\n\t\t\tcmyk: [0, 0, 0, 0],\r\n\t\t\talpha: 1\r\n\t\t};\r\n\r\n\t\t// parse Color() argument\r\n\t\tvar vals;\r\n\t\tif (typeof obj === 'string') {\r\n\t\t\tvals = string.getRgba(obj);\r\n\t\t\tif (vals) {\r\n\t\t\t\tthis.setValues('rgb', vals);\r\n\t\t\t} else if (vals = string.getHsla(obj)) {\r\n\t\t\t\tthis.setValues('hsl', vals);\r\n\t\t\t} else if (vals = string.getHwb(obj)) {\r\n\t\t\t\tthis.setValues('hwb', vals);\r\n\t\t\t}\r\n\t\t} else if (typeof obj === 'object') {\r\n\t\t\tvals = obj;\r\n\t\t\tif (vals.r !== undefined || vals.red !== undefined) {\r\n\t\t\t\tthis.setValues('rgb', vals);\r\n\t\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\r\n\t\t\t\tthis.setValues('hsl', vals);\r\n\t\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\r\n\t\t\t\tthis.setValues('hsv', vals);\r\n\t\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\r\n\t\t\t\tthis.setValues('hwb', vals);\r\n\t\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\r\n\t\t\t\tthis.setValues('cmyk', vals);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tColor.prototype = {\r\n\t\tisValid: function () {\r\n\t\t\treturn this.valid;\r\n\t\t},\r\n\t\trgb: function () {\r\n\t\t\treturn this.setSpace('rgb', arguments);\r\n\t\t},\r\n\t\thsl: function () {\r\n\t\t\treturn this.setSpace('hsl', arguments);\r\n\t\t},\r\n\t\thsv: function () {\r\n\t\t\treturn this.setSpace('hsv', arguments);\r\n\t\t},\r\n\t\thwb: function () {\r\n\t\t\treturn this.setSpace('hwb', arguments);\r\n\t\t},\r\n\t\tcmyk: function () {\r\n\t\t\treturn this.setSpace('cmyk', arguments);\r\n\t\t},\r\n\r\n\t\trgbArray: function () {\r\n\t\t\treturn this.values.rgb;\r\n\t\t},\r\n\t\thslArray: function () {\r\n\t\t\treturn this.values.hsl;\r\n\t\t},\r\n\t\thsvArray: function () {\r\n\t\t\treturn this.values.hsv;\r\n\t\t},\r\n\t\thwbArray: function () {\r\n\t\t\tvar values = this.values;\r\n\t\t\tif (values.alpha !== 1) {\r\n\t\t\t\treturn values.hwb.concat([values.alpha]);\r\n\t\t\t}\r\n\t\t\treturn values.hwb;\r\n\t\t},\r\n\t\tcmykArray: function () {\r\n\t\t\treturn this.values.cmyk;\r\n\t\t},\r\n\t\trgbaArray: function () {\r\n\t\t\tvar values = this.values;\r\n\t\t\treturn values.rgb.concat([values.alpha]);\r\n\t\t},\r\n\t\thslaArray: function () {\r\n\t\t\tvar values = this.values;\r\n\t\t\treturn values.hsl.concat([values.alpha]);\r\n\t\t},\r\n\t\talpha: function (val) {\r\n\t\t\tif (val === undefined) {\r\n\t\t\t\treturn this.values.alpha;\r\n\t\t\t}\r\n\t\t\tthis.setValues('alpha', val);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tred: function (val) {\r\n\t\t\treturn this.setChannel('rgb', 0, val);\r\n\t\t},\r\n\t\tgreen: function (val) {\r\n\t\t\treturn this.setChannel('rgb', 1, val);\r\n\t\t},\r\n\t\tblue: function (val) {\r\n\t\t\treturn this.setChannel('rgb', 2, val);\r\n\t\t},\r\n\t\thue: function (val) {\r\n\t\t\tif (val) {\r\n\t\t\t\tval %= 360;\r\n\t\t\t\tval = val < 0 ? 360 + val : val;\r\n\t\t\t}\r\n\t\t\treturn this.setChannel('hsl', 0, val);\r\n\t\t},\r\n\t\tsaturation: function (val) {\r\n\t\t\treturn this.setChannel('hsl', 1, val);\r\n\t\t},\r\n\t\tlightness: function (val) {\r\n\t\t\treturn this.setChannel('hsl', 2, val);\r\n\t\t},\r\n\t\tsaturationv: function (val) {\r\n\t\t\treturn this.setChannel('hsv', 1, val);\r\n\t\t},\r\n\t\twhiteness: function (val) {\r\n\t\t\treturn this.setChannel('hwb', 1, val);\r\n\t\t},\r\n\t\tblackness: function (val) {\r\n\t\t\treturn this.setChannel('hwb', 2, val);\r\n\t\t},\r\n\t\tvalue: function (val) {\r\n\t\t\treturn this.setChannel('hsv', 2, val);\r\n\t\t},\r\n\t\tcyan: function (val) {\r\n\t\t\treturn this.setChannel('cmyk', 0, val);\r\n\t\t},\r\n\t\tmagenta: function (val) {\r\n\t\t\treturn this.setChannel('cmyk', 1, val);\r\n\t\t},\r\n\t\tyellow: function (val) {\r\n\t\t\treturn this.setChannel('cmyk', 2, val);\r\n\t\t},\r\n\t\tblack: function (val) {\r\n\t\t\treturn this.setChannel('cmyk', 3, val);\r\n\t\t},\r\n\r\n\t\thexString: function () {\r\n\t\t\treturn string.hexString(this.values.rgb);\r\n\t\t},\r\n\t\trgbString: function () {\r\n\t\t\treturn string.rgbString(this.values.rgb, this.values.alpha);\r\n\t\t},\r\n\t\trgbaString: function () {\r\n\t\t\treturn string.rgbaString(this.values.rgb, this.values.alpha);\r\n\t\t},\r\n\t\tpercentString: function () {\r\n\t\t\treturn string.percentString(this.values.rgb, this.values.alpha);\r\n\t\t},\r\n\t\thslString: function () {\r\n\t\t\treturn string.hslString(this.values.hsl, this.values.alpha);\r\n\t\t},\r\n\t\thslaString: function () {\r\n\t\t\treturn string.hslaString(this.values.hsl, this.values.alpha);\r\n\t\t},\r\n\t\thwbString: function () {\r\n\t\t\treturn string.hwbString(this.values.hwb, this.values.alpha);\r\n\t\t},\r\n\t\tkeyword: function () {\r\n\t\t\treturn string.keyword(this.values.rgb, this.values.alpha);\r\n\t\t},\r\n\r\n\t\trgbNumber: function () {\r\n\t\t\tvar rgb = this.values.rgb;\r\n\t\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\r\n\t\t},\r\n\r\n\t\tluminosity: function () {\r\n\t\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\r\n\t\t\tvar rgb = this.values.rgb;\r\n\t\t\tvar lum = [];\r\n\t\t\tfor (var i = 0; i < rgb.length; i++) {\r\n\t\t\t\tvar chan = rgb[i] / 255;\r\n\t\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\r\n\t\t\t}\r\n\t\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\r\n\t\t},\r\n\r\n\t\tcontrast: function (color2) {\r\n\t\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\r\n\t\t\tvar lum1 = this.luminosity();\r\n\t\t\tvar lum2 = color2.luminosity();\r\n\t\t\tif (lum1 > lum2) {\r\n\t\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\r\n\t\t\t}\r\n\t\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\r\n\t\t},\r\n\r\n\t\tlevel: function (color2) {\r\n\t\t\tvar contrastRatio = this.contrast(color2);\r\n\t\t\tif (contrastRatio >= 7.1) {\r\n\t\t\t\treturn 'AAA';\r\n\t\t\t}\r\n\r\n\t\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\r\n\t\t},\r\n\r\n\t\tdark: function () {\r\n\t\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\r\n\t\t\tvar rgb = this.values.rgb;\r\n\t\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\r\n\t\t\treturn yiq < 128;\r\n\t\t},\r\n\r\n\t\tlight: function () {\r\n\t\t\treturn !this.dark();\r\n\t\t},\r\n\r\n\t\tnegate: function () {\r\n\t\t\tvar rgb = [];\r\n\t\t\tfor (var i = 0; i < 3; i++) {\r\n\t\t\t\trgb[i] = 255 - this.values.rgb[i];\r\n\t\t\t}\r\n\t\t\tthis.setValues('rgb', rgb);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tlighten: function (ratio) {\r\n\t\t\tvar hsl = this.values.hsl;\r\n\t\t\thsl[2] += hsl[2] * ratio;\r\n\t\t\tthis.setValues('hsl', hsl);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tdarken: function (ratio) {\r\n\t\t\tvar hsl = this.values.hsl;\r\n\t\t\thsl[2] -= hsl[2] * ratio;\r\n\t\t\tthis.setValues('hsl', hsl);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tsaturate: function (ratio) {\r\n\t\t\tvar hsl = this.values.hsl;\r\n\t\t\thsl[1] += hsl[1] * ratio;\r\n\t\t\tthis.setValues('hsl', hsl);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tdesaturate: function (ratio) {\r\n\t\t\tvar hsl = this.values.hsl;\r\n\t\t\thsl[1] -= hsl[1] * ratio;\r\n\t\t\tthis.setValues('hsl', hsl);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\twhiten: function (ratio) {\r\n\t\t\tvar hwb = this.values.hwb;\r\n\t\t\thwb[1] += hwb[1] * ratio;\r\n\t\t\tthis.setValues('hwb', hwb);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tblacken: function (ratio) {\r\n\t\t\tvar hwb = this.values.hwb;\r\n\t\t\thwb[2] += hwb[2] * ratio;\r\n\t\t\tthis.setValues('hwb', hwb);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tgreyscale: function () {\r\n\t\t\tvar rgb = this.values.rgb;\r\n\t\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\r\n\t\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\r\n\t\t\tthis.setValues('rgb', [val, val, val]);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tclearer: function (ratio) {\r\n\t\t\tvar alpha = this.values.alpha;\r\n\t\t\tthis.setValues('alpha', alpha - (alpha * ratio));\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\topaquer: function (ratio) {\r\n\t\t\tvar alpha = this.values.alpha;\r\n\t\t\tthis.setValues('alpha', alpha + (alpha * ratio));\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\trotate: function (degrees) {\r\n\t\t\tvar hsl = this.values.hsl;\r\n\t\t\tvar hue = (hsl[0] + degrees) % 360;\r\n\t\t\thsl[0] = hue < 0 ? 360 + hue : hue;\r\n\t\t\tthis.setValues('hsl', hsl);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Ported from sass implementation in C\r\n\t\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\r\n\t\t */\r\n\t\tmix: function (mixinColor, weight) {\r\n\t\t\tvar color1 = this;\r\n\t\t\tvar color2 = mixinColor;\r\n\t\t\tvar p = weight === undefined ? 0.5 : weight;\r\n\r\n\t\t\tvar w = 2 * p - 1;\r\n\t\t\tvar a = color1.alpha() - color2.alpha();\r\n\r\n\t\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\r\n\t\t\tvar w2 = 1 - w1;\r\n\r\n\t\t\treturn this\r\n\t\t\t\t.rgb(\r\n\t\t\t\t\tw1 * color1.red() + w2 * color2.red(),\r\n\t\t\t\t\tw1 * color1.green() + w2 * color2.green(),\r\n\t\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\r\n\t\t\t\t)\r\n\t\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\r\n\t\t},\r\n\r\n\t\ttoJSON: function () {\r\n\t\t\treturn this.rgb();\r\n\t\t},\r\n\r\n\t\tclone: function () {\r\n\t\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\r\n\t\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\r\n\t\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\r\n\t\t\t// except 'alpha' which is a number.\r\n\t\t\tvar result = new Color();\r\n\t\t\tvar source = this.values;\r\n\t\t\tvar target = result.values;\r\n\t\t\tvar value, type;\r\n\r\n\t\t\tfor (var prop in source) {\r\n\t\t\t\tif (source.hasOwnProperty(prop)) {\r\n\t\t\t\t\tvalue = source[prop];\r\n\t\t\t\t\ttype = ({}).toString.call(value);\r\n\t\t\t\t\tif (type === '[object Array]') {\r\n\t\t\t\t\t\ttarget[prop] = value.slice(0);\r\n\t\t\t\t\t} else if (type === '[object Number]') {\r\n\t\t\t\t\t\ttarget[prop] = value;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.error('unexpected color value:', value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t}\r\n\t};\r\n\r\n\tColor.prototype.spaces = {\r\n\t\trgb: ['red', 'green', 'blue'],\r\n\t\thsl: ['hue', 'saturation', 'lightness'],\r\n\t\thsv: ['hue', 'saturation', 'value'],\r\n\t\thwb: ['hue', 'whiteness', 'blackness'],\r\n\t\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\r\n\t};\r\n\r\n\tColor.prototype.maxes = {\r\n\t\trgb: [255, 255, 255],\r\n\t\thsl: [360, 100, 100],\r\n\t\thsv: [360, 100, 100],\r\n\t\thwb: [360, 100, 100],\r\n\t\tcmyk: [100, 100, 100, 100]\r\n\t};\r\n\r\n\tColor.prototype.getValues = function (space) {\r\n\t\tvar values = this.values;\r\n\t\tvar vals = {};\r\n\r\n\t\tfor (var i = 0; i < space.length; i++) {\r\n\t\t\tvals[space.charAt(i)] = values[space][i];\r\n\t\t}\r\n\r\n\t\tif (values.alpha !== 1) {\r\n\t\t\tvals.a = values.alpha;\r\n\t\t}\r\n\r\n\t\t// {r: 255, g: 255, b: 255, a: 0.4}\r\n\t\treturn vals;\r\n\t};\r\n\r\n\tColor.prototype.setValues = function (space, vals) {\r\n\t\tvar values = this.values;\r\n\t\tvar spaces = this.spaces;\r\n\t\tvar maxes = this.maxes;\r\n\t\tvar alpha = 1;\r\n\t\tvar i;\r\n\r\n\t\tthis.valid = true;\r\n\r\n\t\tif (space === 'alpha') {\r\n\t\t\talpha = vals;\r\n\t\t} else if (vals.length) {\r\n\t\t\t// [10, 10, 10]\r\n\t\t\tvalues[space] = vals.slice(0, space.length);\r\n\t\t\talpha = vals[space.length];\r\n\t\t} else if (vals[space.charAt(0)] !== undefined) {\r\n\t\t\t// {r: 10, g: 10, b: 10}\r\n\t\t\tfor (i = 0; i < space.length; i++) {\r\n\t\t\t\tvalues[space][i] = vals[space.charAt(i)];\r\n\t\t\t}\r\n\r\n\t\t\talpha = vals.a;\r\n\t\t} else if (vals[spaces[space][0]] !== undefined) {\r\n\t\t\t// {red: 10, green: 10, blue: 10}\r\n\t\t\tvar chans = spaces[space];\r\n\r\n\t\t\tfor (i = 0; i < space.length; i++) {\r\n\t\t\t\tvalues[space][i] = vals[chans[i]];\r\n\t\t\t}\r\n\r\n\t\t\talpha = vals.alpha;\r\n\t\t}\r\n\r\n\t\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\r\n\r\n\t\tif (space === 'alpha') {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar capped;\r\n\r\n\t\t// cap values of the space prior converting all values\r\n\t\tfor (i = 0; i < space.length; i++) {\r\n\t\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\r\n\t\t\tvalues[space][i] = Math.round(capped);\r\n\t\t}\r\n\r\n\t\t// convert to all the other color spaces\r\n\t\tfor (var sname in spaces) {\r\n\t\t\tif (sname !== space) {\r\n\t\t\t\tvalues[sname] = convert[space][sname](values[space]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\tColor.prototype.setSpace = function (space, args) {\r\n\t\tvar vals = args[0];\r\n\r\n\t\tif (vals === undefined) {\r\n\t\t\t// color.rgb()\r\n\t\t\treturn this.getValues(space);\r\n\t\t}\r\n\r\n\t\t// color.rgb(10, 10, 10)\r\n\t\tif (typeof vals === 'number') {\r\n\t\t\tvals = Array.prototype.slice.call(args);\r\n\t\t}\r\n\r\n\t\tthis.setValues(space, vals);\r\n\t\treturn this;\r\n\t};\r\n\r\n\tColor.prototype.setChannel = function (space, index, val) {\r\n\t\tvar svalues = this.values[space];\r\n\t\tif (val === undefined) {\r\n\t\t\t// color.red()\r\n\t\t\treturn svalues[index];\r\n\t\t} else if (val === svalues[index]) {\r\n\t\t\t// color.red(color.red())\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\t// color.red(100)\r\n\t\tsvalues[index] = val;\r\n\t\tthis.setValues(space, svalues);\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\treturn Color;\r\n});\ndefine('skylark-chartjs/helpers/helpers.core',[], function () {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = {\n        noop: function () {\n        },\n        uid: function () {\n            var id = 0;\n            return function () {\n                return id++;\n            };\n        }(),\n        isNullOrUndef: function (value) {\n            return value === null || typeof value === 'undefined';\n        },\n        isArray: function (value) {\n            if (Array.isArray && Array.isArray(value)) {\n                return true;\n            }\n            var type = Object.prototype.toString.call(value);\n            if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n                return true;\n            }\n            return false;\n        },\n        isObject: function (value) {\n            return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n        },\n        isFinite: function (value) {\n            return (typeof value === 'number' || value instanceof Number) && isFinite(value);\n        },\n        valueOrDefault: function (value, defaultValue) {\n            return typeof value === 'undefined' ? defaultValue : value;\n        },\n        valueAtIndexOrDefault: function (value, index, defaultValue) {\n            return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\n        },\n        callback: function (fn, args, thisArg) {\n            if (fn && typeof fn.call === 'function') {\n                return fn.apply(thisArg, args);\n            }\n        },\n        each: function (loopable, fn, thisArg, reverse) {\n            var i, len, keys;\n            if (helpers.isArray(loopable)) {\n                len = loopable.length;\n                if (reverse) {\n                    for (i = len - 1; i >= 0; i--) {\n                        fn.call(thisArg, loopable[i], i);\n                    }\n                } else {\n                    for (i = 0; i < len; i++) {\n                        fn.call(thisArg, loopable[i], i);\n                    }\n                }\n            } else if (helpers.isObject(loopable)) {\n                keys = Object.keys(loopable);\n                len = keys.length;\n                for (i = 0; i < len; i++) {\n                    fn.call(thisArg, loopable[keys[i]], keys[i]);\n                }\n            }\n        },\n        arrayEquals: function (a0, a1) {\n            var i, ilen, v0, v1;\n            if (!a0 || !a1 || a0.length !== a1.length) {\n                return false;\n            }\n            for (i = 0, ilen = a0.length; i < ilen; ++i) {\n                v0 = a0[i];\n                v1 = a1[i];\n                if (v0 instanceof Array && v1 instanceof Array) {\n                    if (!helpers.arrayEquals(v0, v1)) {\n                        return false;\n                    }\n                } else if (v0 !== v1) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        clone: function (source) {\n            if (helpers.isArray(source)) {\n                return source.map(helpers.clone);\n            }\n            if (helpers.isObject(source)) {\n                var target = {};\n                var keys = Object.keys(source);\n                var klen = keys.length;\n                var k = 0;\n                for (; k < klen; ++k) {\n                    target[keys[k]] = helpers.clone(source[keys[k]]);\n                }\n                return target;\n            }\n            return source;\n        },\n        _merger: function (key, target, source, options) {\n            var tval = target[key];\n            var sval = source[key];\n            if (helpers.isObject(tval) && helpers.isObject(sval)) {\n                helpers.merge(tval, sval, options);\n            } else {\n                target[key] = helpers.clone(sval);\n            }\n        },\n        _mergerIf: function (key, target, source) {\n            var tval = target[key];\n            var sval = source[key];\n            if (helpers.isObject(tval) && helpers.isObject(sval)) {\n                helpers.mergeIf(tval, sval);\n            } else if (!target.hasOwnProperty(key)) {\n                target[key] = helpers.clone(sval);\n            }\n        },\n        merge: function (target, source, options) {\n            var sources = helpers.isArray(source) ? source : [source];\n            var ilen = sources.length;\n            var merge, i, keys, klen, k;\n            if (!helpers.isObject(target)) {\n                return target;\n            }\n            options = options || {};\n            merge = options.merger || helpers._merger;\n            for (i = 0; i < ilen; ++i) {\n                source = sources[i];\n                if (!helpers.isObject(source)) {\n                    continue;\n                }\n                keys = Object.keys(source);\n                for (k = 0, klen = keys.length; k < klen; ++k) {\n                    merge(keys[k], target, source, options);\n                }\n            }\n            return target;\n        },\n        mergeIf: function (target, source) {\n            return helpers.merge(target, source, { merger: helpers._mergerIf });\n        },\n        extend: function (target) {\n            var setFn = function (value, key) {\n                target[key] = value;\n            };\n            for (var i = 1, ilen = arguments.length; i < ilen; ++i) {\n                helpers.each(arguments[i], setFn);\n            }\n            return target;\n        },\n        inherits: function (extensions) {\n            var me = this;\n            var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {\n                return me.apply(this, arguments);\n            };\n            var Surrogate = function () {\n                this.constructor = ChartElement;\n            };\n            Surrogate.prototype = me.prototype;\n            ChartElement.prototype = new Surrogate();\n            ChartElement.extend = helpers.inherits;\n            if (extensions) {\n                helpers.extend(ChartElement.prototype, extensions);\n            }\n            ChartElement.__super__ = me.prototype;\n            return ChartElement;\n        }\n    };\n    module.exports = helpers;\n    helpers.callCallback = helpers.callback;\n    helpers.indexOf = function (array, item, fromIndex) {\n        return Array.prototype.indexOf.call(array, item, fromIndex);\n    };\n    helpers.getValueOrDefault = helpers.valueOrDefault;\n    helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/helpers/helpers.easing',['./helpers.core'], function (__module__0) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    var effects = {\n        linear: function (t) {\n            return t;\n        },\n        easeInQuad: function (t) {\n            return t * t;\n        },\n        easeOutQuad: function (t) {\n            return -t * (t - 2);\n        },\n        easeInOutQuad: function (t) {\n            if ((t /= 0.5) < 1) {\n                return 0.5 * t * t;\n            }\n            return -0.5 * (--t * (t - 2) - 1);\n        },\n        easeInCubic: function (t) {\n            return t * t * t;\n        },\n        easeOutCubic: function (t) {\n            return (t = t - 1) * t * t + 1;\n        },\n        easeInOutCubic: function (t) {\n            if ((t /= 0.5) < 1) {\n                return 0.5 * t * t * t;\n            }\n            return 0.5 * ((t -= 2) * t * t + 2);\n        },\n        easeInQuart: function (t) {\n            return t * t * t * t;\n        },\n        easeOutQuart: function (t) {\n            return -((t = t - 1) * t * t * t - 1);\n        },\n        easeInOutQuart: function (t) {\n            if ((t /= 0.5) < 1) {\n                return 0.5 * t * t * t * t;\n            }\n            return -0.5 * ((t -= 2) * t * t * t - 2);\n        },\n        easeInQuint: function (t) {\n            return t * t * t * t * t;\n        },\n        easeOutQuint: function (t) {\n            return (t = t - 1) * t * t * t * t + 1;\n        },\n        easeInOutQuint: function (t) {\n            if ((t /= 0.5) < 1) {\n                return 0.5 * t * t * t * t * t;\n            }\n            return 0.5 * ((t -= 2) * t * t * t * t + 2);\n        },\n        easeInSine: function (t) {\n            return -Math.cos(t * (Math.PI / 2)) + 1;\n        },\n        easeOutSine: function (t) {\n            return Math.sin(t * (Math.PI / 2));\n        },\n        easeInOutSine: function (t) {\n            return -0.5 * (Math.cos(Math.PI * t) - 1);\n        },\n        easeInExpo: function (t) {\n            return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));\n        },\n        easeOutExpo: function (t) {\n            return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;\n        },\n        easeInOutExpo: function (t) {\n            if (t === 0) {\n                return 0;\n            }\n            if (t === 1) {\n                return 1;\n            }\n            if ((t /= 0.5) < 1) {\n                return 0.5 * Math.pow(2, 10 * (t - 1));\n            }\n            return 0.5 * (-Math.pow(2, -10 * --t) + 2);\n        },\n        easeInCirc: function (t) {\n            if (t >= 1) {\n                return t;\n            }\n            return -(Math.sqrt(1 - t * t) - 1);\n        },\n        easeOutCirc: function (t) {\n            return Math.sqrt(1 - (t = t - 1) * t);\n        },\n        easeInOutCirc: function (t) {\n            if ((t /= 0.5) < 1) {\n                return -0.5 * (Math.sqrt(1 - t * t) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n        },\n        easeInElastic: function (t) {\n            var s = 1.70158;\n            var p = 0;\n            var a = 1;\n            if (t === 0) {\n                return 0;\n            }\n            if (t === 1) {\n                return 1;\n            }\n            if (!p) {\n                p = 0.3;\n            }\n            if (a < 1) {\n                a = 1;\n                s = p / 4;\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(1 / a);\n            }\n            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n        },\n        easeOutElastic: function (t) {\n            var s = 1.70158;\n            var p = 0;\n            var a = 1;\n            if (t === 0) {\n                return 0;\n            }\n            if (t === 1) {\n                return 1;\n            }\n            if (!p) {\n                p = 0.3;\n            }\n            if (a < 1) {\n                a = 1;\n                s = p / 4;\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(1 / a);\n            }\n            return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n        },\n        easeInOutElastic: function (t) {\n            var s = 1.70158;\n            var p = 0;\n            var a = 1;\n            if (t === 0) {\n                return 0;\n            }\n            if ((t /= 0.5) === 2) {\n                return 1;\n            }\n            if (!p) {\n                p = 0.45;\n            }\n            if (a < 1) {\n                a = 1;\n                s = p / 4;\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(1 / a);\n            }\n            if (t < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\n        },\n        easeInBack: function (t) {\n            var s = 1.70158;\n            return t * t * ((s + 1) * t - s);\n        },\n        easeOutBack: function (t) {\n            var s = 1.70158;\n            return (t = t - 1) * t * ((s + 1) * t + s) + 1;\n        },\n        easeInOutBack: function (t) {\n            var s = 1.70158;\n            if ((t /= 0.5) < 1) {\n                return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n            }\n            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n        },\n        easeInBounce: function (t) {\n            return 1 - effects.easeOutBounce(1 - t);\n        },\n        easeOutBounce: function (t) {\n            if (t < 1 / 2.75) {\n                return 7.5625 * t * t;\n            }\n            if (t < 2 / 2.75) {\n                return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n            }\n            if (t < 2.5 / 2.75) {\n                return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n            }\n            return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n        },\n        easeInOutBounce: function (t) {\n            if (t < 0.5) {\n                return effects.easeInBounce(t * 2) * 0.5;\n            }\n            return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n    module.exports = { effects: effects };\n    helpers.easingEffects = effects;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/helpers/helpers.canvas',['./helpers.core'], function (__module__0) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    var PI = Math.PI;\n    var RAD_PER_DEG = PI / 180;\n    var DOUBLE_PI = PI * 2;\n    var HALF_PI = PI / 2;\n    var QUARTER_PI = PI / 4;\n    var TWO_THIRDS_PI = PI * 2 / 3;\n    var exports = {\n        clear: function (chart) {\n            chart.ctx.clearRect(0, 0, chart.width, chart.height);\n        },\n        roundedRect: function (ctx, x, y, width, height, radius) {\n            if (radius) {\n                var r = Math.min(radius, height / 2, width / 2);\n                var left = x + r;\n                var top = y + r;\n                var right = x + width - r;\n                var bottom = y + height - r;\n                ctx.moveTo(x, top);\n                if (left < right && top < bottom) {\n                    ctx.arc(left, top, r, -PI, -HALF_PI);\n                    ctx.arc(right, top, r, -HALF_PI, 0);\n                    ctx.arc(right, bottom, r, 0, HALF_PI);\n                    ctx.arc(left, bottom, r, HALF_PI, PI);\n                } else if (left < right) {\n                    ctx.moveTo(left, y);\n                    ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n                    ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);\n                } else if (top < bottom) {\n                    ctx.arc(left, top, r, -PI, 0);\n                    ctx.arc(left, bottom, r, 0, PI);\n                } else {\n                    ctx.arc(left, top, r, -PI, PI);\n                }\n                ctx.closePath();\n                ctx.moveTo(x, y);\n            } else {\n                ctx.rect(x, y, width, height);\n            }\n        },\n        drawPoint: function (ctx, style, radius, x, y, rotation) {\n            var type, xOffset, yOffset, size, cornerRadius;\n            var rad = (rotation || 0) * RAD_PER_DEG;\n            if (style && typeof style === 'object') {\n                type = style.toString();\n                if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n                    ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);\n                    return;\n                }\n            }\n            if (isNaN(radius) || radius <= 0) {\n                return;\n            }\n            ctx.beginPath();\n            switch (style) {\n            default:\n                ctx.arc(x, y, radius, 0, DOUBLE_PI);\n                ctx.closePath();\n                break;\n            case 'triangle':\n                ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n                rad += TWO_THIRDS_PI;\n                ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n                rad += TWO_THIRDS_PI;\n                ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n                ctx.closePath();\n                break;\n            case 'rectRounded':\n                cornerRadius = radius * 0.516;\n                size = radius - cornerRadius;\n                xOffset = Math.cos(rad + QUARTER_PI) * size;\n                yOffset = Math.sin(rad + QUARTER_PI) * size;\n                ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n                ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n                ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n                ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n                ctx.closePath();\n                break;\n            case 'rect':\n                if (!rotation) {\n                    size = Math.SQRT1_2 * radius;\n                    ctx.rect(x - size, y - size, 2 * size, 2 * size);\n                    break;\n                }\n                rad += QUARTER_PI;\n            case 'rectRot':\n                xOffset = Math.cos(rad) * radius;\n                yOffset = Math.sin(rad) * radius;\n                ctx.moveTo(x - xOffset, y - yOffset);\n                ctx.lineTo(x + yOffset, y - xOffset);\n                ctx.lineTo(x + xOffset, y + yOffset);\n                ctx.lineTo(x - yOffset, y + xOffset);\n                ctx.closePath();\n                break;\n            case 'crossRot':\n                rad += QUARTER_PI;\n            case 'cross':\n                xOffset = Math.cos(rad) * radius;\n                yOffset = Math.sin(rad) * radius;\n                ctx.moveTo(x - xOffset, y - yOffset);\n                ctx.lineTo(x + xOffset, y + yOffset);\n                ctx.moveTo(x + yOffset, y - xOffset);\n                ctx.lineTo(x - yOffset, y + xOffset);\n                break;\n            case 'star':\n                xOffset = Math.cos(rad) * radius;\n                yOffset = Math.sin(rad) * radius;\n                ctx.moveTo(x - xOffset, y - yOffset);\n                ctx.lineTo(x + xOffset, y + yOffset);\n                ctx.moveTo(x + yOffset, y - xOffset);\n                ctx.lineTo(x - yOffset, y + xOffset);\n                rad += QUARTER_PI;\n                xOffset = Math.cos(rad) * radius;\n                yOffset = Math.sin(rad) * radius;\n                ctx.moveTo(x - xOffset, y - yOffset);\n                ctx.lineTo(x + xOffset, y + yOffset);\n                ctx.moveTo(x + yOffset, y - xOffset);\n                ctx.lineTo(x - yOffset, y + xOffset);\n                break;\n            case 'line':\n                xOffset = Math.cos(rad) * radius;\n                yOffset = Math.sin(rad) * radius;\n                ctx.moveTo(x - xOffset, y - yOffset);\n                ctx.lineTo(x + xOffset, y + yOffset);\n                break;\n            case 'dash':\n                ctx.moveTo(x, y);\n                ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n                break;\n            }\n            ctx.fill();\n            ctx.stroke();\n        },\n        _isPointInArea: function (point, area) {\n            var epsilon = 0.000001;\n            return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;\n        },\n        clipArea: function (ctx, area) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n            ctx.clip();\n        },\n        unclipArea: function (ctx) {\n            ctx.restore();\n        },\n        lineTo: function (ctx, previous, target, flip) {\n            var stepped = target.steppedLine;\n            if (stepped) {\n                if (stepped === 'middle') {\n                    var midpoint = (previous.x + target.x) / 2;\n                    ctx.lineTo(midpoint, flip ? target.y : previous.y);\n                    ctx.lineTo(midpoint, flip ? previous.y : target.y);\n                } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {\n                    ctx.lineTo(previous.x, target.y);\n                } else {\n                    ctx.lineTo(target.x, previous.y);\n                }\n                ctx.lineTo(target.x, target.y);\n                return;\n            }\n            if (!target.tension) {\n                ctx.lineTo(target.x, target.y);\n                return;\n            }\n            ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);\n        }\n    };\n    module.exports = exports;\n    helpers.clear = exports.clear;\n    helpers.drawRoundedRectangle = function (ctx) {\n        ctx.beginPath();\n        exports.roundedRect.apply(exports, arguments);\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.defaults',['../helpers/helpers.core'], function (__module__0) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    var defaults = {\n        _set: function (scope, values) {\n            return helpers.merge(this[scope] || (this[scope] = {}), values);\n        }\n    };\n    defaults._set('global', {\n        defaultColor: 'rgba(0,0,0,0.1)',\n        defaultFontColor: '#666',\n        defaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n        defaultFontSize: 12,\n        defaultFontStyle: 'normal',\n        defaultLineHeight: 1.2,\n        showLines: true\n    });\n    module.exports = defaults;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/helpers/helpers.options',[\n    '../core/core.defaults',\n    './helpers.core'\n], function (__module__0, __module__1) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var helpers = __module__1;\n    var valueOrDefault = helpers.valueOrDefault;\n    function toFontString(font) {\n        if (!font || helpers.isNullOrUndef(font.size) || helpers.isNullOrUndef(font.family)) {\n            return null;\n        }\n        return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n    }\n    module.exports = {\n        toLineHeight: function (value, size) {\n            var matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\n            if (!matches || matches[1] === 'normal') {\n                return size * 1.2;\n            }\n            value = +matches[2];\n            switch (matches[3]) {\n            case 'px':\n                return value;\n            case '%':\n                value /= 100;\n                break;\n            default:\n                break;\n            }\n            return size * value;\n        },\n        toPadding: function (value) {\n            var t, r, b, l;\n            if (helpers.isObject(value)) {\n                t = +value.top || 0;\n                r = +value.right || 0;\n                b = +value.bottom || 0;\n                l = +value.left || 0;\n            } else {\n                t = r = b = l = +value || 0;\n            }\n            return {\n                top: t,\n                right: r,\n                bottom: b,\n                left: l,\n                height: t + b,\n                width: l + r\n            };\n        },\n        _parseFont: function (options) {\n            var globalDefaults = defaults.global;\n            var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n            var font = {\n                family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),\n                lineHeight: helpers.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),\n                size: size,\n                style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),\n                weight: null,\n                string: ''\n            };\n            font.string = toFontString(font);\n            return font;\n        },\n        resolve: function (inputs, context, index) {\n            var i, ilen, value;\n            for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n                value = inputs[i];\n                if (value === undefined) {\n                    continue;\n                }\n                if (context !== undefined && typeof value === 'function') {\n                    value = value(context);\n                }\n                if (index !== undefined && helpers.isArray(value)) {\n                    value = value[index];\n                }\n                if (value !== undefined) {\n                    return value;\n                }\n            }\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/helpers/index',[\n    './helpers.core',\n    './helpers.easing',\n    './helpers.canvas',\n    './helpers.options'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    module.exports = __module__0;\n    module.exports.easing = __module__1;\n    module.exports.canvas = __module__2;\n    module.exports.options = __module__3;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.element',[\n    '../../packages/chartjs-color',\n    '../helpers/index'\n], function (__module__0, __module__1) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var color = __module__0;\n    var helpers = __module__1;\n    function interpolate(start, view, model, ease) {\n        var keys = Object.keys(model);\n        var i, ilen, key, actual, origin, target, type, c0, c1;\n        for (i = 0, ilen = keys.length; i < ilen; ++i) {\n            key = keys[i];\n            target = model[key];\n            if (!view.hasOwnProperty(key)) {\n                view[key] = target;\n            }\n            actual = view[key];\n            if (actual === target || key[0] === '_') {\n                continue;\n            }\n            if (!start.hasOwnProperty(key)) {\n                start[key] = actual;\n            }\n            origin = start[key];\n            type = typeof target;\n            if (type === typeof origin) {\n                if (type === 'string') {\n                    c0 = color(origin);\n                    if (c0.valid) {\n                        c1 = color(target);\n                        if (c1.valid) {\n                            view[key] = c1.mix(c0, ease).rgbString();\n                            continue;\n                        }\n                    }\n                } else if (helpers.isFinite(origin) && helpers.isFinite(target)) {\n                    view[key] = origin + (target - origin) * ease;\n                    continue;\n                }\n            }\n            view[key] = target;\n        }\n    }\n    var Element = function (configuration) {\n        helpers.extend(this, configuration);\n        this.initialize.apply(this, arguments);\n    };\n    helpers.extend(Element.prototype, {\n        initialize: function () {\n            this.hidden = false;\n        },\n        pivot: function () {\n            var me = this;\n            if (!me._view) {\n                me._view = helpers.clone(me._model);\n            }\n            me._start = {};\n            return me;\n        },\n        transition: function (ease) {\n            var me = this;\n            var model = me._model;\n            var start = me._start;\n            var view = me._view;\n            if (!model || ease === 1) {\n                me._view = model;\n                me._start = null;\n                return me;\n            }\n            if (!view) {\n                view = me._view = {};\n            }\n            if (!start) {\n                start = me._start = {};\n            }\n            interpolate(start, view, model, ease);\n            return me;\n        },\n        tooltipPosition: function () {\n            return {\n                x: this._model.x,\n                y: this._model.y\n            };\n        },\n        hasValue: function () {\n            return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\n        }\n    });\n    Element.extend = helpers.inherits;\n    module.exports = Element;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.animation',['./core.element'], function (__module__0) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var Element = __module__0;\n    var exports = Element.extend({\n        chart: null,\n        currentStep: 0,\n        numSteps: 60,\n        easing: '',\n        render: null,\n        onAnimationProgress: null,\n        onAnimationComplete: null\n    });\n    module.exports = exports;\n    Object.defineProperty(exports.prototype, 'animationObject', {\n        get: function () {\n            return this;\n        }\n    });\n    Object.defineProperty(exports.prototype, 'chartInstance', {\n        get: function () {\n            return this.chart;\n        },\n        set: function (value) {\n            this.chart = value;\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.animations',[\n    './core.defaults',\n    '../helpers/index'\n], function (__module__0, __module__1) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var helpers = __module__1;\n    defaults._set('global', {\n        animation: {\n            duration: 1000,\n            easing: 'easeOutQuart',\n            onProgress: helpers.noop,\n            onComplete: helpers.noop\n        }\n    });\n    module.exports = {\n        animations: [],\n        request: null,\n        addAnimation: function (chart, animation, duration, lazy) {\n            var animations = this.animations;\n            var i, ilen;\n            animation.chart = chart;\n            animation.startTime = Date.now();\n            animation.duration = duration;\n            if (!lazy) {\n                chart.animating = true;\n            }\n            for (i = 0, ilen = animations.length; i < ilen; ++i) {\n                if (animations[i].chart === chart) {\n                    animations[i] = animation;\n                    return;\n                }\n            }\n            animations.push(animation);\n            if (animations.length === 1) {\n                this.requestAnimationFrame();\n            }\n        },\n        cancelAnimation: function (chart) {\n            var index = helpers.findIndex(this.animations, function (animation) {\n                return animation.chart === chart;\n            });\n            if (index !== -1) {\n                this.animations.splice(index, 1);\n                chart.animating = false;\n            }\n        },\n        requestAnimationFrame: function () {\n            var me = this;\n            if (me.request === null) {\n                me.request = helpers.requestAnimFrame.call(window, function () {\n                    me.request = null;\n                    me.startDigest();\n                });\n            }\n        },\n        startDigest: function () {\n            var me = this;\n            me.advance();\n            if (me.animations.length > 0) {\n                me.requestAnimationFrame();\n            }\n        },\n        advance: function () {\n            var animations = this.animations;\n            var animation, chart, numSteps, nextStep;\n            var i = 0;\n            while (i < animations.length) {\n                animation = animations[i];\n                chart = animation.chart;\n                numSteps = animation.numSteps;\n                nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;\n                animation.currentStep = Math.min(nextStep, numSteps);\n                helpers.callback(animation.render, [\n                    chart,\n                    animation\n                ], chart);\n                helpers.callback(animation.onAnimationProgress, [animation], chart);\n                if (animation.currentStep >= numSteps) {\n                    helpers.callback(animation.onAnimationComplete, [animation], chart);\n                    chart.animating = false;\n                    animations.splice(i, 1);\n                } else {\n                    ++i;\n                }\n            }\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.datasetController',['../helpers/index'], function (__module__0) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    var resolve = helpers.options.resolve;\n    var arrayEvents = [\n        'push',\n        'pop',\n        'shift',\n        'splice',\n        'unshift'\n    ];\n    function listenArrayEvents(array, listener) {\n        if (array._chartjs) {\n            array._chartjs.listeners.push(listener);\n            return;\n        }\n        Object.defineProperty(array, '_chartjs', {\n            configurable: true,\n            enumerable: false,\n            value: { listeners: [listener] }\n        });\n        arrayEvents.forEach(function (key) {\n            var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n            var base = array[key];\n            Object.defineProperty(array, key, {\n                configurable: true,\n                enumerable: false,\n                value: function () {\n                    var args = Array.prototype.slice.call(arguments);\n                    var res = base.apply(this, args);\n                    helpers.each(array._chartjs.listeners, function (object) {\n                        if (typeof object[method] === 'function') {\n                            object[method].apply(object, args);\n                        }\n                    });\n                    return res;\n                }\n            });\n        });\n    }\n    function unlistenArrayEvents(array, listener) {\n        var stub = array._chartjs;\n        if (!stub) {\n            return;\n        }\n        var listeners = stub.listeners;\n        var index = listeners.indexOf(listener);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n        if (listeners.length > 0) {\n            return;\n        }\n        arrayEvents.forEach(function (key) {\n            delete array[key];\n        });\n        delete array._chartjs;\n    }\n    var DatasetController = function (chart, datasetIndex) {\n        this.initialize(chart, datasetIndex);\n    };\n    helpers.extend(DatasetController.prototype, {\n        datasetElementType: null,\n        dataElementType: null,\n        initialize: function (chart, datasetIndex) {\n            var me = this;\n            me.chart = chart;\n            me.index = datasetIndex;\n            me.linkScales();\n            me.addElements();\n        },\n        updateIndex: function (datasetIndex) {\n            this.index = datasetIndex;\n        },\n        linkScales: function () {\n            var me = this;\n            var meta = me.getMeta();\n            var dataset = me.getDataset();\n            if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {\n                meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n            }\n            if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {\n                meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n            }\n        },\n        getDataset: function () {\n            return this.chart.data.datasets[this.index];\n        },\n        getMeta: function () {\n            return this.chart.getDatasetMeta(this.index);\n        },\n        getScaleForId: function (scaleID) {\n            return this.chart.scales[scaleID];\n        },\n        _getValueScaleId: function () {\n            return this.getMeta().yAxisID;\n        },\n        _getIndexScaleId: function () {\n            return this.getMeta().xAxisID;\n        },\n        _getValueScale: function () {\n            return this.getScaleForId(this._getValueScaleId());\n        },\n        _getIndexScale: function () {\n            return this.getScaleForId(this._getIndexScaleId());\n        },\n        reset: function () {\n            this.update(true);\n        },\n        destroy: function () {\n            if (this._data) {\n                unlistenArrayEvents(this._data, this);\n            }\n        },\n        createMetaDataset: function () {\n            var me = this;\n            var type = me.datasetElementType;\n            return type && new type({\n                _chart: me.chart,\n                _datasetIndex: me.index\n            });\n        },\n        createMetaData: function (index) {\n            var me = this;\n            var type = me.dataElementType;\n            return type && new type({\n                _chart: me.chart,\n                _datasetIndex: me.index,\n                _index: index\n            });\n        },\n        addElements: function () {\n            var me = this;\n            var meta = me.getMeta();\n            var data = me.getDataset().data || [];\n            var metaData = meta.data;\n            var i, ilen;\n            for (i = 0, ilen = data.length; i < ilen; ++i) {\n                metaData[i] = metaData[i] || me.createMetaData(i);\n            }\n            meta.dataset = meta.dataset || me.createMetaDataset();\n        },\n        addElementAndReset: function (index) {\n            var element = this.createMetaData(index);\n            this.getMeta().data.splice(index, 0, element);\n            this.updateElement(element, index, true);\n        },\n        buildOrUpdateElements: function () {\n            var me = this;\n            var dataset = me.getDataset();\n            var data = dataset.data || (dataset.data = []);\n            if (me._data !== data) {\n                if (me._data) {\n                    unlistenArrayEvents(me._data, me);\n                }\n                if (data && Object.isExtensible(data)) {\n                    listenArrayEvents(data, me);\n                }\n                me._data = data;\n            }\n            me.resyncElements();\n        },\n        update: helpers.noop,\n        transition: function (easingValue) {\n            var meta = this.getMeta();\n            var elements = meta.data || [];\n            var ilen = elements.length;\n            var i = 0;\n            for (; i < ilen; ++i) {\n                elements[i].transition(easingValue);\n            }\n            if (meta.dataset) {\n                meta.dataset.transition(easingValue);\n            }\n        },\n        draw: function () {\n            var meta = this.getMeta();\n            var elements = meta.data || [];\n            var ilen = elements.length;\n            var i = 0;\n            if (meta.dataset) {\n                meta.dataset.draw();\n            }\n            for (; i < ilen; ++i) {\n                elements[i].draw();\n            }\n        },\n        removeHoverStyle: function (element) {\n            helpers.merge(element._model, element.$previousStyle || {});\n            delete element.$previousStyle;\n        },\n        setHoverStyle: function (element) {\n            var dataset = this.chart.data.datasets[element._datasetIndex];\n            var index = element._index;\n            var custom = element.custom || {};\n            var model = element._model;\n            var getHoverColor = helpers.getHoverColor;\n            element.$previousStyle = {\n                backgroundColor: model.backgroundColor,\n                borderColor: model.borderColor,\n                borderWidth: model.borderWidth\n            };\n            model.backgroundColor = resolve([\n                custom.hoverBackgroundColor,\n                dataset.hoverBackgroundColor,\n                getHoverColor(model.backgroundColor)\n            ], undefined, index);\n            model.borderColor = resolve([\n                custom.hoverBorderColor,\n                dataset.hoverBorderColor,\n                getHoverColor(model.borderColor)\n            ], undefined, index);\n            model.borderWidth = resolve([\n                custom.hoverBorderWidth,\n                dataset.hoverBorderWidth,\n                model.borderWidth\n            ], undefined, index);\n        },\n        resyncElements: function () {\n            var me = this;\n            var meta = me.getMeta();\n            var data = me.getDataset().data;\n            var numMeta = meta.data.length;\n            var numData = data.length;\n            if (numData < numMeta) {\n                meta.data.splice(numData, numMeta - numData);\n            } else if (numData > numMeta) {\n                me.insertElements(numMeta, numData - numMeta);\n            }\n        },\n        insertElements: function (start, count) {\n            for (var i = 0; i < count; ++i) {\n                this.addElementAndReset(start + i);\n            }\n        },\n        onDataPush: function () {\n            var count = arguments.length;\n            this.insertElements(this.getDataset().data.length - count, count);\n        },\n        onDataPop: function () {\n            this.getMeta().data.pop();\n        },\n        onDataShift: function () {\n            this.getMeta().data.shift();\n        },\n        onDataSplice: function (start, count) {\n            this.getMeta().data.splice(start, count);\n            this.insertElements(start, arguments.length - 2);\n        },\n        onDataUnshift: function () {\n            this.insertElements(0, arguments.length);\n        }\n    });\n    DatasetController.extend = helpers.inherits;\n    module.exports = DatasetController;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/elements/element.arc',[\n    '../core/core.defaults',\n    '../core/core.element',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var Element = __module__1;\n    var helpers = __module__2;\n    defaults._set('global', {\n        elements: {\n            arc: {\n                backgroundColor: defaults.global.defaultColor,\n                borderColor: '#fff',\n                borderWidth: 2,\n                borderAlign: 'center'\n            }\n        }\n    });\n    module.exports = Element.extend({\n        inLabelRange: function (mouseX) {\n            var vm = this._view;\n            if (vm) {\n                return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);\n            }\n            return false;\n        },\n        inRange: function (chartX, chartY) {\n            var vm = this._view;\n            if (vm) {\n                var pointRelativePosition = helpers.getAngleFromPoint(vm, {\n                    x: chartX,\n                    y: chartY\n                });\n                var angle = pointRelativePosition.angle;\n                var distance = pointRelativePosition.distance;\n                var startAngle = vm.startAngle;\n                var endAngle = vm.endAngle;\n                while (endAngle < startAngle) {\n                    endAngle += 2 * Math.PI;\n                }\n                while (angle > endAngle) {\n                    angle -= 2 * Math.PI;\n                }\n                while (angle < startAngle) {\n                    angle += 2 * Math.PI;\n                }\n                var betweenAngles = angle >= startAngle && angle <= endAngle;\n                var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;\n                return betweenAngles && withinRadius;\n            }\n            return false;\n        },\n        getCenterPoint: function () {\n            var vm = this._view;\n            var halfAngle = (vm.startAngle + vm.endAngle) / 2;\n            var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n            return {\n                x: vm.x + Math.cos(halfAngle) * halfRadius,\n                y: vm.y + Math.sin(halfAngle) * halfRadius\n            };\n        },\n        getArea: function () {\n            var vm = this._view;\n            return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n        },\n        tooltipPosition: function () {\n            var vm = this._view;\n            var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;\n            var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n            return {\n                x: vm.x + Math.cos(centreAngle) * rangeFromCentre,\n                y: vm.y + Math.sin(centreAngle) * rangeFromCentre\n            };\n        },\n        draw: function () {\n            var ctx = this._chart.ctx;\n            var vm = this._view;\n            var sA = vm.startAngle;\n            var eA = vm.endAngle;\n            var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;\n            var angleMargin;\n            ctx.save();\n            ctx.beginPath();\n            ctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);\n            ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n            ctx.closePath();\n            ctx.fillStyle = vm.backgroundColor;\n            ctx.fill();\n            if (vm.borderWidth) {\n                if (vm.borderAlign === 'inner') {\n                    ctx.beginPath();\n                    angleMargin = pixelMargin / vm.outerRadius;\n                    ctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);\n                    if (vm.innerRadius > pixelMargin) {\n                        angleMargin = pixelMargin / vm.innerRadius;\n                        ctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);\n                    } else {\n                        ctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);\n                    }\n                    ctx.closePath();\n                    ctx.clip();\n                    ctx.beginPath();\n                    ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n                    ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n                    ctx.closePath();\n                    ctx.lineWidth = vm.borderWidth * 2;\n                    ctx.lineJoin = 'round';\n                } else {\n                    ctx.lineWidth = vm.borderWidth;\n                    ctx.lineJoin = 'bevel';\n                }\n                ctx.strokeStyle = vm.borderColor;\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/elements/element.line',[\n    '../core/core.defaults',\n    '../core/core.element',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var Element = __module__1;\n    var helpers = __module__2;\n    var valueOrDefault = helpers.valueOrDefault;\n    var defaultColor = defaults.global.defaultColor;\n    defaults._set('global', {\n        elements: {\n            line: {\n                tension: 0.4,\n                backgroundColor: defaultColor,\n                borderWidth: 3,\n                borderColor: defaultColor,\n                borderCapStyle: 'butt',\n                borderDash: [],\n                borderDashOffset: 0,\n                borderJoinStyle: 'miter',\n                capBezierPoints: true,\n                fill: true\n            }\n        }\n    });\n    module.exports = Element.extend({\n        draw: function () {\n            var me = this;\n            var vm = me._view;\n            var ctx = me._chart.ctx;\n            var spanGaps = vm.spanGaps;\n            var points = me._children.slice();\n            var globalDefaults = defaults.global;\n            var globalOptionLineElements = globalDefaults.elements.line;\n            var lastDrawnIndex = -1;\n            var index, current, previous, currentVM;\n            if (me._loop && points.length) {\n                points.push(points[0]);\n            }\n            ctx.save();\n            ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n            if (ctx.setLineDash) {\n                ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n            }\n            ctx.lineDashOffset = valueOrDefault(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);\n            ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n            ctx.lineWidth = valueOrDefault(vm.borderWidth, globalOptionLineElements.borderWidth);\n            ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n            ctx.beginPath();\n            lastDrawnIndex = -1;\n            for (index = 0; index < points.length; ++index) {\n                current = points[index];\n                previous = helpers.previousItem(points, index);\n                currentVM = current._view;\n                if (index === 0) {\n                    if (!currentVM.skip) {\n                        ctx.moveTo(currentVM.x, currentVM.y);\n                        lastDrawnIndex = index;\n                    }\n                } else {\n                    previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n                    if (!currentVM.skip) {\n                        if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {\n                            ctx.moveTo(currentVM.x, currentVM.y);\n                        } else {\n                            helpers.canvas.lineTo(ctx, previous._view, current._view);\n                        }\n                        lastDrawnIndex = index;\n                    }\n                }\n            }\n            ctx.stroke();\n            ctx.restore();\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/elements/element.point',[\n    '../core/core.defaults',\n    '../core/core.element',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var Element = __module__1;\n    var helpers = __module__2;\n    var valueOrDefault = helpers.valueOrDefault;\n    var defaultColor = defaults.global.defaultColor;\n    defaults._set('global', {\n        elements: {\n            point: {\n                radius: 3,\n                pointStyle: 'circle',\n                backgroundColor: defaultColor,\n                borderColor: defaultColor,\n                borderWidth: 1,\n                hitRadius: 1,\n                hoverRadius: 4,\n                hoverBorderWidth: 1\n            }\n        }\n    });\n    function xRange(mouseX) {\n        var vm = this._view;\n        return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;\n    }\n    function yRange(mouseY) {\n        var vm = this._view;\n        return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;\n    }\n    module.exports = Element.extend({\n        inRange: function (mouseX, mouseY) {\n            var vm = this._view;\n            return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;\n        },\n        inLabelRange: xRange,\n        inXRange: xRange,\n        inYRange: yRange,\n        getCenterPoint: function () {\n            var vm = this._view;\n            return {\n                x: vm.x,\n                y: vm.y\n            };\n        },\n        getArea: function () {\n            return Math.PI * Math.pow(this._view.radius, 2);\n        },\n        tooltipPosition: function () {\n            var vm = this._view;\n            return {\n                x: vm.x,\n                y: vm.y,\n                padding: vm.radius + vm.borderWidth\n            };\n        },\n        draw: function (chartArea) {\n            var vm = this._view;\n            var ctx = this._chart.ctx;\n            var pointStyle = vm.pointStyle;\n            var rotation = vm.rotation;\n            var radius = vm.radius;\n            var x = vm.x;\n            var y = vm.y;\n            var globalDefaults = defaults.global;\n            var defaultColor = globalDefaults.defaultColor;\n            if (vm.skip) {\n                return;\n            }\n            if (chartArea === undefined || helpers.canvas._isPointInArea(vm, chartArea)) {\n                ctx.strokeStyle = vm.borderColor || defaultColor;\n                ctx.lineWidth = valueOrDefault(vm.borderWidth, globalDefaults.elements.point.borderWidth);\n                ctx.fillStyle = vm.backgroundColor || defaultColor;\n                helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);\n            }\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/elements/element.rectangle',[\n    '../core/core.defaults',\n    '../core/core.element',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var Element = __module__1;\n    var helpers = __module__2;\n    var defaultColor = defaults.global.defaultColor;\n    defaults._set('global', {\n        elements: {\n            rectangle: {\n                backgroundColor: defaultColor,\n                borderColor: defaultColor,\n                borderSkipped: 'bottom',\n                borderWidth: 0\n            }\n        }\n    });\n    function isVertical(vm) {\n        return vm && vm.width !== undefined;\n    }\n    function getBarBounds(vm) {\n        var x1, x2, y1, y2, half;\n        if (isVertical(vm)) {\n            half = vm.width / 2;\n            x1 = vm.x - half;\n            x2 = vm.x + half;\n            y1 = Math.min(vm.y, vm.base);\n            y2 = Math.max(vm.y, vm.base);\n        } else {\n            half = vm.height / 2;\n            x1 = Math.min(vm.x, vm.base);\n            x2 = Math.max(vm.x, vm.base);\n            y1 = vm.y - half;\n            y2 = vm.y + half;\n        }\n        return {\n            left: x1,\n            top: y1,\n            right: x2,\n            bottom: y2\n        };\n    }\n    function swap(orig, v1, v2) {\n        return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n    }\n    function parseBorderSkipped(vm) {\n        var edge = vm.borderSkipped;\n        var res = {};\n        if (!edge) {\n            return res;\n        }\n        if (vm.horizontal) {\n            if (vm.base > vm.x) {\n                edge = swap(edge, 'left', 'right');\n            }\n        } else if (vm.base < vm.y) {\n            edge = swap(edge, 'bottom', 'top');\n        }\n        res[edge] = true;\n        return res;\n    }\n    function parseBorderWidth(vm, maxW, maxH) {\n        var value = vm.borderWidth;\n        var skip = parseBorderSkipped(vm);\n        var t, r, b, l;\n        if (helpers.isObject(value)) {\n            t = +value.top || 0;\n            r = +value.right || 0;\n            b = +value.bottom || 0;\n            l = +value.left || 0;\n        } else {\n            t = r = b = l = +value || 0;\n        }\n        return {\n            t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,\n            r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,\n            b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,\n            l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l\n        };\n    }\n    function boundingRects(vm) {\n        var bounds = getBarBounds(vm);\n        var width = bounds.right - bounds.left;\n        var height = bounds.bottom - bounds.top;\n        var border = parseBorderWidth(vm, width / 2, height / 2);\n        return {\n            outer: {\n                x: bounds.left,\n                y: bounds.top,\n                w: width,\n                h: height\n            },\n            inner: {\n                x: bounds.left + border.l,\n                y: bounds.top + border.t,\n                w: width - border.l - border.r,\n                h: height - border.t - border.b\n            }\n        };\n    }\n    function inRange(vm, x, y) {\n        var skipX = x === null;\n        var skipY = y === null;\n        var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);\n        return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);\n    }\n    module.exports = Element.extend({\n        draw: function () {\n            var ctx = this._chart.ctx;\n            var vm = this._view;\n            var rects = boundingRects(vm);\n            var outer = rects.outer;\n            var inner = rects.inner;\n            ctx.fillStyle = vm.backgroundColor;\n            ctx.fillRect(outer.x, outer.y, outer.w, outer.h);\n            if (outer.w === inner.w && outer.h === inner.h) {\n                return;\n            }\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(outer.x, outer.y, outer.w, outer.h);\n            ctx.clip();\n            ctx.fillStyle = vm.borderColor;\n            ctx.rect(inner.x, inner.y, inner.w, inner.h);\n            ctx.fill('evenodd');\n            ctx.restore();\n        },\n        height: function () {\n            var vm = this._view;\n            return vm.base - vm.y;\n        },\n        inRange: function (mouseX, mouseY) {\n            return inRange(this._view, mouseX, mouseY);\n        },\n        inLabelRange: function (mouseX, mouseY) {\n            var vm = this._view;\n            return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);\n        },\n        inXRange: function (mouseX) {\n            return inRange(this._view, mouseX, null);\n        },\n        inYRange: function (mouseY) {\n            return inRange(this._view, null, mouseY);\n        },\n        getCenterPoint: function () {\n            var vm = this._view;\n            var x, y;\n            if (isVertical(vm)) {\n                x = vm.x;\n                y = (vm.y + vm.base) / 2;\n            } else {\n                x = (vm.x + vm.base) / 2;\n                y = vm.y;\n            }\n            return {\n                x: x,\n                y: y\n            };\n        },\n        getArea: function () {\n            var vm = this._view;\n            return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);\n        },\n        tooltipPosition: function () {\n            var vm = this._view;\n            return {\n                x: vm.x,\n                y: vm.y\n            };\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/elements/index',[\n    './element.arc',\n    './element.line',\n    './element.point',\n    './element.rectangle'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    module.exports = {};\n    module.exports.Arc = __module__0;\n    module.exports.Line = __module__1;\n    module.exports.Point = __module__2;\n    module.exports.Rectangle = __module__3;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/controllers/controller.bar',[\n    '../core/core.datasetController',\n    '../core/core.defaults',\n    '../elements/index',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var DatasetController = __module__0;\n    var defaults = __module__1;\n    var elements = __module__2;\n    var helpers = __module__3;\n    var resolve = helpers.options.resolve;\n    defaults._set('bar', {\n        hover: { mode: 'label' },\n        scales: {\n            xAxes: [{\n                    type: 'category',\n                    categoryPercentage: 0.8,\n                    barPercentage: 0.9,\n                    offset: true,\n                    gridLines: { offsetGridLines: true }\n                }],\n            yAxes: [{ type: 'linear' }]\n        }\n    });\n    function computeMinSampleSize(scale, pixels) {\n        var min = scale.isHorizontal() ? scale.width : scale.height;\n        var ticks = scale.getTicks();\n        var prev, curr, i, ilen;\n        for (i = 1, ilen = pixels.length; i < ilen; ++i) {\n            min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));\n        }\n        for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n            curr = scale.getPixelForTick(i);\n            min = i > 0 ? Math.min(min, curr - prev) : min;\n            prev = curr;\n        }\n        return min;\n    }\n    function computeFitCategoryTraits(index, ruler, options) {\n        var thickness = options.barThickness;\n        var count = ruler.stackCount;\n        var curr = ruler.pixels[index];\n        var size, ratio;\n        if (helpers.isNullOrUndef(thickness)) {\n            size = ruler.min * options.categoryPercentage;\n            ratio = options.barPercentage;\n        } else {\n            size = thickness * count;\n            ratio = 1;\n        }\n        return {\n            chunk: size / count,\n            ratio: ratio,\n            start: curr - size / 2\n        };\n    }\n    function computeFlexCategoryTraits(index, ruler, options) {\n        var pixels = ruler.pixels;\n        var curr = pixels[index];\n        var prev = index > 0 ? pixels[index - 1] : null;\n        var next = index < pixels.length - 1 ? pixels[index + 1] : null;\n        var percent = options.categoryPercentage;\n        var start, size;\n        if (prev === null) {\n            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n        }\n        if (next === null) {\n            next = curr + curr - prev;\n        }\n        start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n        size = Math.abs(next - prev) / 2 * percent;\n        return {\n            chunk: size / ruler.stackCount,\n            ratio: options.barPercentage,\n            start: start\n        };\n    }\n    module.exports = DatasetController.extend({\n        dataElementType: elements.Rectangle,\n        initialize: function () {\n            var me = this;\n            var meta;\n            DatasetController.prototype.initialize.apply(me, arguments);\n            meta = me.getMeta();\n            meta.stack = me.getDataset().stack;\n            meta.bar = true;\n        },\n        update: function (reset) {\n            var me = this;\n            var rects = me.getMeta().data;\n            var i, ilen;\n            me._ruler = me.getRuler();\n            for (i = 0, ilen = rects.length; i < ilen; ++i) {\n                me.updateElement(rects[i], i, reset);\n            }\n        },\n        updateElement: function (rectangle, index, reset) {\n            var me = this;\n            var meta = me.getMeta();\n            var dataset = me.getDataset();\n            var options = me._resolveElementOptions(rectangle, index);\n            rectangle._xScale = me.getScaleForId(meta.xAxisID);\n            rectangle._yScale = me.getScaleForId(meta.yAxisID);\n            rectangle._datasetIndex = me.index;\n            rectangle._index = index;\n            rectangle._model = {\n                backgroundColor: options.backgroundColor,\n                borderColor: options.borderColor,\n                borderSkipped: options.borderSkipped,\n                borderWidth: options.borderWidth,\n                datasetLabel: dataset.label,\n                label: me.chart.data.labels[index]\n            };\n            me._updateElementGeometry(rectangle, index, reset);\n            rectangle.pivot();\n        },\n        _updateElementGeometry: function (rectangle, index, reset) {\n            var me = this;\n            var model = rectangle._model;\n            var vscale = me._getValueScale();\n            var base = vscale.getBasePixel();\n            var horizontal = vscale.isHorizontal();\n            var ruler = me._ruler || me.getRuler();\n            var vpixels = me.calculateBarValuePixels(me.index, index);\n            var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n            model.horizontal = horizontal;\n            model.base = reset ? base : vpixels.base;\n            model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n            model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n            model.height = horizontal ? ipixels.size : undefined;\n            model.width = horizontal ? undefined : ipixels.size;\n        },\n        _getStacks: function (last) {\n            var me = this;\n            var chart = me.chart;\n            var scale = me._getIndexScale();\n            var stacked = scale.options.stacked;\n            var ilen = last === undefined ? chart.data.datasets.length : last + 1;\n            var stacks = [];\n            var i, meta;\n            for (i = 0; i < ilen; ++i) {\n                meta = chart.getDatasetMeta(i);\n                if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {\n                    stacks.push(meta.stack);\n                }\n            }\n            return stacks;\n        },\n        getStackCount: function () {\n            return this._getStacks().length;\n        },\n        getStackIndex: function (datasetIndex, name) {\n            var stacks = this._getStacks(datasetIndex);\n            var index = name !== undefined ? stacks.indexOf(name) : -1;\n            return index === -1 ? stacks.length - 1 : index;\n        },\n        getRuler: function () {\n            var me = this;\n            var scale = me._getIndexScale();\n            var stackCount = me.getStackCount();\n            var datasetIndex = me.index;\n            var isHorizontal = scale.isHorizontal();\n            var start = isHorizontal ? scale.left : scale.top;\n            var end = start + (isHorizontal ? scale.width : scale.height);\n            var pixels = [];\n            var i, ilen, min;\n            for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n                pixels.push(scale.getPixelForValue(null, i, datasetIndex));\n            }\n            min = helpers.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;\n            return {\n                min: min,\n                pixels: pixels,\n                start: start,\n                end: end,\n                stackCount: stackCount,\n                scale: scale\n            };\n        },\n        calculateBarValuePixels: function (datasetIndex, index) {\n            var me = this;\n            var chart = me.chart;\n            var meta = me.getMeta();\n            var scale = me._getValueScale();\n            var isHorizontal = scale.isHorizontal();\n            var datasets = chart.data.datasets;\n            var value = +scale.getRightValue(datasets[datasetIndex].data[index]);\n            var minBarLength = scale.options.minBarLength;\n            var stacked = scale.options.stacked;\n            var stack = meta.stack;\n            var start = 0;\n            var i, imeta, ivalue, base, head, size;\n            if (stacked || stacked === undefined && stack !== undefined) {\n                for (i = 0; i < datasetIndex; ++i) {\n                    imeta = chart.getDatasetMeta(i);\n                    if (imeta.bar && imeta.stack === stack && imeta.controller._getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {\n                        ivalue = +scale.getRightValue(datasets[i].data[index]);\n                        if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {\n                            start += ivalue;\n                        }\n                    }\n                }\n            }\n            base = scale.getPixelForValue(start);\n            head = scale.getPixelForValue(start + value);\n            size = head - base;\n            if (minBarLength !== undefined && Math.abs(size) < minBarLength) {\n                size = minBarLength;\n                if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {\n                    head = base - minBarLength;\n                } else {\n                    head = base + minBarLength;\n                }\n            }\n            return {\n                size: size,\n                base: base,\n                head: head,\n                center: head + size / 2\n            };\n        },\n        calculateBarIndexPixels: function (datasetIndex, index, ruler) {\n            var me = this;\n            var options = ruler.scale.options;\n            var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);\n            var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n            var center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            var size = Math.min(helpers.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);\n            return {\n                base: center - size / 2,\n                head: center + size / 2,\n                center: center,\n                size: size\n            };\n        },\n        draw: function () {\n            var me = this;\n            var chart = me.chart;\n            var scale = me._getValueScale();\n            var rects = me.getMeta().data;\n            var dataset = me.getDataset();\n            var ilen = rects.length;\n            var i = 0;\n            helpers.canvas.clipArea(chart.ctx, chart.chartArea);\n            for (; i < ilen; ++i) {\n                if (!isNaN(scale.getRightValue(dataset.data[i]))) {\n                    rects[i].draw();\n                }\n            }\n            helpers.canvas.unclipArea(chart.ctx);\n        },\n        _resolveElementOptions: function (rectangle, index) {\n            var me = this;\n            var chart = me.chart;\n            var datasets = chart.data.datasets;\n            var dataset = datasets[me.index];\n            var custom = rectangle.custom || {};\n            var options = chart.options.elements.rectangle;\n            var values = {};\n            var i, ilen, key;\n            var context = {\n                chart: chart,\n                dataIndex: index,\n                dataset: dataset,\n                datasetIndex: me.index\n            };\n            var keys = [\n                'backgroundColor',\n                'borderColor',\n                'borderSkipped',\n                'borderWidth'\n            ];\n            for (i = 0, ilen = keys.length; i < ilen; ++i) {\n                key = keys[i];\n                values[key] = resolve([\n                    custom[key],\n                    dataset[key],\n                    options[key]\n                ], context, index);\n            }\n            return values;\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/controllers/controller.bubble',[\n    '../core/core.datasetController',\n    '../core/core.defaults',\n    '../elements/index',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var DatasetController = __module__0;\n    var defaults = __module__1;\n    var elements = __module__2;\n    var helpers = __module__3;\n    var valueOrDefault = helpers.valueOrDefault;\n    var resolve = helpers.options.resolve;\n    defaults._set('bubble', {\n        hover: { mode: 'single' },\n        scales: {\n            xAxes: [{\n                    type: 'linear',\n                    position: 'bottom',\n                    id: 'x-axis-0'\n                }],\n            yAxes: [{\n                    type: 'linear',\n                    position: 'left',\n                    id: 'y-axis-0'\n                }]\n        },\n        tooltips: {\n            callbacks: {\n                title: function () {\n                    return '';\n                },\n                label: function (item, data) {\n                    var datasetLabel = data.datasets[item.datasetIndex].label || '';\n                    var dataPoint = data.datasets[item.datasetIndex].data[item.index];\n                    return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';\n                }\n            }\n        }\n    });\n    module.exports = DatasetController.extend({\n        dataElementType: elements.Point,\n        update: function (reset) {\n            var me = this;\n            var meta = me.getMeta();\n            var points = meta.data;\n            helpers.each(points, function (point, index) {\n                me.updateElement(point, index, reset);\n            });\n        },\n        updateElement: function (point, index, reset) {\n            var me = this;\n            var meta = me.getMeta();\n            var custom = point.custom || {};\n            var xScale = me.getScaleForId(meta.xAxisID);\n            var yScale = me.getScaleForId(meta.yAxisID);\n            var options = me._resolveElementOptions(point, index);\n            var data = me.getDataset().data[index];\n            var dsIndex = me.index;\n            var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\n            var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\n            point._xScale = xScale;\n            point._yScale = yScale;\n            point._options = options;\n            point._datasetIndex = dsIndex;\n            point._index = index;\n            point._model = {\n                backgroundColor: options.backgroundColor,\n                borderColor: options.borderColor,\n                borderWidth: options.borderWidth,\n                hitRadius: options.hitRadius,\n                pointStyle: options.pointStyle,\n                rotation: options.rotation,\n                radius: reset ? 0 : options.radius,\n                skip: custom.skip || isNaN(x) || isNaN(y),\n                x: x,\n                y: y\n            };\n            point.pivot();\n        },\n        setHoverStyle: function (point) {\n            var model = point._model;\n            var options = point._options;\n            var getHoverColor = helpers.getHoverColor;\n            point.$previousStyle = {\n                backgroundColor: model.backgroundColor,\n                borderColor: model.borderColor,\n                borderWidth: model.borderWidth,\n                radius: model.radius\n            };\n            model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n            model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));\n            model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n            model.radius = options.radius + options.hoverRadius;\n        },\n        _resolveElementOptions: function (point, index) {\n            var me = this;\n            var chart = me.chart;\n            var datasets = chart.data.datasets;\n            var dataset = datasets[me.index];\n            var custom = point.custom || {};\n            var options = chart.options.elements.point;\n            var data = dataset.data[index];\n            var values = {};\n            var i, ilen, key;\n            var context = {\n                chart: chart,\n                dataIndex: index,\n                dataset: dataset,\n                datasetIndex: me.index\n            };\n            var keys = [\n                'backgroundColor',\n                'borderColor',\n                'borderWidth',\n                'hoverBackgroundColor',\n                'hoverBorderColor',\n                'hoverBorderWidth',\n                'hoverRadius',\n                'hitRadius',\n                'pointStyle',\n                'rotation'\n            ];\n            for (i = 0, ilen = keys.length; i < ilen; ++i) {\n                key = keys[i];\n                values[key] = resolve([\n                    custom[key],\n                    dataset[key],\n                    options[key]\n                ], context, index);\n            }\n            values.radius = resolve([\n                custom.radius,\n                data ? data.r : undefined,\n                dataset.radius,\n                options.radius\n            ], context, index);\n            return values;\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/controllers/controller.doughnut',[\n    '../core/core.datasetController',\n    '../core/core.defaults',\n    '../elements/index',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var DatasetController = __module__0;\n    var defaults = __module__1;\n    var elements = __module__2;\n    var helpers = __module__3;\n    var resolve = helpers.options.resolve;\n    var valueOrDefault = helpers.valueOrDefault;\n    defaults._set('doughnut', {\n        animation: {\n            animateRotate: true,\n            animateScale: false\n        },\n        hover: { mode: 'single' },\n        legendCallback: function (chart) {\n            var text = [];\n            text.push('<ul class=\"' + chart.id + '-legend\">');\n            var data = chart.data;\n            var datasets = data.datasets;\n            var labels = data.labels;\n            if (datasets.length) {\n                for (var i = 0; i < datasets[0].data.length; ++i) {\n                    text.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n                    if (labels[i]) {\n                        text.push(labels[i]);\n                    }\n                    text.push('</li>');\n                }\n            }\n            text.push('</ul>');\n            return text.join('');\n        },\n        legend: {\n            labels: {\n                generateLabels: function (chart) {\n                    var data = chart.data;\n                    if (data.labels.length && data.datasets.length) {\n                        return data.labels.map(function (label, i) {\n                            var meta = chart.getDatasetMeta(0);\n                            var ds = data.datasets[0];\n                            var arc = meta.data[i];\n                            var custom = arc && arc.custom || {};\n                            var arcOpts = chart.options.elements.arc;\n                            var fill = resolve([\n                                custom.backgroundColor,\n                                ds.backgroundColor,\n                                arcOpts.backgroundColor\n                            ], undefined, i);\n                            var stroke = resolve([\n                                custom.borderColor,\n                                ds.borderColor,\n                                arcOpts.borderColor\n                            ], undefined, i);\n                            var bw = resolve([\n                                custom.borderWidth,\n                                ds.borderWidth,\n                                arcOpts.borderWidth\n                            ], undefined, i);\n                            return {\n                                text: label,\n                                fillStyle: fill,\n                                strokeStyle: stroke,\n                                lineWidth: bw,\n                                hidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n                                index: i\n                            };\n                        });\n                    }\n                    return [];\n                }\n            },\n            onClick: function (e, legendItem) {\n                var index = legendItem.index;\n                var chart = this.chart;\n                var i, ilen, meta;\n                for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n                    meta = chart.getDatasetMeta(i);\n                    if (meta.data[index]) {\n                        meta.data[index].hidden = !meta.data[index].hidden;\n                    }\n                }\n                chart.update();\n            }\n        },\n        cutoutPercentage: 50,\n        rotation: Math.PI * -0.5,\n        circumference: Math.PI * 2,\n        tooltips: {\n            callbacks: {\n                title: function () {\n                    return '';\n                },\n                label: function (tooltipItem, data) {\n                    var dataLabel = data.labels[tooltipItem.index];\n                    var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n                    if (helpers.isArray(dataLabel)) {\n                        dataLabel = dataLabel.slice();\n                        dataLabel[0] += value;\n                    } else {\n                        dataLabel += value;\n                    }\n                    return dataLabel;\n                }\n            }\n        }\n    });\n    module.exports = DatasetController.extend({\n        dataElementType: elements.Arc,\n        linkScales: helpers.noop,\n        getRingIndex: function (datasetIndex) {\n            var ringIndex = 0;\n            for (var j = 0; j < datasetIndex; ++j) {\n                if (this.chart.isDatasetVisible(j)) {\n                    ++ringIndex;\n                }\n            }\n            return ringIndex;\n        },\n        update: function (reset) {\n            var me = this;\n            var chart = me.chart;\n            var chartArea = chart.chartArea;\n            var opts = chart.options;\n            var availableWidth = chartArea.right - chartArea.left;\n            var availableHeight = chartArea.bottom - chartArea.top;\n            var minSize = Math.min(availableWidth, availableHeight);\n            var offset = {\n                x: 0,\n                y: 0\n            };\n            var meta = me.getMeta();\n            var arcs = meta.data;\n            var cutoutPercentage = opts.cutoutPercentage;\n            var circumference = opts.circumference;\n            var chartWeight = me._getRingWeight(me.index);\n            var i, ilen;\n            if (circumference < Math.PI * 2) {\n                var startAngle = opts.rotation % (Math.PI * 2);\n                startAngle += Math.PI * 2 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n                var endAngle = startAngle + circumference;\n                var start = {\n                    x: Math.cos(startAngle),\n                    y: Math.sin(startAngle)\n                };\n                var end = {\n                    x: Math.cos(endAngle),\n                    y: Math.sin(endAngle)\n                };\n                var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2 && Math.PI * 2 <= endAngle;\n                var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;\n                var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;\n                var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;\n                var cutout = cutoutPercentage / 100;\n                var min = {\n                    x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),\n                    y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))\n                };\n                var max = {\n                    x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),\n                    y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))\n                };\n                var size = {\n                    width: (max.x - min.x) * 0.5,\n                    height: (max.y - min.y) * 0.5\n                };\n                minSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n                offset = {\n                    x: (max.x + min.x) * -0.5,\n                    y: (max.y + min.y) * -0.5\n                };\n            }\n            for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n                arcs[i]._options = me._resolveElementOptions(arcs[i], i);\n            }\n            chart.borderWidth = me.getMaxBorderWidth();\n            chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n            chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);\n            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);\n            chart.offsetX = offset.x * chart.outerRadius;\n            chart.offsetY = offset.y * chart.outerRadius;\n            meta.total = me.calculateTotal();\n            me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);\n            me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);\n            for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n                me.updateElement(arcs[i], i, reset);\n            }\n        },\n        updateElement: function (arc, index, reset) {\n            var me = this;\n            var chart = me.chart;\n            var chartArea = chart.chartArea;\n            var opts = chart.options;\n            var animationOpts = opts.animation;\n            var centerX = (chartArea.left + chartArea.right) / 2;\n            var centerY = (chartArea.top + chartArea.bottom) / 2;\n            var startAngle = opts.rotation;\n            var endAngle = opts.rotation;\n            var dataset = me.getDataset();\n            var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2 * Math.PI));\n            var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;\n            var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;\n            var options = arc._options || {};\n            helpers.extend(arc, {\n                _datasetIndex: me.index,\n                _index: index,\n                _model: {\n                    backgroundColor: options.backgroundColor,\n                    borderColor: options.borderColor,\n                    borderWidth: options.borderWidth,\n                    borderAlign: options.borderAlign,\n                    x: centerX + chart.offsetX,\n                    y: centerY + chart.offsetY,\n                    startAngle: startAngle,\n                    endAngle: endAngle,\n                    circumference: circumference,\n                    outerRadius: outerRadius,\n                    innerRadius: innerRadius,\n                    label: helpers.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n                }\n            });\n            var model = arc._model;\n            if (!reset || !animationOpts.animateRotate) {\n                if (index === 0) {\n                    model.startAngle = opts.rotation;\n                } else {\n                    model.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n                }\n                model.endAngle = model.startAngle + model.circumference;\n            }\n            arc.pivot();\n        },\n        calculateTotal: function () {\n            var dataset = this.getDataset();\n            var meta = this.getMeta();\n            var total = 0;\n            var value;\n            helpers.each(meta.data, function (element, index) {\n                value = dataset.data[index];\n                if (!isNaN(value) && !element.hidden) {\n                    total += Math.abs(value);\n                }\n            });\n            return total;\n        },\n        calculateCircumference: function (value) {\n            var total = this.getMeta().total;\n            if (total > 0 && !isNaN(value)) {\n                return Math.PI * 2 * (Math.abs(value) / total);\n            }\n            return 0;\n        },\n        getMaxBorderWidth: function (arcs) {\n            var me = this;\n            var max = 0;\n            var chart = me.chart;\n            var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;\n            if (!arcs) {\n                for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n                    if (chart.isDatasetVisible(i)) {\n                        meta = chart.getDatasetMeta(i);\n                        arcs = meta.data;\n                        if (i !== me.index) {\n                            controller = meta.controller;\n                        }\n                        break;\n                    }\n                }\n            }\n            if (!arcs) {\n                return 0;\n            }\n            for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n                arc = arcs[i];\n                options = controller ? controller._resolveElementOptions(arc, i) : arc._options;\n                if (options.borderAlign !== 'inner') {\n                    borderWidth = options.borderWidth;\n                    hoverWidth = options.hoverBorderWidth;\n                    max = borderWidth > max ? borderWidth : max;\n                    max = hoverWidth > max ? hoverWidth : max;\n                }\n            }\n            return max;\n        },\n        setHoverStyle: function (arc) {\n            var model = arc._model;\n            var options = arc._options;\n            var getHoverColor = helpers.getHoverColor;\n            arc.$previousStyle = {\n                backgroundColor: model.backgroundColor,\n                borderColor: model.borderColor,\n                borderWidth: model.borderWidth\n            };\n            model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n            model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));\n            model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n        },\n        _resolveElementOptions: function (arc, index) {\n            var me = this;\n            var chart = me.chart;\n            var dataset = me.getDataset();\n            var custom = arc.custom || {};\n            var options = chart.options.elements.arc;\n            var values = {};\n            var i, ilen, key;\n            var context = {\n                chart: chart,\n                dataIndex: index,\n                dataset: dataset,\n                datasetIndex: me.index\n            };\n            var keys = [\n                'backgroundColor',\n                'borderColor',\n                'borderWidth',\n                'borderAlign',\n                'hoverBackgroundColor',\n                'hoverBorderColor',\n                'hoverBorderWidth'\n            ];\n            for (i = 0, ilen = keys.length; i < ilen; ++i) {\n                key = keys[i];\n                values[key] = resolve([\n                    custom[key],\n                    dataset[key],\n                    options[key]\n                ], context, index);\n            }\n            return values;\n        },\n        _getRingWeightOffset: function (datasetIndex) {\n            var ringWeightOffset = 0;\n            for (var i = 0; i < datasetIndex; ++i) {\n                if (this.chart.isDatasetVisible(i)) {\n                    ringWeightOffset += this._getRingWeight(i);\n                }\n            }\n            return ringWeightOffset;\n        },\n        _getRingWeight: function (dataSetIndex) {\n            return Math.max(valueOrDefault(this.chart.data.datasets[dataSetIndex].weight, 1), 0);\n        },\n        _getVisibleDatasetWeightTotal: function () {\n            return this._getRingWeightOffset(this.chart.data.datasets.length);\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/controllers/controller.horizontalBar',[\n    './controller.bar',\n    '../core/core.defaults'\n], function (__module__0, __module__1) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var BarController = __module__0;\n    var defaults = __module__1;\n    defaults._set('horizontalBar', {\n        hover: {\n            mode: 'index',\n            axis: 'y'\n        },\n        scales: {\n            xAxes: [{\n                    type: 'linear',\n                    position: 'bottom'\n                }],\n            yAxes: [{\n                    type: 'category',\n                    position: 'left',\n                    categoryPercentage: 0.8,\n                    barPercentage: 0.9,\n                    offset: true,\n                    gridLines: { offsetGridLines: true }\n                }]\n        },\n        elements: { rectangle: { borderSkipped: 'left' } },\n        tooltips: {\n            mode: 'index',\n            axis: 'y'\n        }\n    });\n    module.exports = BarController.extend({\n        _getValueScaleId: function () {\n            return this.getMeta().xAxisID;\n        },\n        _getIndexScaleId: function () {\n            return this.getMeta().yAxisID;\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/controllers/controller.line',[\n    '../core/core.datasetController',\n    '../core/core.defaults',\n    '../elements/index',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var DatasetController = __module__0;\n    var defaults = __module__1;\n    var elements = __module__2;\n    var helpers = __module__3;\n    var valueOrDefault = helpers.valueOrDefault;\n    var resolve = helpers.options.resolve;\n    var isPointInArea = helpers.canvas._isPointInArea;\n    defaults._set('line', {\n        showLines: true,\n        spanGaps: false,\n        hover: { mode: 'label' },\n        scales: {\n            xAxes: [{\n                    type: 'category',\n                    id: 'x-axis-0'\n                }],\n            yAxes: [{\n                    type: 'linear',\n                    id: 'y-axis-0'\n                }]\n        }\n    });\n    function lineEnabled(dataset, options) {\n        return valueOrDefault(dataset.showLine, options.showLines);\n    }\n    module.exports = DatasetController.extend({\n        datasetElementType: elements.Line,\n        dataElementType: elements.Point,\n        update: function (reset) {\n            var me = this;\n            var meta = me.getMeta();\n            var line = meta.dataset;\n            var points = meta.data || [];\n            var scale = me.getScaleForId(meta.yAxisID);\n            var dataset = me.getDataset();\n            var showLine = lineEnabled(dataset, me.chart.options);\n            var i, ilen;\n            if (showLine) {\n                if (dataset.tension !== undefined && dataset.lineTension === undefined) {\n                    dataset.lineTension = dataset.tension;\n                }\n                line._scale = scale;\n                line._datasetIndex = me.index;\n                line._children = points;\n                line._model = me._resolveLineOptions(line);\n                line.pivot();\n            }\n            for (i = 0, ilen = points.length; i < ilen; ++i) {\n                me.updateElement(points[i], i, reset);\n            }\n            if (showLine && line._model.tension !== 0) {\n                me.updateBezierControlPoints();\n            }\n            for (i = 0, ilen = points.length; i < ilen; ++i) {\n                points[i].pivot();\n            }\n        },\n        updateElement: function (point, index, reset) {\n            var me = this;\n            var meta = me.getMeta();\n            var custom = point.custom || {};\n            var dataset = me.getDataset();\n            var datasetIndex = me.index;\n            var value = dataset.data[index];\n            var yScale = me.getScaleForId(meta.yAxisID);\n            var xScale = me.getScaleForId(meta.xAxisID);\n            var lineModel = meta.dataset._model;\n            var x, y;\n            var options = me._resolvePointOptions(point, index);\n            x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n            y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n            point._xScale = xScale;\n            point._yScale = yScale;\n            point._options = options;\n            point._datasetIndex = datasetIndex;\n            point._index = index;\n            point._model = {\n                x: x,\n                y: y,\n                skip: custom.skip || isNaN(x) || isNaN(y),\n                radius: options.radius,\n                pointStyle: options.pointStyle,\n                rotation: options.rotation,\n                backgroundColor: options.backgroundColor,\n                borderColor: options.borderColor,\n                borderWidth: options.borderWidth,\n                tension: valueOrDefault(custom.tension, lineModel ? lineModel.tension : 0),\n                steppedLine: lineModel ? lineModel.steppedLine : false,\n                hitRadius: options.hitRadius\n            };\n        },\n        _resolvePointOptions: function (element, index) {\n            var me = this;\n            var chart = me.chart;\n            var dataset = chart.data.datasets[me.index];\n            var custom = element.custom || {};\n            var options = chart.options.elements.point;\n            var values = {};\n            var i, ilen, key;\n            var context = {\n                chart: chart,\n                dataIndex: index,\n                dataset: dataset,\n                datasetIndex: me.index\n            };\n            var ELEMENT_OPTIONS = {\n                backgroundColor: 'pointBackgroundColor',\n                borderColor: 'pointBorderColor',\n                borderWidth: 'pointBorderWidth',\n                hitRadius: 'pointHitRadius',\n                hoverBackgroundColor: 'pointHoverBackgroundColor',\n                hoverBorderColor: 'pointHoverBorderColor',\n                hoverBorderWidth: 'pointHoverBorderWidth',\n                hoverRadius: 'pointHoverRadius',\n                pointStyle: 'pointStyle',\n                radius: 'pointRadius',\n                rotation: 'pointRotation'\n            };\n            var keys = Object.keys(ELEMENT_OPTIONS);\n            for (i = 0, ilen = keys.length; i < ilen; ++i) {\n                key = keys[i];\n                values[key] = resolve([\n                    custom[key],\n                    dataset[ELEMENT_OPTIONS[key]],\n                    dataset[key],\n                    options[key]\n                ], context, index);\n            }\n            return values;\n        },\n        _resolveLineOptions: function (element) {\n            var me = this;\n            var chart = me.chart;\n            var dataset = chart.data.datasets[me.index];\n            var custom = element.custom || {};\n            var options = chart.options;\n            var elementOptions = options.elements.line;\n            var values = {};\n            var i, ilen, key;\n            var keys = [\n                'backgroundColor',\n                'borderWidth',\n                'borderColor',\n                'borderCapStyle',\n                'borderDash',\n                'borderDashOffset',\n                'borderJoinStyle',\n                'fill',\n                'cubicInterpolationMode'\n            ];\n            for (i = 0, ilen = keys.length; i < ilen; ++i) {\n                key = keys[i];\n                values[key] = resolve([\n                    custom[key],\n                    dataset[key],\n                    elementOptions[key]\n                ]);\n            }\n            values.spanGaps = valueOrDefault(dataset.spanGaps, options.spanGaps);\n            values.tension = valueOrDefault(dataset.lineTension, elementOptions.tension);\n            values.steppedLine = resolve([\n                custom.steppedLine,\n                dataset.steppedLine,\n                elementOptions.stepped\n            ]);\n            return values;\n        },\n        calculatePointY: function (value, index, datasetIndex) {\n            var me = this;\n            var chart = me.chart;\n            var meta = me.getMeta();\n            var yScale = me.getScaleForId(meta.yAxisID);\n            var sumPos = 0;\n            var sumNeg = 0;\n            var i, ds, dsMeta;\n            if (yScale.options.stacked) {\n                for (i = 0; i < datasetIndex; i++) {\n                    ds = chart.data.datasets[i];\n                    dsMeta = chart.getDatasetMeta(i);\n                    if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n                        var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n                        if (stackedRightValue < 0) {\n                            sumNeg += stackedRightValue || 0;\n                        } else {\n                            sumPos += stackedRightValue || 0;\n                        }\n                    }\n                }\n                var rightValue = Number(yScale.getRightValue(value));\n                if (rightValue < 0) {\n                    return yScale.getPixelForValue(sumNeg + rightValue);\n                }\n                return yScale.getPixelForValue(sumPos + rightValue);\n            }\n            return yScale.getPixelForValue(value);\n        },\n        updateBezierControlPoints: function () {\n            var me = this;\n            var chart = me.chart;\n            var meta = me.getMeta();\n            var lineModel = meta.dataset._model;\n            var area = chart.chartArea;\n            var points = meta.data || [];\n            var i, ilen, model, controlPoints;\n            if (lineModel.spanGaps) {\n                points = points.filter(function (pt) {\n                    return !pt._model.skip;\n                });\n            }\n            function capControlPoint(pt, min, max) {\n                return Math.max(Math.min(pt, max), min);\n            }\n            if (lineModel.cubicInterpolationMode === 'monotone') {\n                helpers.splineCurveMonotone(points);\n            } else {\n                for (i = 0, ilen = points.length; i < ilen; ++i) {\n                    model = points[i]._model;\n                    controlPoints = helpers.splineCurve(helpers.previousItem(points, i)._model, model, helpers.nextItem(points, i)._model, lineModel.tension);\n                    model.controlPointPreviousX = controlPoints.previous.x;\n                    model.controlPointPreviousY = controlPoints.previous.y;\n                    model.controlPointNextX = controlPoints.next.x;\n                    model.controlPointNextY = controlPoints.next.y;\n                }\n            }\n            if (chart.options.elements.line.capBezierPoints) {\n                for (i = 0, ilen = points.length; i < ilen; ++i) {\n                    model = points[i]._model;\n                    if (isPointInArea(model, area)) {\n                        if (i > 0 && isPointInArea(points[i - 1]._model, area)) {\n                            model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n                            model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n                        }\n                        if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {\n                            model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n                            model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n                        }\n                    }\n                }\n            }\n        },\n        draw: function () {\n            var me = this;\n            var chart = me.chart;\n            var meta = me.getMeta();\n            var points = meta.data || [];\n            var area = chart.chartArea;\n            var ilen = points.length;\n            var halfBorderWidth;\n            var i = 0;\n            if (lineEnabled(me.getDataset(), chart.options)) {\n                halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;\n                helpers.canvas.clipArea(chart.ctx, {\n                    left: area.left,\n                    right: area.right,\n                    top: area.top - halfBorderWidth,\n                    bottom: area.bottom + halfBorderWidth\n                });\n                meta.dataset.draw();\n                helpers.canvas.unclipArea(chart.ctx);\n            }\n            for (; i < ilen; ++i) {\n                points[i].draw(area);\n            }\n        },\n        setHoverStyle: function (point) {\n            var model = point._model;\n            var options = point._options;\n            var getHoverColor = helpers.getHoverColor;\n            point.$previousStyle = {\n                backgroundColor: model.backgroundColor,\n                borderColor: model.borderColor,\n                borderWidth: model.borderWidth,\n                radius: model.radius\n            };\n            model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n            model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));\n            model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n            model.radius = valueOrDefault(options.hoverRadius, options.radius);\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/controllers/controller.polarArea',[\n    '../core/core.datasetController',\n    '../core/core.defaults',\n    '../elements/index',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var DatasetController = __module__0;\n    var defaults = __module__1;\n    var elements = __module__2;\n    var helpers = __module__3;\n    var resolve = helpers.options.resolve;\n    defaults._set('polarArea', {\n        scale: {\n            type: 'radialLinear',\n            angleLines: { display: false },\n            gridLines: { circular: true },\n            pointLabels: { display: false },\n            ticks: { beginAtZero: true }\n        },\n        animation: {\n            animateRotate: true,\n            animateScale: true\n        },\n        startAngle: -0.5 * Math.PI,\n        legendCallback: function (chart) {\n            var text = [];\n            text.push('<ul class=\"' + chart.id + '-legend\">');\n            var data = chart.data;\n            var datasets = data.datasets;\n            var labels = data.labels;\n            if (datasets.length) {\n                for (var i = 0; i < datasets[0].data.length; ++i) {\n                    text.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n                    if (labels[i]) {\n                        text.push(labels[i]);\n                    }\n                    text.push('</li>');\n                }\n            }\n            text.push('</ul>');\n            return text.join('');\n        },\n        legend: {\n            labels: {\n                generateLabels: function (chart) {\n                    var data = chart.data;\n                    if (data.labels.length && data.datasets.length) {\n                        return data.labels.map(function (label, i) {\n                            var meta = chart.getDatasetMeta(0);\n                            var ds = data.datasets[0];\n                            var arc = meta.data[i];\n                            var custom = arc.custom || {};\n                            var arcOpts = chart.options.elements.arc;\n                            var fill = resolve([\n                                custom.backgroundColor,\n                                ds.backgroundColor,\n                                arcOpts.backgroundColor\n                            ], undefined, i);\n                            var stroke = resolve([\n                                custom.borderColor,\n                                ds.borderColor,\n                                arcOpts.borderColor\n                            ], undefined, i);\n                            var bw = resolve([\n                                custom.borderWidth,\n                                ds.borderWidth,\n                                arcOpts.borderWidth\n                            ], undefined, i);\n                            return {\n                                text: label,\n                                fillStyle: fill,\n                                strokeStyle: stroke,\n                                lineWidth: bw,\n                                hidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n                                index: i\n                            };\n                        });\n                    }\n                    return [];\n                }\n            },\n            onClick: function (e, legendItem) {\n                var index = legendItem.index;\n                var chart = this.chart;\n                var i, ilen, meta;\n                for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n                    meta = chart.getDatasetMeta(i);\n                    meta.data[index].hidden = !meta.data[index].hidden;\n                }\n                chart.update();\n            }\n        },\n        tooltips: {\n            callbacks: {\n                title: function () {\n                    return '';\n                },\n                label: function (item, data) {\n                    return data.labels[item.index] + ': ' + item.yLabel;\n                }\n            }\n        }\n    });\n    module.exports = DatasetController.extend({\n        dataElementType: elements.Arc,\n        linkScales: helpers.noop,\n        update: function (reset) {\n            var me = this;\n            var dataset = me.getDataset();\n            var meta = me.getMeta();\n            var start = me.chart.options.startAngle || 0;\n            var starts = me._starts = [];\n            var angles = me._angles = [];\n            var arcs = meta.data;\n            var i, ilen, angle;\n            me._updateRadius();\n            meta.count = me.countVisibleElements();\n            for (i = 0, ilen = dataset.data.length; i < ilen; i++) {\n                starts[i] = start;\n                angle = me._computeAngle(i);\n                angles[i] = angle;\n                start += angle;\n            }\n            for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n                arcs[i]._options = me._resolveElementOptions(arcs[i], i);\n                me.updateElement(arcs[i], i, reset);\n            }\n        },\n        _updateRadius: function () {\n            var me = this;\n            var chart = me.chart;\n            var chartArea = chart.chartArea;\n            var opts = chart.options;\n            var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n            chart.outerRadius = Math.max(minSize / 2, 0);\n            chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n            me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;\n            me.innerRadius = me.outerRadius - chart.radiusLength;\n        },\n        updateElement: function (arc, index, reset) {\n            var me = this;\n            var chart = me.chart;\n            var dataset = me.getDataset();\n            var opts = chart.options;\n            var animationOpts = opts.animation;\n            var scale = chart.scale;\n            var labels = chart.data.labels;\n            var centerX = scale.xCenter;\n            var centerY = scale.yCenter;\n            var datasetStartAngle = opts.startAngle;\n            var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n            var startAngle = me._starts[index];\n            var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);\n            var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n            var options = arc._options || {};\n            helpers.extend(arc, {\n                _datasetIndex: me.index,\n                _index: index,\n                _scale: scale,\n                _model: {\n                    backgroundColor: options.backgroundColor,\n                    borderColor: options.borderColor,\n                    borderWidth: options.borderWidth,\n                    borderAlign: options.borderAlign,\n                    x: centerX,\n                    y: centerY,\n                    innerRadius: 0,\n                    outerRadius: reset ? resetRadius : distance,\n                    startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n                    endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n                    label: helpers.valueAtIndexOrDefault(labels, index, labels[index])\n                }\n            });\n            arc.pivot();\n        },\n        countVisibleElements: function () {\n            var dataset = this.getDataset();\n            var meta = this.getMeta();\n            var count = 0;\n            helpers.each(meta.data, function (element, index) {\n                if (!isNaN(dataset.data[index]) && !element.hidden) {\n                    count++;\n                }\n            });\n            return count;\n        },\n        setHoverStyle: function (arc) {\n            var model = arc._model;\n            var options = arc._options;\n            var getHoverColor = helpers.getHoverColor;\n            var valueOrDefault = helpers.valueOrDefault;\n            arc.$previousStyle = {\n                backgroundColor: model.backgroundColor,\n                borderColor: model.borderColor,\n                borderWidth: model.borderWidth\n            };\n            model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n            model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));\n            model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n        },\n        _resolveElementOptions: function (arc, index) {\n            var me = this;\n            var chart = me.chart;\n            var dataset = me.getDataset();\n            var custom = arc.custom || {};\n            var options = chart.options.elements.arc;\n            var values = {};\n            var i, ilen, key;\n            var context = {\n                chart: chart,\n                dataIndex: index,\n                dataset: dataset,\n                datasetIndex: me.index\n            };\n            var keys = [\n                'backgroundColor',\n                'borderColor',\n                'borderWidth',\n                'borderAlign',\n                'hoverBackgroundColor',\n                'hoverBorderColor',\n                'hoverBorderWidth'\n            ];\n            for (i = 0, ilen = keys.length; i < ilen; ++i) {\n                key = keys[i];\n                values[key] = resolve([\n                    custom[key],\n                    dataset[key],\n                    options[key]\n                ], context, index);\n            }\n            return values;\n        },\n        _computeAngle: function (index) {\n            var me = this;\n            var count = this.getMeta().count;\n            var dataset = me.getDataset();\n            var meta = me.getMeta();\n            if (isNaN(dataset.data[index]) || meta.data[index].hidden) {\n                return 0;\n            }\n            var context = {\n                chart: me.chart,\n                dataIndex: index,\n                dataset: dataset,\n                datasetIndex: me.index\n            };\n            return resolve([\n                me.chart.options.elements.arc.angle,\n                2 * Math.PI / count\n            ], context, index);\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/controllers/controller.pie',[\n    './controller.doughnut',\n    '../core/core.defaults',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var DoughnutController = __module__0;\n    var defaults = __module__1;\n    var helpers = __module__2;\n    defaults._set('pie', helpers.clone(defaults.doughnut));\n    defaults._set('pie', { cutoutPercentage: 0 });\n    module.exports = DoughnutController;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/controllers/controller.radar',[\n    '../core/core.datasetController',\n    '../core/core.defaults',\n    '../elements/index',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var DatasetController = __module__0;\n    var defaults = __module__1;\n    var elements = __module__2;\n    var helpers = __module__3;\n    var valueOrDefault = helpers.valueOrDefault;\n    var resolve = helpers.options.resolve;\n    defaults._set('radar', {\n        scale: { type: 'radialLinear' },\n        elements: { line: { tension: 0 } }\n    });\n    module.exports = DatasetController.extend({\n        datasetElementType: elements.Line,\n        dataElementType: elements.Point,\n        linkScales: helpers.noop,\n        update: function (reset) {\n            var me = this;\n            var meta = me.getMeta();\n            var line = meta.dataset;\n            var points = meta.data || [];\n            var scale = me.chart.scale;\n            var dataset = me.getDataset();\n            var i, ilen;\n            if (dataset.tension !== undefined && dataset.lineTension === undefined) {\n                dataset.lineTension = dataset.tension;\n            }\n            line._scale = scale;\n            line._datasetIndex = me.index;\n            line._children = points;\n            line._loop = true;\n            line._model = me._resolveLineOptions(line);\n            line.pivot();\n            for (i = 0, ilen = points.length; i < ilen; ++i) {\n                me.updateElement(points[i], i, reset);\n            }\n            me.updateBezierControlPoints();\n            for (i = 0, ilen = points.length; i < ilen; ++i) {\n                points[i].pivot();\n            }\n        },\n        updateElement: function (point, index, reset) {\n            var me = this;\n            var custom = point.custom || {};\n            var dataset = me.getDataset();\n            var scale = me.chart.scale;\n            var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n            var options = me._resolvePointOptions(point, index);\n            var lineModel = me.getMeta().dataset._model;\n            var x = reset ? scale.xCenter : pointPosition.x;\n            var y = reset ? scale.yCenter : pointPosition.y;\n            point._scale = scale;\n            point._options = options;\n            point._datasetIndex = me.index;\n            point._index = index;\n            point._model = {\n                x: x,\n                y: y,\n                skip: custom.skip || isNaN(x) || isNaN(y),\n                radius: options.radius,\n                pointStyle: options.pointStyle,\n                rotation: options.rotation,\n                backgroundColor: options.backgroundColor,\n                borderColor: options.borderColor,\n                borderWidth: options.borderWidth,\n                tension: valueOrDefault(custom.tension, lineModel ? lineModel.tension : 0),\n                hitRadius: options.hitRadius\n            };\n        },\n        _resolvePointOptions: function (element, index) {\n            var me = this;\n            var chart = me.chart;\n            var dataset = chart.data.datasets[me.index];\n            var custom = element.custom || {};\n            var options = chart.options.elements.point;\n            var values = {};\n            var i, ilen, key;\n            var context = {\n                chart: chart,\n                dataIndex: index,\n                dataset: dataset,\n                datasetIndex: me.index\n            };\n            var ELEMENT_OPTIONS = {\n                backgroundColor: 'pointBackgroundColor',\n                borderColor: 'pointBorderColor',\n                borderWidth: 'pointBorderWidth',\n                hitRadius: 'pointHitRadius',\n                hoverBackgroundColor: 'pointHoverBackgroundColor',\n                hoverBorderColor: 'pointHoverBorderColor',\n                hoverBorderWidth: 'pointHoverBorderWidth',\n                hoverRadius: 'pointHoverRadius',\n                pointStyle: 'pointStyle',\n                radius: 'pointRadius',\n                rotation: 'pointRotation'\n            };\n            var keys = Object.keys(ELEMENT_OPTIONS);\n            for (i = 0, ilen = keys.length; i < ilen; ++i) {\n                key = keys[i];\n                values[key] = resolve([\n                    custom[key],\n                    dataset[ELEMENT_OPTIONS[key]],\n                    dataset[key],\n                    options[key]\n                ], context, index);\n            }\n            return values;\n        },\n        _resolveLineOptions: function (element) {\n            var me = this;\n            var chart = me.chart;\n            var dataset = chart.data.datasets[me.index];\n            var custom = element.custom || {};\n            var options = chart.options.elements.line;\n            var values = {};\n            var i, ilen, key;\n            var keys = [\n                'backgroundColor',\n                'borderWidth',\n                'borderColor',\n                'borderCapStyle',\n                'borderDash',\n                'borderDashOffset',\n                'borderJoinStyle',\n                'fill'\n            ];\n            for (i = 0, ilen = keys.length; i < ilen; ++i) {\n                key = keys[i];\n                values[key] = resolve([\n                    custom[key],\n                    dataset[key],\n                    options[key]\n                ]);\n            }\n            values.tension = valueOrDefault(dataset.lineTension, options.tension);\n            return values;\n        },\n        updateBezierControlPoints: function () {\n            var me = this;\n            var meta = me.getMeta();\n            var area = me.chart.chartArea;\n            var points = meta.data || [];\n            var i, ilen, model, controlPoints;\n            function capControlPoint(pt, min, max) {\n                return Math.max(Math.min(pt, max), min);\n            }\n            for (i = 0, ilen = points.length; i < ilen; ++i) {\n                model = points[i]._model;\n                controlPoints = helpers.splineCurve(helpers.previousItem(points, i, true)._model, model, helpers.nextItem(points, i, true)._model, model.tension);\n                model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);\n                model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\n                model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);\n                model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);\n            }\n        },\n        setHoverStyle: function (point) {\n            var model = point._model;\n            var options = point._options;\n            var getHoverColor = helpers.getHoverColor;\n            point.$previousStyle = {\n                backgroundColor: model.backgroundColor,\n                borderColor: model.borderColor,\n                borderWidth: model.borderWidth,\n                radius: model.radius\n            };\n            model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n            model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));\n            model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n            model.radius = valueOrDefault(options.hoverRadius, options.radius);\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/controllers/controller.scatter',[\n    './controller.line',\n    '../core/core.defaults'\n], function (__module__0, __module__1) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var LineController = __module__0;\n    var defaults = __module__1;\n    defaults._set('scatter', {\n        hover: { mode: 'single' },\n        scales: {\n            xAxes: [{\n                    id: 'x-axis-1',\n                    type: 'linear',\n                    position: 'bottom'\n                }],\n            yAxes: [{\n                    id: 'y-axis-1',\n                    type: 'linear',\n                    position: 'left'\n                }]\n        },\n        showLines: false,\n        tooltips: {\n            callbacks: {\n                title: function () {\n                    return '';\n                },\n                label: function (item) {\n                    return '(' + item.xLabel + ', ' + item.yLabel + ')';\n                }\n            }\n        }\n    });\n    module.exports = LineController;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/controllers/index',[\n    './controller.bar',\n    './controller.bubble',\n    './controller.doughnut',\n    './controller.horizontalBar',\n    './controller.line',\n    './controller.polarArea',\n    './controller.pie',\n    './controller.radar',\n    './controller.scatter'\n], function (__module__0, __module__1, __module__2, __module__3, __module__4, __module__5, __module__6, __module__7, __module__8) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var bar = __module__0;\n    var bubble = __module__1;\n    var doughnut = __module__2;\n    var horizontalBar = __module__3;\n    var line = __module__4;\n    var polarArea = __module__5;\n    var pie = __module__6;\n    var radar = __module__7;\n    var scatter = __module__8;\n    module.exports = {\n        bar: bar,\n        bubble: bubble,\n        doughnut: doughnut,\n        horizontalBar: horizontalBar,\n        line: line,\n        polarArea: polarArea,\n        pie: pie,\n        radar: radar,\n        scatter: scatter\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.interaction',['../helpers/index'], function (__module__0) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    function getRelativePosition(e, chart) {\n        if (e.native) {\n            return {\n                x: e.x,\n                y: e.y\n            };\n        }\n        return helpers.getRelativePosition(e, chart);\n    }\n    function parseVisibleItems(chart, handler) {\n        var datasets = chart.data.datasets;\n        var meta, i, j, ilen, jlen;\n        for (i = 0, ilen = datasets.length; i < ilen; ++i) {\n            if (!chart.isDatasetVisible(i)) {\n                continue;\n            }\n            meta = chart.getDatasetMeta(i);\n            for (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n                var element = meta.data[j];\n                if (!element._view.skip) {\n                    handler(element);\n                }\n            }\n        }\n    }\n    function getIntersectItems(chart, position) {\n        var elements = [];\n        parseVisibleItems(chart, function (element) {\n            if (element.inRange(position.x, position.y)) {\n                elements.push(element);\n            }\n        });\n        return elements;\n    }\n    function getNearestItems(chart, position, intersect, distanceMetric) {\n        var minDistance = Number.POSITIVE_INFINITY;\n        var nearestItems = [];\n        parseVisibleItems(chart, function (element) {\n            if (intersect && !element.inRange(position.x, position.y)) {\n                return;\n            }\n            var center = element.getCenterPoint();\n            var distance = distanceMetric(position, center);\n            if (distance < minDistance) {\n                nearestItems = [element];\n                minDistance = distance;\n            } else if (distance === minDistance) {\n                nearestItems.push(element);\n            }\n        });\n        return nearestItems;\n    }\n    function getDistanceMetricForAxis(axis) {\n        var useX = axis.indexOf('x') !== -1;\n        var useY = axis.indexOf('y') !== -1;\n        return function (pt1, pt2) {\n            var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n            var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n        };\n    }\n    function indexMode(chart, e, options) {\n        var position = getRelativePosition(e, chart);\n        options.axis = options.axis || 'x';\n        var distanceMetric = getDistanceMetricForAxis(options.axis);\n        var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n        var elements = [];\n        if (!items.length) {\n            return [];\n        }\n        chart.data.datasets.forEach(function (dataset, datasetIndex) {\n            if (chart.isDatasetVisible(datasetIndex)) {\n                var meta = chart.getDatasetMeta(datasetIndex);\n                var element = meta.data[items[0]._index];\n                if (element && !element._view.skip) {\n                    elements.push(element);\n                }\n            }\n        });\n        return elements;\n    }\n    module.exports = {\n        modes: {\n            single: function (chart, e) {\n                var position = getRelativePosition(e, chart);\n                var elements = [];\n                parseVisibleItems(chart, function (element) {\n                    if (element.inRange(position.x, position.y)) {\n                        elements.push(element);\n                        return elements;\n                    }\n                });\n                return elements.slice(0, 1);\n            },\n            label: indexMode,\n            index: indexMode,\n            dataset: function (chart, e, options) {\n                var position = getRelativePosition(e, chart);\n                options.axis = options.axis || 'xy';\n                var distanceMetric = getDistanceMetricForAxis(options.axis);\n                var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n                if (items.length > 0) {\n                    items = chart.getDatasetMeta(items[0]._datasetIndex).data;\n                }\n                return items;\n            },\n            'x-axis': function (chart, e) {\n                return indexMode(chart, e, { intersect: false });\n            },\n            point: function (chart, e) {\n                var position = getRelativePosition(e, chart);\n                return getIntersectItems(chart, position);\n            },\n            nearest: function (chart, e, options) {\n                var position = getRelativePosition(e, chart);\n                options.axis = options.axis || 'xy';\n                var distanceMetric = getDistanceMetricForAxis(options.axis);\n                return getNearestItems(chart, position, options.intersect, distanceMetric);\n            },\n            x: function (chart, e, options) {\n                var position = getRelativePosition(e, chart);\n                var items = [];\n                var intersectsItem = false;\n                parseVisibleItems(chart, function (element) {\n                    if (element.inXRange(position.x)) {\n                        items.push(element);\n                    }\n                    if (element.inRange(position.x, position.y)) {\n                        intersectsItem = true;\n                    }\n                });\n                if (options.intersect && !intersectsItem) {\n                    items = [];\n                }\n                return items;\n            },\n            y: function (chart, e, options) {\n                var position = getRelativePosition(e, chart);\n                var items = [];\n                var intersectsItem = false;\n                parseVisibleItems(chart, function (element) {\n                    if (element.inYRange(position.y)) {\n                        items.push(element);\n                    }\n                    if (element.inRange(position.x, position.y)) {\n                        intersectsItem = true;\n                    }\n                });\n                if (options.intersect && !intersectsItem) {\n                    items = [];\n                }\n                return items;\n            }\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.layouts',[\n    './core.defaults',\n    '../helpers/index'\n], function (__module__0, __module__1) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var helpers = __module__1;\n    function filterByPosition(array, position) {\n        return helpers.where(array, function (v) {\n            return v.position === position;\n        });\n    }\n    function sortByWeight(array, reverse) {\n        array.forEach(function (v, i) {\n            v._tmpIndex_ = i;\n            return v;\n        });\n        array.sort(function (a, b) {\n            var v0 = reverse ? b : a;\n            var v1 = reverse ? a : b;\n            return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;\n        });\n        array.forEach(function (v) {\n            delete v._tmpIndex_;\n        });\n    }\n    function findMaxPadding(boxes) {\n        var top = 0;\n        var left = 0;\n        var bottom = 0;\n        var right = 0;\n        helpers.each(boxes, function (box) {\n            if (box.getPadding) {\n                var boxPadding = box.getPadding();\n                top = Math.max(top, boxPadding.top);\n                left = Math.max(left, boxPadding.left);\n                bottom = Math.max(bottom, boxPadding.bottom);\n                right = Math.max(right, boxPadding.right);\n            }\n        });\n        return {\n            top: top,\n            left: left,\n            bottom: bottom,\n            right: right\n        };\n    }\n    function addSizeByPosition(boxes, size) {\n        helpers.each(boxes, function (box) {\n            size[box.position] += box.isHorizontal() ? box.height : box.width;\n        });\n    }\n    defaults._set('global', {\n        layout: {\n            padding: {\n                top: 0,\n                right: 0,\n                bottom: 0,\n                left: 0\n            }\n        }\n    });\n    module.exports = {\n        defaults: {},\n        addBox: function (chart, item) {\n            if (!chart.boxes) {\n                chart.boxes = [];\n            }\n            item.fullWidth = item.fullWidth || false;\n            item.position = item.position || 'top';\n            item.weight = item.weight || 0;\n            chart.boxes.push(item);\n        },\n        removeBox: function (chart, layoutItem) {\n            var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n            if (index !== -1) {\n                chart.boxes.splice(index, 1);\n            }\n        },\n        configure: function (chart, item, options) {\n            var props = [\n                'fullWidth',\n                'position',\n                'weight'\n            ];\n            var ilen = props.length;\n            var i = 0;\n            var prop;\n            for (; i < ilen; ++i) {\n                prop = props[i];\n                if (options.hasOwnProperty(prop)) {\n                    item[prop] = options[prop];\n                }\n            }\n        },\n        update: function (chart, width, height) {\n            if (!chart) {\n                return;\n            }\n            var layoutOptions = chart.options.layout || {};\n            var padding = helpers.options.toPadding(layoutOptions.padding);\n            var leftPadding = padding.left;\n            var rightPadding = padding.right;\n            var topPadding = padding.top;\n            var bottomPadding = padding.bottom;\n            var leftBoxes = filterByPosition(chart.boxes, 'left');\n            var rightBoxes = filterByPosition(chart.boxes, 'right');\n            var topBoxes = filterByPosition(chart.boxes, 'top');\n            var bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n            var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n            sortByWeight(leftBoxes, true);\n            sortByWeight(rightBoxes, false);\n            sortByWeight(topBoxes, true);\n            sortByWeight(bottomBoxes, false);\n            var verticalBoxes = leftBoxes.concat(rightBoxes);\n            var horizontalBoxes = topBoxes.concat(bottomBoxes);\n            var outerBoxes = verticalBoxes.concat(horizontalBoxes);\n            var chartWidth = width - leftPadding - rightPadding;\n            var chartHeight = height - topPadding - bottomPadding;\n            var chartAreaWidth = chartWidth / 2;\n            var verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length;\n            var maxChartAreaWidth = chartWidth;\n            var maxChartAreaHeight = chartHeight;\n            var outerBoxSizes = {\n                top: topPadding,\n                left: leftPadding,\n                bottom: bottomPadding,\n                right: rightPadding\n            };\n            var minBoxSizes = [];\n            var maxPadding;\n            function getMinimumBoxSize(box) {\n                var minSize;\n                var isHorizontal = box.isHorizontal();\n                if (isHorizontal) {\n                    minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);\n                    maxChartAreaHeight -= minSize.height;\n                } else {\n                    minSize = box.update(verticalBoxWidth, maxChartAreaHeight);\n                    maxChartAreaWidth -= minSize.width;\n                }\n                minBoxSizes.push({\n                    horizontal: isHorizontal,\n                    width: minSize.width,\n                    box: box\n                });\n            }\n            helpers.each(outerBoxes, getMinimumBoxSize);\n            maxPadding = findMaxPadding(outerBoxes);\n            function fitBox(box) {\n                var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {\n                    return minBox.box === box;\n                });\n                if (minBoxSize) {\n                    if (minBoxSize.horizontal) {\n                        var scaleMargin = {\n                            left: Math.max(outerBoxSizes.left, maxPadding.left),\n                            right: Math.max(outerBoxSizes.right, maxPadding.right),\n                            top: 0,\n                            bottom: 0\n                        };\n                        box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n                    } else {\n                        box.update(minBoxSize.width, maxChartAreaHeight);\n                    }\n                }\n            }\n            helpers.each(verticalBoxes, fitBox);\n            addSizeByPosition(verticalBoxes, outerBoxSizes);\n            helpers.each(horizontalBoxes, fitBox);\n            addSizeByPosition(horizontalBoxes, outerBoxSizes);\n            function finalFitVerticalBox(box) {\n                var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {\n                    return minSize.box === box;\n                });\n                var scaleMargin = {\n                    left: 0,\n                    right: 0,\n                    top: outerBoxSizes.top,\n                    bottom: outerBoxSizes.bottom\n                };\n                if (minBoxSize) {\n                    box.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);\n                }\n            }\n            helpers.each(verticalBoxes, finalFitVerticalBox);\n            outerBoxSizes = {\n                top: topPadding,\n                left: leftPadding,\n                bottom: bottomPadding,\n                right: rightPadding\n            };\n            addSizeByPosition(outerBoxes, outerBoxSizes);\n            var leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);\n            outerBoxSizes.left += leftPaddingAddition;\n            outerBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);\n            var topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);\n            outerBoxSizes.top += topPaddingAddition;\n            outerBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0);\n            var newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;\n            var newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;\n            if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n                helpers.each(verticalBoxes, function (box) {\n                    box.height = newMaxChartAreaHeight;\n                });\n                helpers.each(horizontalBoxes, function (box) {\n                    if (!box.fullWidth) {\n                        box.width = newMaxChartAreaWidth;\n                    }\n                });\n                maxChartAreaHeight = newMaxChartAreaHeight;\n                maxChartAreaWidth = newMaxChartAreaWidth;\n            }\n            var left = leftPadding + leftPaddingAddition;\n            var top = topPadding + topPaddingAddition;\n            function placeBox(box) {\n                if (box.isHorizontal()) {\n                    box.left = box.fullWidth ? leftPadding : outerBoxSizes.left;\n                    box.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;\n                    box.top = top;\n                    box.bottom = top + box.height;\n                    top = box.bottom;\n                } else {\n                    box.left = left;\n                    box.right = left + box.width;\n                    box.top = outerBoxSizes.top;\n                    box.bottom = outerBoxSizes.top + maxChartAreaHeight;\n                    left = box.right;\n                }\n            }\n            helpers.each(leftBoxes.concat(topBoxes), placeBox);\n            left += maxChartAreaWidth;\n            top += maxChartAreaHeight;\n            helpers.each(rightBoxes, placeBox);\n            helpers.each(bottomBoxes, placeBox);\n            chart.chartArea = {\n                left: outerBoxSizes.left,\n                top: outerBoxSizes.top,\n                right: outerBoxSizes.left + maxChartAreaWidth,\n                bottom: outerBoxSizes.top + maxChartAreaHeight\n            };\n            helpers.each(chartAreaBoxes, function (box) {\n                box.left = chart.chartArea.left;\n                box.top = chart.chartArea.top;\n                box.right = chart.chartArea.right;\n                box.bottom = chart.chartArea.bottom;\n                box.update(maxChartAreaWidth, maxChartAreaHeight);\n            });\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/platforms/platform.basic',[], function () {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    module.exports = {\n        acquireContext: function (item) {\n            if (item && item.canvas) {\n                item = item.canvas;\n            }\n            return item && item.getContext('2d') || null;\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/platforms/platform.dom.css',[], function() { return \"/*\\n * DOM element rendering detection\\n * https://davidwalsh.name/detect-node-insertion\\n */\\n@keyframes chartjs-render-animation {\\n\\tfrom { opacity: 0.99; }\\n\\tto { opacity: 1; }\\n}\\n\\n.chartjs-render-monitor {\\n\\tanimation: chartjs-render-animation 0.001s;\\n}\\n\\n/*\\n * DOM element resizing detection\\n * https://github.com/marcj/css-element-queries\\n */\\n.chartjs-size-monitor,\\n.chartjs-size-monitor-expand,\\n.chartjs-size-monitor-shrink {\\n\\tposition: absolute;\\n\\tdirection: ltr;\\n\\tleft: 0;\\n\\ttop: 0;\\n\\tright: 0;\\n\\tbottom: 0;\\n\\toverflow: hidden;\\n\\tpointer-events: none;\\n\\tvisibility: hidden;\\n\\tz-index: -1;\\n}\\n\\n.chartjs-size-monitor-expand > div {\\n\\tposition: absolute;\\n\\twidth: 1000000px;\\n\\theight: 1000000px;\\n\\tleft: 0;\\n\\ttop: 0;\\n}\\n\\n.chartjs-size-monitor-shrink > div {\\n\\tposition: absolute;\\n\\twidth: 200%;\\n\\theight: 200%;\\n\\tleft: 0;\\n\\ttop: 0;\\n}\\n\"; });\ndefine('skylark-chartjs/platforms/platform.dom',[\n    '../helpers/index',\n    './platform.dom.css'\n], function (__module__0, __module__1) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    var stylesheet = __module__1;\n    var EXPANDO_KEY = '$chartjs';\n    var CSS_PREFIX = 'chartjs-';\n    var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';\n    var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\n    var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\n    var ANIMATION_START_EVENTS = [\n        'animationstart',\n        'webkitAnimationStart'\n    ];\n    var EVENT_TYPES = {\n        touchstart: 'mousedown',\n        touchmove: 'mousemove',\n        touchend: 'mouseup',\n        pointerenter: 'mouseenter',\n        pointerdown: 'mousedown',\n        pointermove: 'mousemove',\n        pointerup: 'mouseup',\n        pointerleave: 'mouseout',\n        pointerout: 'mouseout'\n    };\n    function readUsedSize(element, property) {\n        var value = helpers.getStyle(element, property);\n        var matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n        return matches ? Number(matches[1]) : undefined;\n    }\n    function initCanvas(canvas, config) {\n        var style = canvas.style;\n        var renderHeight = canvas.getAttribute('height');\n        var renderWidth = canvas.getAttribute('width');\n        canvas[EXPANDO_KEY] = {\n            initial: {\n                height: renderHeight,\n                width: renderWidth,\n                style: {\n                    display: style.display,\n                    height: style.height,\n                    width: style.width\n                }\n            }\n        };\n        style.display = style.display || 'block';\n        if (renderWidth === null || renderWidth === '') {\n            var displayWidth = readUsedSize(canvas, 'width');\n            if (displayWidth !== undefined) {\n                canvas.width = displayWidth;\n            }\n        }\n        if (renderHeight === null || renderHeight === '') {\n            if (canvas.style.height === '') {\n                canvas.height = canvas.width / (config.options.aspectRatio || 2);\n            } else {\n                var displayHeight = readUsedSize(canvas, 'height');\n                if (displayWidth !== undefined) {\n                    canvas.height = displayHeight;\n                }\n            }\n        }\n        return canvas;\n    }\n    var supportsEventListenerOptions = function () {\n        var supports = false;\n        try {\n            var options = Object.defineProperty({}, 'passive', {\n                get: function () {\n                    supports = true;\n                }\n            });\n            window.addEventListener('e', null, options);\n        } catch (e) {\n        }\n        return supports;\n    }();\n    var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;\n    function addListener(node, type, listener) {\n        node.addEventListener(type, listener, eventListenerOptions);\n    }\n    function removeListener(node, type, listener) {\n        node.removeEventListener(type, listener, eventListenerOptions);\n    }\n    function createEvent(type, chart, x, y, nativeEvent) {\n        return {\n            type: type,\n            chart: chart,\n            native: nativeEvent || null,\n            x: x !== undefined ? x : null,\n            y: y !== undefined ? y : null\n        };\n    }\n    function fromNativeEvent(event, chart) {\n        var type = EVENT_TYPES[event.type] || event.type;\n        var pos = helpers.getRelativePosition(event, chart);\n        return createEvent(type, chart, pos.x, pos.y, event);\n    }\n    function throttled(fn, thisArg) {\n        var ticking = false;\n        var args = [];\n        return function () {\n            args = Array.prototype.slice.call(arguments);\n            thisArg = thisArg || this;\n            if (!ticking) {\n                ticking = true;\n                helpers.requestAnimFrame.call(window, function () {\n                    ticking = false;\n                    fn.apply(thisArg, args);\n                });\n            }\n        };\n    }\n    function createDiv(cls) {\n        var el = document.createElement('div');\n        el.className = cls || '';\n        return el;\n    }\n    function createResizer(handler) {\n        var maxSize = 1000000;\n        var resizer = createDiv(CSS_SIZE_MONITOR);\n        var expand = createDiv(CSS_SIZE_MONITOR + '-expand');\n        var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');\n        expand.appendChild(createDiv());\n        shrink.appendChild(createDiv());\n        resizer.appendChild(expand);\n        resizer.appendChild(shrink);\n        resizer._reset = function () {\n            expand.scrollLeft = maxSize;\n            expand.scrollTop = maxSize;\n            shrink.scrollLeft = maxSize;\n            shrink.scrollTop = maxSize;\n        };\n        var onScroll = function () {\n            resizer._reset();\n            handler();\n        };\n        addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\n        addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\n        return resizer;\n    }\n    function watchForRender(node, handler) {\n        var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n        var proxy = expando.renderProxy = function (e) {\n            if (e.animationName === CSS_RENDER_ANIMATION) {\n                handler();\n            }\n        };\n        helpers.each(ANIMATION_START_EVENTS, function (type) {\n            addListener(node, type, proxy);\n        });\n        expando.reflow = !!node.offsetParent;\n        node.classList.add(CSS_RENDER_MONITOR);\n    }\n    function unwatchForRender(node) {\n        var expando = node[EXPANDO_KEY] || {};\n        var proxy = expando.renderProxy;\n        if (proxy) {\n            helpers.each(ANIMATION_START_EVENTS, function (type) {\n                removeListener(node, type, proxy);\n            });\n            delete expando.renderProxy;\n        }\n        node.classList.remove(CSS_RENDER_MONITOR);\n    }\n    function addResizeListener(node, listener, chart) {\n        var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n        var resizer = expando.resizer = createResizer(throttled(function () {\n            if (expando.resizer) {\n                var container = chart.options.maintainAspectRatio && node.parentNode;\n                var w = container ? container.clientWidth : 0;\n                listener(createEvent('resize', chart));\n                if (container && container.clientWidth < w && chart.canvas) {\n                    listener(createEvent('resize', chart));\n                }\n            }\n        }));\n        watchForRender(node, function () {\n            if (expando.resizer) {\n                var container = node.parentNode;\n                if (container && container !== resizer.parentNode) {\n                    container.insertBefore(resizer, container.firstChild);\n                }\n                resizer._reset();\n            }\n        });\n    }\n    function removeResizeListener(node) {\n        var expando = node[EXPANDO_KEY] || {};\n        var resizer = expando.resizer;\n        delete expando.resizer;\n        unwatchForRender(node);\n        if (resizer && resizer.parentNode) {\n            resizer.parentNode.removeChild(resizer);\n        }\n    }\n    function injectCSS(platform, css) {\n        var style = platform._style || document.createElement('style');\n        if (!platform._style) {\n            platform._style = style;\n            css = '/* Chart.js */\\n' + css;\n            style.setAttribute('type', 'text/css');\n            document.getElementsByTagName('head')[0].appendChild(style);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n    module.exports = {\n        disableCSSInjection: false,\n        _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',\n        _ensureLoaded: function () {\n            if (this._loaded) {\n                return;\n            }\n            this._loaded = true;\n            if (!this.disableCSSInjection) {\n                injectCSS(this, stylesheet);\n            }\n        },\n        acquireContext: function (item, config) {\n            if (typeof item === 'string') {\n                item = document.getElementById(item);\n            } else if (item.length) {\n                item = item[0];\n            }\n            if (item && item.canvas) {\n                item = item.canvas;\n            }\n            var context = item && item.getContext && item.getContext('2d');\n            this._ensureLoaded();\n            if (context && context.canvas === item) {\n                initCanvas(item, config);\n                return context;\n            }\n            return null;\n        },\n        releaseContext: function (context) {\n            var canvas = context.canvas;\n            if (!canvas[EXPANDO_KEY]) {\n                return;\n            }\n            var initial = canvas[EXPANDO_KEY].initial;\n            [\n                'height',\n                'width'\n            ].forEach(function (prop) {\n                var value = initial[prop];\n                if (helpers.isNullOrUndef(value)) {\n                    canvas.removeAttribute(prop);\n                } else {\n                    canvas.setAttribute(prop, value);\n                }\n            });\n            helpers.each(initial.style || {}, function (value, key) {\n                canvas.style[key] = value;\n            });\n            canvas.width = canvas.width;\n            delete canvas[EXPANDO_KEY];\n        },\n        addEventListener: function (chart, type, listener) {\n            var canvas = chart.canvas;\n            if (type === 'resize') {\n                addResizeListener(canvas, listener, chart);\n                return;\n            }\n            var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});\n            var proxies = expando.proxies || (expando.proxies = {});\n            var proxy = proxies[chart.id + '_' + type] = function (event) {\n                listener(fromNativeEvent(event, chart));\n            };\n            addListener(canvas, type, proxy);\n        },\n        removeEventListener: function (chart, type, listener) {\n            var canvas = chart.canvas;\n            if (type === 'resize') {\n                removeResizeListener(canvas);\n                return;\n            }\n            var expando = listener[EXPANDO_KEY] || {};\n            var proxies = expando.proxies || {};\n            var proxy = proxies[chart.id + '_' + type];\n            if (!proxy) {\n                return;\n            }\n            removeListener(canvas, type, proxy);\n        }\n    };\n    helpers.addEvent = addListener;\n    helpers.removeEvent = removeListener;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/platforms/platform',[\n    '../helpers/index',\n    './platform.basic',\n    './platform.dom'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    var basic = __module__1;\n    var dom = __module__2;\n    var implementation = dom._enabled ? dom : basic;\n    module.exports = helpers.extend({\n        initialize: function () {\n        },\n        acquireContext: function () {\n        },\n        releaseContext: function () {\n        },\n        addEventListener: function () {\n        },\n        removeEventListener: function () {\n        }\n    }, implementation);\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.plugins',[\n    './core.defaults',\n    '../helpers/index'\n], function (__module__0, __module__1) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var helpers = __module__1;\n    defaults._set('global', { plugins: {} });\n    module.exports = {\n        _plugins: [],\n        _cacheId: 0,\n        register: function (plugins) {\n            var p = this._plugins;\n            [].concat(plugins).forEach(function (plugin) {\n                if (p.indexOf(plugin) === -1) {\n                    p.push(plugin);\n                }\n            });\n            this._cacheId++;\n        },\n        unregister: function (plugins) {\n            var p = this._plugins;\n            [].concat(plugins).forEach(function (plugin) {\n                var idx = p.indexOf(plugin);\n                if (idx !== -1) {\n                    p.splice(idx, 1);\n                }\n            });\n            this._cacheId++;\n        },\n        clear: function () {\n            this._plugins = [];\n            this._cacheId++;\n        },\n        count: function () {\n            return this._plugins.length;\n        },\n        getAll: function () {\n            return this._plugins;\n        },\n        notify: function (chart, hook, args) {\n            var descriptors = this.descriptors(chart);\n            var ilen = descriptors.length;\n            var i, descriptor, plugin, params, method;\n            for (i = 0; i < ilen; ++i) {\n                descriptor = descriptors[i];\n                plugin = descriptor.plugin;\n                method = plugin[hook];\n                if (typeof method === 'function') {\n                    params = [chart].concat(args || []);\n                    params.push(descriptor.options);\n                    if (method.apply(plugin, params) === false) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n        descriptors: function (chart) {\n            var cache = chart.$plugins || (chart.$plugins = {});\n            if (cache.id === this._cacheId) {\n                return cache.descriptors;\n            }\n            var plugins = [];\n            var descriptors = [];\n            var config = chart && chart.config || {};\n            var options = config.options && config.options.plugins || {};\n            this._plugins.concat(config.plugins || []).forEach(function (plugin) {\n                var idx = plugins.indexOf(plugin);\n                if (idx !== -1) {\n                    return;\n                }\n                var id = plugin.id;\n                var opts = options[id];\n                if (opts === false) {\n                    return;\n                }\n                if (opts === true) {\n                    opts = helpers.clone(defaults.global.plugins[id]);\n                }\n                plugins.push(plugin);\n                descriptors.push({\n                    plugin: plugin,\n                    options: opts || {}\n                });\n            });\n            cache.descriptors = descriptors;\n            cache.id = this._cacheId;\n            return descriptors;\n        },\n        _invalidate: function (chart) {\n            delete chart.$plugins;\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.scaleService',[\n    './core.defaults',\n    '../helpers/index',\n    './core.layouts'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var helpers = __module__1;\n    var layouts = __module__2;\n    module.exports = {\n        constructors: {},\n        defaults: {},\n        registerScaleType: function (type, scaleConstructor, scaleDefaults) {\n            this.constructors[type] = scaleConstructor;\n            this.defaults[type] = helpers.clone(scaleDefaults);\n        },\n        getScaleConstructor: function (type) {\n            return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n        },\n        getScaleDefaults: function (type) {\n            return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [\n                defaults.scale,\n                this.defaults[type]\n            ]) : {};\n        },\n        updateScaleDefaults: function (type, additions) {\n            var me = this;\n            if (me.defaults.hasOwnProperty(type)) {\n                me.defaults[type] = helpers.extend(me.defaults[type], additions);\n            }\n        },\n        addScalesToLayout: function (chart) {\n            helpers.each(chart.scales, function (scale) {\n                scale.fullWidth = scale.options.fullWidth;\n                scale.position = scale.options.position;\n                scale.weight = scale.options.weight;\n                layouts.addBox(chart, scale);\n            });\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.tooltip',[\n    './core.defaults',\n    './core.element',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var Element = __module__1;\n    var helpers = __module__2;\n    var valueOrDefault = helpers.valueOrDefault;\n    defaults._set('global', {\n        tooltips: {\n            enabled: true,\n            custom: null,\n            mode: 'nearest',\n            position: 'average',\n            intersect: true,\n            backgroundColor: 'rgba(0,0,0,0.8)',\n            titleFontStyle: 'bold',\n            titleSpacing: 2,\n            titleMarginBottom: 6,\n            titleFontColor: '#fff',\n            titleAlign: 'left',\n            bodySpacing: 2,\n            bodyFontColor: '#fff',\n            bodyAlign: 'left',\n            footerFontStyle: 'bold',\n            footerSpacing: 2,\n            footerMarginTop: 6,\n            footerFontColor: '#fff',\n            footerAlign: 'left',\n            yPadding: 6,\n            xPadding: 6,\n            caretPadding: 2,\n            caretSize: 5,\n            cornerRadius: 6,\n            multiKeyBackground: '#fff',\n            displayColors: true,\n            borderColor: 'rgba(0,0,0,0)',\n            borderWidth: 0,\n            callbacks: {\n                beforeTitle: helpers.noop,\n                title: function (tooltipItems, data) {\n                    var title = '';\n                    var labels = data.labels;\n                    var labelCount = labels ? labels.length : 0;\n                    if (tooltipItems.length > 0) {\n                        var item = tooltipItems[0];\n                        if (item.label) {\n                            title = item.label;\n                        } else if (item.xLabel) {\n                            title = item.xLabel;\n                        } else if (labelCount > 0 && item.index < labelCount) {\n                            title = labels[item.index];\n                        }\n                    }\n                    return title;\n                },\n                afterTitle: helpers.noop,\n                beforeBody: helpers.noop,\n                beforeLabel: helpers.noop,\n                label: function (tooltipItem, data) {\n                    var label = data.datasets[tooltipItem.datasetIndex].label || '';\n                    if (label) {\n                        label += ': ';\n                    }\n                    if (!helpers.isNullOrUndef(tooltipItem.value)) {\n                        label += tooltipItem.value;\n                    } else {\n                        label += tooltipItem.yLabel;\n                    }\n                    return label;\n                },\n                labelColor: function (tooltipItem, chart) {\n                    var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n                    var activeElement = meta.data[tooltipItem.index];\n                    var view = activeElement._view;\n                    return {\n                        borderColor: view.borderColor,\n                        backgroundColor: view.backgroundColor\n                    };\n                },\n                labelTextColor: function () {\n                    return this._options.bodyFontColor;\n                },\n                afterLabel: helpers.noop,\n                afterBody: helpers.noop,\n                beforeFooter: helpers.noop,\n                footer: helpers.noop,\n                afterFooter: helpers.noop\n            }\n        }\n    });\n    var positioners = {\n        average: function (elements) {\n            if (!elements.length) {\n                return false;\n            }\n            var i, len;\n            var x = 0;\n            var y = 0;\n            var count = 0;\n            for (i = 0, len = elements.length; i < len; ++i) {\n                var el = elements[i];\n                if (el && el.hasValue()) {\n                    var pos = el.tooltipPosition();\n                    x += pos.x;\n                    y += pos.y;\n                    ++count;\n                }\n            }\n            return {\n                x: x / count,\n                y: y / count\n            };\n        },\n        nearest: function (elements, eventPosition) {\n            var x = eventPosition.x;\n            var y = eventPosition.y;\n            var minDistance = Number.POSITIVE_INFINITY;\n            var i, len, nearestElement;\n            for (i = 0, len = elements.length; i < len; ++i) {\n                var el = elements[i];\n                if (el && el.hasValue()) {\n                    var center = el.getCenterPoint();\n                    var d = helpers.distanceBetweenPoints(eventPosition, center);\n                    if (d < minDistance) {\n                        minDistance = d;\n                        nearestElement = el;\n                    }\n                }\n            }\n            if (nearestElement) {\n                var tp = nearestElement.tooltipPosition();\n                x = tp.x;\n                y = tp.y;\n            }\n            return {\n                x: x,\n                y: y\n            };\n        }\n    };\n    function pushOrConcat(base, toPush) {\n        if (toPush) {\n            if (helpers.isArray(toPush)) {\n                Array.prototype.push.apply(base, toPush);\n            } else {\n                base.push(toPush);\n            }\n        }\n        return base;\n    }\n    function splitNewlines(str) {\n        if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n            return str.split('\\n');\n        }\n        return str;\n    }\n    function createTooltipItem(element) {\n        var xScale = element._xScale;\n        var yScale = element._yScale || element._scale;\n        var index = element._index;\n        var datasetIndex = element._datasetIndex;\n        var controller = element._chart.getDatasetMeta(datasetIndex).controller;\n        var indexScale = controller._getIndexScale();\n        var valueScale = controller._getValueScale();\n        return {\n            xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n            yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n            label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',\n            value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',\n            index: index,\n            datasetIndex: datasetIndex,\n            x: element._model.x,\n            y: element._model.y\n        };\n    }\n    function getBaseModel(tooltipOpts) {\n        var globalDefaults = defaults.global;\n        return {\n            xPadding: tooltipOpts.xPadding,\n            yPadding: tooltipOpts.yPadding,\n            xAlign: tooltipOpts.xAlign,\n            yAlign: tooltipOpts.yAlign,\n            bodyFontColor: tooltipOpts.bodyFontColor,\n            _bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n            _bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n            _bodyAlign: tooltipOpts.bodyAlign,\n            bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n            bodySpacing: tooltipOpts.bodySpacing,\n            titleFontColor: tooltipOpts.titleFontColor,\n            _titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n            _titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n            titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n            _titleAlign: tooltipOpts.titleAlign,\n            titleSpacing: tooltipOpts.titleSpacing,\n            titleMarginBottom: tooltipOpts.titleMarginBottom,\n            footerFontColor: tooltipOpts.footerFontColor,\n            _footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n            _footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n            footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n            _footerAlign: tooltipOpts.footerAlign,\n            footerSpacing: tooltipOpts.footerSpacing,\n            footerMarginTop: tooltipOpts.footerMarginTop,\n            caretSize: tooltipOpts.caretSize,\n            cornerRadius: tooltipOpts.cornerRadius,\n            backgroundColor: tooltipOpts.backgroundColor,\n            opacity: 0,\n            legendColorBackground: tooltipOpts.multiKeyBackground,\n            displayColors: tooltipOpts.displayColors,\n            borderColor: tooltipOpts.borderColor,\n            borderWidth: tooltipOpts.borderWidth\n        };\n    }\n    function getTooltipSize(tooltip, model) {\n        var ctx = tooltip._chart.ctx;\n        var height = model.yPadding * 2;\n        var width = 0;\n        var body = model.body;\n        var combinedBodyLength = body.reduce(function (count, bodyItem) {\n            return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n        }, 0);\n        combinedBodyLength += model.beforeBody.length + model.afterBody.length;\n        var titleLineCount = model.title.length;\n        var footerLineCount = model.footer.length;\n        var titleFontSize = model.titleFontSize;\n        var bodyFontSize = model.bodyFontSize;\n        var footerFontSize = model.footerFontSize;\n        height += titleLineCount * titleFontSize;\n        height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;\n        height += titleLineCount ? model.titleMarginBottom : 0;\n        height += combinedBodyLength * bodyFontSize;\n        height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;\n        height += footerLineCount ? model.footerMarginTop : 0;\n        height += footerLineCount * footerFontSize;\n        height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;\n        var widthPadding = 0;\n        var maxLineWidth = function (line) {\n            width = Math.max(width, ctx.measureText(line).width + widthPadding);\n        };\n        ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n        helpers.each(model.title, maxLineWidth);\n        ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n        helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n        widthPadding = model.displayColors ? bodyFontSize + 2 : 0;\n        helpers.each(body, function (bodyItem) {\n            helpers.each(bodyItem.before, maxLineWidth);\n            helpers.each(bodyItem.lines, maxLineWidth);\n            helpers.each(bodyItem.after, maxLineWidth);\n        });\n        widthPadding = 0;\n        ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n        helpers.each(model.footer, maxLineWidth);\n        width += 2 * model.xPadding;\n        return {\n            width: width,\n            height: height\n        };\n    }\n    function determineAlignment(tooltip, size) {\n        var model = tooltip._model;\n        var chart = tooltip._chart;\n        var chartArea = tooltip._chart.chartArea;\n        var xAlign = 'center';\n        var yAlign = 'center';\n        if (model.y < size.height) {\n            yAlign = 'top';\n        } else if (model.y > chart.height - size.height) {\n            yAlign = 'bottom';\n        }\n        var lf, rf;\n        var olf, orf;\n        var yf;\n        var midX = (chartArea.left + chartArea.right) / 2;\n        var midY = (chartArea.top + chartArea.bottom) / 2;\n        if (yAlign === 'center') {\n            lf = function (x) {\n                return x <= midX;\n            };\n            rf = function (x) {\n                return x > midX;\n            };\n        } else {\n            lf = function (x) {\n                return x <= size.width / 2;\n            };\n            rf = function (x) {\n                return x >= chart.width - size.width / 2;\n            };\n        }\n        olf = function (x) {\n            return x + size.width + model.caretSize + model.caretPadding > chart.width;\n        };\n        orf = function (x) {\n            return x - size.width - model.caretSize - model.caretPadding < 0;\n        };\n        yf = function (y) {\n            return y <= midY ? 'top' : 'bottom';\n        };\n        if (lf(model.x)) {\n            xAlign = 'left';\n            if (olf(model.x)) {\n                xAlign = 'center';\n                yAlign = yf(model.y);\n            }\n        } else if (rf(model.x)) {\n            xAlign = 'right';\n            if (orf(model.x)) {\n                xAlign = 'center';\n                yAlign = yf(model.y);\n            }\n        }\n        var opts = tooltip._options;\n        return {\n            xAlign: opts.xAlign ? opts.xAlign : xAlign,\n            yAlign: opts.yAlign ? opts.yAlign : yAlign\n        };\n    }\n    function getBackgroundPoint(vm, size, alignment, chart) {\n        var x = vm.x;\n        var y = vm.y;\n        var caretSize = vm.caretSize;\n        var caretPadding = vm.caretPadding;\n        var cornerRadius = vm.cornerRadius;\n        var xAlign = alignment.xAlign;\n        var yAlign = alignment.yAlign;\n        var paddingAndSize = caretSize + caretPadding;\n        var radiusAndPadding = cornerRadius + caretPadding;\n        if (xAlign === 'right') {\n            x -= size.width;\n        } else if (xAlign === 'center') {\n            x -= size.width / 2;\n            if (x + size.width > chart.width) {\n                x = chart.width - size.width;\n            }\n            if (x < 0) {\n                x = 0;\n            }\n        }\n        if (yAlign === 'top') {\n            y += paddingAndSize;\n        } else if (yAlign === 'bottom') {\n            y -= size.height + paddingAndSize;\n        } else {\n            y -= size.height / 2;\n        }\n        if (yAlign === 'center') {\n            if (xAlign === 'left') {\n                x += paddingAndSize;\n            } else if (xAlign === 'right') {\n                x -= paddingAndSize;\n            }\n        } else if (xAlign === 'left') {\n            x -= radiusAndPadding;\n        } else if (xAlign === 'right') {\n            x += radiusAndPadding;\n        }\n        return {\n            x: x,\n            y: y\n        };\n    }\n    function getAlignedX(vm, align) {\n        return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;\n    }\n    function getBeforeAfterBodyLines(callback) {\n        return pushOrConcat([], splitNewlines(callback));\n    }\n    var exports = Element.extend({\n        initialize: function () {\n            this._model = getBaseModel(this._options);\n            this._lastActive = [];\n        },\n        getTitle: function () {\n            var me = this;\n            var opts = me._options;\n            var callbacks = opts.callbacks;\n            var beforeTitle = callbacks.beforeTitle.apply(me, arguments);\n            var title = callbacks.title.apply(me, arguments);\n            var afterTitle = callbacks.afterTitle.apply(me, arguments);\n            var lines = [];\n            lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n            lines = pushOrConcat(lines, splitNewlines(title));\n            lines = pushOrConcat(lines, splitNewlines(afterTitle));\n            return lines;\n        },\n        getBeforeBody: function () {\n            return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));\n        },\n        getBody: function (tooltipItems, data) {\n            var me = this;\n            var callbacks = me._options.callbacks;\n            var bodyItems = [];\n            helpers.each(tooltipItems, function (tooltipItem) {\n                var bodyItem = {\n                    before: [],\n                    lines: [],\n                    after: []\n                };\n                pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));\n                pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n                pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));\n                bodyItems.push(bodyItem);\n            });\n            return bodyItems;\n        },\n        getAfterBody: function () {\n            return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));\n        },\n        getFooter: function () {\n            var me = this;\n            var callbacks = me._options.callbacks;\n            var beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n            var footer = callbacks.footer.apply(me, arguments);\n            var afterFooter = callbacks.afterFooter.apply(me, arguments);\n            var lines = [];\n            lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n            lines = pushOrConcat(lines, splitNewlines(footer));\n            lines = pushOrConcat(lines, splitNewlines(afterFooter));\n            return lines;\n        },\n        update: function (changed) {\n            var me = this;\n            var opts = me._options;\n            var existingModel = me._model;\n            var model = me._model = getBaseModel(opts);\n            var active = me._active;\n            var data = me._data;\n            var alignment = {\n                xAlign: existingModel.xAlign,\n                yAlign: existingModel.yAlign\n            };\n            var backgroundPoint = {\n                x: existingModel.x,\n                y: existingModel.y\n            };\n            var tooltipSize = {\n                width: existingModel.width,\n                height: existingModel.height\n            };\n            var tooltipPosition = {\n                x: existingModel.caretX,\n                y: existingModel.caretY\n            };\n            var i, len;\n            if (active.length) {\n                model.opacity = 1;\n                var labelColors = [];\n                var labelTextColors = [];\n                tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);\n                var tooltipItems = [];\n                for (i = 0, len = active.length; i < len; ++i) {\n                    tooltipItems.push(createTooltipItem(active[i]));\n                }\n                if (opts.filter) {\n                    tooltipItems = tooltipItems.filter(function (a) {\n                        return opts.filter(a, data);\n                    });\n                }\n                if (opts.itemSort) {\n                    tooltipItems = tooltipItems.sort(function (a, b) {\n                        return opts.itemSort(a, b, data);\n                    });\n                }\n                helpers.each(tooltipItems, function (tooltipItem) {\n                    labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n                    labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\n                });\n                model.title = me.getTitle(tooltipItems, data);\n                model.beforeBody = me.getBeforeBody(tooltipItems, data);\n                model.body = me.getBody(tooltipItems, data);\n                model.afterBody = me.getAfterBody(tooltipItems, data);\n                model.footer = me.getFooter(tooltipItems, data);\n                model.x = tooltipPosition.x;\n                model.y = tooltipPosition.y;\n                model.caretPadding = opts.caretPadding;\n                model.labelColors = labelColors;\n                model.labelTextColors = labelTextColors;\n                model.dataPoints = tooltipItems;\n                tooltipSize = getTooltipSize(this, model);\n                alignment = determineAlignment(this, tooltipSize);\n                backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\n            } else {\n                model.opacity = 0;\n            }\n            model.xAlign = alignment.xAlign;\n            model.yAlign = alignment.yAlign;\n            model.x = backgroundPoint.x;\n            model.y = backgroundPoint.y;\n            model.width = tooltipSize.width;\n            model.height = tooltipSize.height;\n            model.caretX = tooltipPosition.x;\n            model.caretY = tooltipPosition.y;\n            me._model = model;\n            if (changed && opts.custom) {\n                opts.custom.call(me, model);\n            }\n            return me;\n        },\n        drawCaret: function (tooltipPoint, size) {\n            var ctx = this._chart.ctx;\n            var vm = this._view;\n            var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n            ctx.lineTo(caretPosition.x1, caretPosition.y1);\n            ctx.lineTo(caretPosition.x2, caretPosition.y2);\n            ctx.lineTo(caretPosition.x3, caretPosition.y3);\n        },\n        getCaretPosition: function (tooltipPoint, size, vm) {\n            var x1, x2, x3, y1, y2, y3;\n            var caretSize = vm.caretSize;\n            var cornerRadius = vm.cornerRadius;\n            var xAlign = vm.xAlign;\n            var yAlign = vm.yAlign;\n            var ptX = tooltipPoint.x;\n            var ptY = tooltipPoint.y;\n            var width = size.width;\n            var height = size.height;\n            if (yAlign === 'center') {\n                y2 = ptY + height / 2;\n                if (xAlign === 'left') {\n                    x1 = ptX;\n                    x2 = x1 - caretSize;\n                    x3 = x1;\n                    y1 = y2 + caretSize;\n                    y3 = y2 - caretSize;\n                } else {\n                    x1 = ptX + width;\n                    x2 = x1 + caretSize;\n                    x3 = x1;\n                    y1 = y2 - caretSize;\n                    y3 = y2 + caretSize;\n                }\n            } else {\n                if (xAlign === 'left') {\n                    x2 = ptX + cornerRadius + caretSize;\n                    x1 = x2 - caretSize;\n                    x3 = x2 + caretSize;\n                } else if (xAlign === 'right') {\n                    x2 = ptX + width - cornerRadius - caretSize;\n                    x1 = x2 - caretSize;\n                    x3 = x2 + caretSize;\n                } else {\n                    x2 = vm.caretX;\n                    x1 = x2 - caretSize;\n                    x3 = x2 + caretSize;\n                }\n                if (yAlign === 'top') {\n                    y1 = ptY;\n                    y2 = y1 - caretSize;\n                    y3 = y1;\n                } else {\n                    y1 = ptY + height;\n                    y2 = y1 + caretSize;\n                    y3 = y1;\n                    var tmp = x3;\n                    x3 = x1;\n                    x1 = tmp;\n                }\n            }\n            return {\n                x1: x1,\n                x2: x2,\n                x3: x3,\n                y1: y1,\n                y2: y2,\n                y3: y3\n            };\n        },\n        drawTitle: function (pt, vm, ctx) {\n            var title = vm.title;\n            if (title.length) {\n                pt.x = getAlignedX(vm, vm._titleAlign);\n                ctx.textAlign = vm._titleAlign;\n                ctx.textBaseline = 'top';\n                var titleFontSize = vm.titleFontSize;\n                var titleSpacing = vm.titleSpacing;\n                ctx.fillStyle = vm.titleFontColor;\n                ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n                var i, len;\n                for (i = 0, len = title.length; i < len; ++i) {\n                    ctx.fillText(title[i], pt.x, pt.y);\n                    pt.y += titleFontSize + titleSpacing;\n                    if (i + 1 === title.length) {\n                        pt.y += vm.titleMarginBottom - titleSpacing;\n                    }\n                }\n            }\n        },\n        drawBody: function (pt, vm, ctx) {\n            var bodyFontSize = vm.bodyFontSize;\n            var bodySpacing = vm.bodySpacing;\n            var bodyAlign = vm._bodyAlign;\n            var body = vm.body;\n            var drawColorBoxes = vm.displayColors;\n            var labelColors = vm.labelColors;\n            var xLinePadding = 0;\n            var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\n            var textColor;\n            ctx.textAlign = bodyAlign;\n            ctx.textBaseline = 'top';\n            ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n            pt.x = getAlignedX(vm, bodyAlign);\n            var fillLineOfText = function (line) {\n                ctx.fillText(line, pt.x + xLinePadding, pt.y);\n                pt.y += bodyFontSize + bodySpacing;\n            };\n            ctx.fillStyle = vm.bodyFontColor;\n            helpers.each(vm.beforeBody, fillLineOfText);\n            xLinePadding = drawColorBoxes && bodyAlign !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0;\n            helpers.each(body, function (bodyItem, i) {\n                textColor = vm.labelTextColors[i];\n                ctx.fillStyle = textColor;\n                helpers.each(bodyItem.before, fillLineOfText);\n                helpers.each(bodyItem.lines, function (line) {\n                    if (drawColorBoxes) {\n                        ctx.fillStyle = vm.legendColorBackground;\n                        ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n                        ctx.lineWidth = 1;\n                        ctx.strokeStyle = labelColors[i].borderColor;\n                        ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n                        ctx.fillStyle = labelColors[i].backgroundColor;\n                        ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n                        ctx.fillStyle = textColor;\n                    }\n                    fillLineOfText(line);\n                });\n                helpers.each(bodyItem.after, fillLineOfText);\n            });\n            xLinePadding = 0;\n            helpers.each(vm.afterBody, fillLineOfText);\n            pt.y -= bodySpacing;\n        },\n        drawFooter: function (pt, vm, ctx) {\n            var footer = vm.footer;\n            if (footer.length) {\n                pt.x = getAlignedX(vm, vm._footerAlign);\n                pt.y += vm.footerMarginTop;\n                ctx.textAlign = vm._footerAlign;\n                ctx.textBaseline = 'top';\n                ctx.fillStyle = vm.footerFontColor;\n                ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n                helpers.each(footer, function (line) {\n                    ctx.fillText(line, pt.x, pt.y);\n                    pt.y += vm.footerFontSize + vm.footerSpacing;\n                });\n            }\n        },\n        drawBackground: function (pt, vm, ctx, tooltipSize) {\n            ctx.fillStyle = vm.backgroundColor;\n            ctx.strokeStyle = vm.borderColor;\n            ctx.lineWidth = vm.borderWidth;\n            var xAlign = vm.xAlign;\n            var yAlign = vm.yAlign;\n            var x = pt.x;\n            var y = pt.y;\n            var width = tooltipSize.width;\n            var height = tooltipSize.height;\n            var radius = vm.cornerRadius;\n            ctx.beginPath();\n            ctx.moveTo(x + radius, y);\n            if (yAlign === 'top') {\n                this.drawCaret(pt, tooltipSize);\n            }\n            ctx.lineTo(x + width - radius, y);\n            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n            if (yAlign === 'center' && xAlign === 'right') {\n                this.drawCaret(pt, tooltipSize);\n            }\n            ctx.lineTo(x + width, y + height - radius);\n            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n            if (yAlign === 'bottom') {\n                this.drawCaret(pt, tooltipSize);\n            }\n            ctx.lineTo(x + radius, y + height);\n            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n            if (yAlign === 'center' && xAlign === 'left') {\n                this.drawCaret(pt, tooltipSize);\n            }\n            ctx.lineTo(x, y + radius);\n            ctx.quadraticCurveTo(x, y, x + radius, y);\n            ctx.closePath();\n            ctx.fill();\n            if (vm.borderWidth > 0) {\n                ctx.stroke();\n            }\n        },\n        draw: function () {\n            var ctx = this._chart.ctx;\n            var vm = this._view;\n            if (vm.opacity === 0) {\n                return;\n            }\n            var tooltipSize = {\n                width: vm.width,\n                height: vm.height\n            };\n            var pt = {\n                x: vm.x,\n                y: vm.y\n            };\n            var opacity = Math.abs(vm.opacity < 0.001) ? 0 : vm.opacity;\n            var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n            if (this._options.enabled && hasTooltipContent) {\n                ctx.save();\n                ctx.globalAlpha = opacity;\n                this.drawBackground(pt, vm, ctx, tooltipSize);\n                pt.y += vm.yPadding;\n                this.drawTitle(pt, vm, ctx);\n                this.drawBody(pt, vm, ctx);\n                this.drawFooter(pt, vm, ctx);\n                ctx.restore();\n            }\n        },\n        handleEvent: function (e) {\n            var me = this;\n            var options = me._options;\n            var changed = false;\n            me._lastActive = me._lastActive || [];\n            if (e.type === 'mouseout') {\n                me._active = [];\n            } else {\n                me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n            }\n            changed = !helpers.arrayEquals(me._active, me._lastActive);\n            if (changed) {\n                me._lastActive = me._active;\n                if (options.enabled || options.custom) {\n                    me._eventPosition = {\n                        x: e.x,\n                        y: e.y\n                    };\n                    me.update(true);\n                    me.pivot();\n                }\n            }\n            return changed;\n        }\n    });\n    exports.positioners = positioners;\n    module.exports = exports;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.controller',[\n    './core.animation',\n    './core.animations',\n    '../controllers/index',\n    './core.defaults',\n    '../helpers/index',\n    './core.interaction',\n    './core.layouts',\n    '../platforms/platform',\n    './core.plugins',\n    '../core/core.scaleService',\n    './core.tooltip'\n], function (__module__0, __module__1, __module__2, __module__3, __module__4, __module__5, __module__6, __module__7, __module__8, __module__9, __module__10) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var Animation = __module__0;\n    var animations = __module__1;\n    var controllers = __module__2;\n    var defaults = __module__3;\n    var helpers = __module__4;\n    var Interaction = __module__5;\n    var layouts = __module__6;\n    var platform = __module__7;\n    var plugins = __module__8;\n    var scaleService = __module__9;\n    var Tooltip = __module__10;\n    var valueOrDefault = helpers.valueOrDefault;\n    defaults._set('global', {\n        elements: {},\n        events: [\n            'mousemove',\n            'mouseout',\n            'click',\n            'touchstart',\n            'touchmove'\n        ],\n        hover: {\n            onHover: null,\n            mode: 'nearest',\n            intersect: true,\n            animationDuration: 400\n        },\n        onClick: null,\n        maintainAspectRatio: true,\n        responsive: true,\n        responsiveAnimationDuration: 0\n    });\n    function mergeScaleConfig() {\n        return helpers.merge({}, [].slice.call(arguments), {\n            merger: function (key, target, source, options) {\n                if (key === 'xAxes' || key === 'yAxes') {\n                    var slen = source[key].length;\n                    var i, type, scale;\n                    if (!target[key]) {\n                        target[key] = [];\n                    }\n                    for (i = 0; i < slen; ++i) {\n                        scale = source[key][i];\n                        type = valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');\n                        if (i >= target[key].length) {\n                            target[key].push({});\n                        }\n                        if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {\n                            helpers.merge(target[key][i], [\n                                scaleService.getScaleDefaults(type),\n                                scale\n                            ]);\n                        } else {\n                            helpers.merge(target[key][i], scale);\n                        }\n                    }\n                } else {\n                    helpers._merger(key, target, source, options);\n                }\n            }\n        });\n    }\n    function mergeConfig() {\n        return helpers.merge({}, [].slice.call(arguments), {\n            merger: function (key, target, source, options) {\n                var tval = target[key] || {};\n                var sval = source[key];\n                if (key === 'scales') {\n                    target[key] = mergeScaleConfig(tval, sval);\n                } else if (key === 'scale') {\n                    target[key] = helpers.merge(tval, [\n                        scaleService.getScaleDefaults(sval.type),\n                        sval\n                    ]);\n                } else {\n                    helpers._merger(key, target, source, options);\n                }\n            }\n        });\n    }\n    function initConfig(config) {\n        config = config || {};\n        var data = config.data = config.data || {};\n        data.datasets = data.datasets || [];\n        data.labels = data.labels || [];\n        config.options = mergeConfig(defaults.global, defaults[config.type], config.options || {});\n        return config;\n    }\n    function updateConfig(chart) {\n        var newOptions = chart.options;\n        helpers.each(chart.scales, function (scale) {\n            layouts.removeBox(chart, scale);\n        });\n        newOptions = mergeConfig(defaults.global, defaults[chart.config.type], newOptions);\n        chart.options = chart.config.options = newOptions;\n        chart.ensureScalesHaveIDs();\n        chart.buildOrUpdateScales();\n        chart.tooltip._options = newOptions.tooltips;\n        chart.tooltip.initialize();\n    }\n    function positionIsHorizontal(position) {\n        return position === 'top' || position === 'bottom';\n    }\n    var Chart = function (item, config) {\n        this.construct(item, config);\n        return this;\n    };\n    helpers.extend(Chart.prototype, {\n        construct: function (item, config) {\n            var me = this;\n            config = initConfig(config);\n            var context = platform.acquireContext(item, config);\n            var canvas = context && context.canvas;\n            var height = canvas && canvas.height;\n            var width = canvas && canvas.width;\n            me.id = helpers.uid();\n            me.ctx = context;\n            me.canvas = canvas;\n            me.config = config;\n            me.width = width;\n            me.height = height;\n            me.aspectRatio = height ? width / height : null;\n            me.options = config.options;\n            me._bufferedRender = false;\n            me.chart = me;\n            me.controller = me;\n            Chart.instances[me.id] = me;\n            Object.defineProperty(me, 'data', {\n                get: function () {\n                    return me.config.data;\n                },\n                set: function (value) {\n                    me.config.data = value;\n                }\n            });\n            if (!context || !canvas) {\n                console.error(\"Failed to create chart: can't acquire context from the given item\");\n                return;\n            }\n            me.initialize();\n            me.update();\n        },\n        initialize: function () {\n            var me = this;\n            plugins.notify(me, 'beforeInit');\n            helpers.retinaScale(me, me.options.devicePixelRatio);\n            me.bindEvents();\n            if (me.options.responsive) {\n                me.resize(true);\n            }\n            me.ensureScalesHaveIDs();\n            me.buildOrUpdateScales();\n            me.initToolTip();\n            plugins.notify(me, 'afterInit');\n            return me;\n        },\n        clear: function () {\n            helpers.canvas.clear(this);\n            return this;\n        },\n        stop: function () {\n            animations.cancelAnimation(this);\n            return this;\n        },\n        resize: function (silent) {\n            var me = this;\n            var options = me.options;\n            var canvas = me.canvas;\n            var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null;\n            var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));\n            var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));\n            if (me.width === newWidth && me.height === newHeight) {\n                return;\n            }\n            canvas.width = me.width = newWidth;\n            canvas.height = me.height = newHeight;\n            canvas.style.width = newWidth + 'px';\n            canvas.style.height = newHeight + 'px';\n            helpers.retinaScale(me, options.devicePixelRatio);\n            if (!silent) {\n                var newSize = {\n                    width: newWidth,\n                    height: newHeight\n                };\n                plugins.notify(me, 'resize', [newSize]);\n                if (options.onResize) {\n                    options.onResize(me, newSize);\n                }\n                me.stop();\n                me.update({ duration: options.responsiveAnimationDuration });\n            }\n        },\n        ensureScalesHaveIDs: function () {\n            var options = this.options;\n            var scalesOptions = options.scales || {};\n            var scaleOptions = options.scale;\n            helpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {\n                xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;\n            });\n            helpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {\n                yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;\n            });\n            if (scaleOptions) {\n                scaleOptions.id = scaleOptions.id || 'scale';\n            }\n        },\n        buildOrUpdateScales: function () {\n            var me = this;\n            var options = me.options;\n            var scales = me.scales || {};\n            var items = [];\n            var updated = Object.keys(scales).reduce(function (obj, id) {\n                obj[id] = false;\n                return obj;\n            }, {});\n            if (options.scales) {\n                items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {\n                    return {\n                        options: xAxisOptions,\n                        dtype: 'category',\n                        dposition: 'bottom'\n                    };\n                }), (options.scales.yAxes || []).map(function (yAxisOptions) {\n                    return {\n                        options: yAxisOptions,\n                        dtype: 'linear',\n                        dposition: 'left'\n                    };\n                }));\n            }\n            if (options.scale) {\n                items.push({\n                    options: options.scale,\n                    dtype: 'radialLinear',\n                    isDefault: true,\n                    dposition: 'chartArea'\n                });\n            }\n            helpers.each(items, function (item) {\n                var scaleOptions = item.options;\n                var id = scaleOptions.id;\n                var scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n                if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n                    scaleOptions.position = item.dposition;\n                }\n                updated[id] = true;\n                var scale = null;\n                if (id in scales && scales[id].type === scaleType) {\n                    scale = scales[id];\n                    scale.options = scaleOptions;\n                    scale.ctx = me.ctx;\n                    scale.chart = me;\n                } else {\n                    var scaleClass = scaleService.getScaleConstructor(scaleType);\n                    if (!scaleClass) {\n                        return;\n                    }\n                    scale = new scaleClass({\n                        id: id,\n                        type: scaleType,\n                        options: scaleOptions,\n                        ctx: me.ctx,\n                        chart: me\n                    });\n                    scales[scale.id] = scale;\n                }\n                scale.mergeTicksOptions();\n                if (item.isDefault) {\n                    me.scale = scale;\n                }\n            });\n            helpers.each(updated, function (hasUpdated, id) {\n                if (!hasUpdated) {\n                    delete scales[id];\n                }\n            });\n            me.scales = scales;\n            scaleService.addScalesToLayout(this);\n        },\n        buildOrUpdateControllers: function () {\n            var me = this;\n            var newControllers = [];\n            helpers.each(me.data.datasets, function (dataset, datasetIndex) {\n                var meta = me.getDatasetMeta(datasetIndex);\n                var type = dataset.type || me.config.type;\n                if (meta.type && meta.type !== type) {\n                    me.destroyDatasetMeta(datasetIndex);\n                    meta = me.getDatasetMeta(datasetIndex);\n                }\n                meta.type = type;\n                if (meta.controller) {\n                    meta.controller.updateIndex(datasetIndex);\n                    meta.controller.linkScales();\n                } else {\n                    var ControllerClass = controllers[meta.type];\n                    if (ControllerClass === undefined) {\n                        throw new Error('\"' + meta.type + '\" is not a chart type.');\n                    }\n                    meta.controller = new ControllerClass(me, datasetIndex);\n                    newControllers.push(meta.controller);\n                }\n            }, me);\n            return newControllers;\n        },\n        resetElements: function () {\n            var me = this;\n            helpers.each(me.data.datasets, function (dataset, datasetIndex) {\n                me.getDatasetMeta(datasetIndex).controller.reset();\n            }, me);\n        },\n        reset: function () {\n            this.resetElements();\n            this.tooltip.initialize();\n        },\n        update: function (config) {\n            var me = this;\n            if (!config || typeof config !== 'object') {\n                config = {\n                    duration: config,\n                    lazy: arguments[1]\n                };\n            }\n            updateConfig(me);\n            plugins._invalidate(me);\n            if (plugins.notify(me, 'beforeUpdate') === false) {\n                return;\n            }\n            me.tooltip._data = me.data;\n            var newControllers = me.buildOrUpdateControllers();\n            helpers.each(me.data.datasets, function (dataset, datasetIndex) {\n                me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n            }, me);\n            me.updateLayout();\n            if (me.options.animation && me.options.animation.duration) {\n                helpers.each(newControllers, function (controller) {\n                    controller.reset();\n                });\n            }\n            me.updateDatasets();\n            me.tooltip.initialize();\n            me.lastActive = [];\n            plugins.notify(me, 'afterUpdate');\n            if (me._bufferedRender) {\n                me._bufferedRequest = {\n                    duration: config.duration,\n                    easing: config.easing,\n                    lazy: config.lazy\n                };\n            } else {\n                me.render(config);\n            }\n        },\n        updateLayout: function () {\n            var me = this;\n            if (plugins.notify(me, 'beforeLayout') === false) {\n                return;\n            }\n            layouts.update(this, this.width, this.height);\n            plugins.notify(me, 'afterScaleUpdate');\n            plugins.notify(me, 'afterLayout');\n        },\n        updateDatasets: function () {\n            var me = this;\n            if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n                return;\n            }\n            for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n                me.updateDataset(i);\n            }\n            plugins.notify(me, 'afterDatasetsUpdate');\n        },\n        updateDataset: function (index) {\n            var me = this;\n            var meta = me.getDatasetMeta(index);\n            var args = {\n                meta: meta,\n                index: index\n            };\n            if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n                return;\n            }\n            meta.controller.update();\n            plugins.notify(me, 'afterDatasetUpdate', [args]);\n        },\n        render: function (config) {\n            var me = this;\n            if (!config || typeof config !== 'object') {\n                config = {\n                    duration: config,\n                    lazy: arguments[1]\n                };\n            }\n            var animationOptions = me.options.animation;\n            var duration = valueOrDefault(config.duration, animationOptions && animationOptions.duration);\n            var lazy = config.lazy;\n            if (plugins.notify(me, 'beforeRender') === false) {\n                return;\n            }\n            var onComplete = function (animation) {\n                plugins.notify(me, 'afterRender');\n                helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);\n            };\n            if (animationOptions && duration) {\n                var animation = new Animation({\n                    numSteps: duration / 16.66,\n                    easing: config.easing || animationOptions.easing,\n                    render: function (chart, animationObject) {\n                        var easingFunction = helpers.easing.effects[animationObject.easing];\n                        var currentStep = animationObject.currentStep;\n                        var stepDecimal = currentStep / animationObject.numSteps;\n                        chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n                    },\n                    onAnimationProgress: animationOptions.onProgress,\n                    onAnimationComplete: onComplete\n                });\n                animations.addAnimation(me, animation, duration, lazy);\n            } else {\n                me.draw();\n                onComplete(new Animation({\n                    numSteps: 0,\n                    chart: me\n                }));\n            }\n            return me;\n        },\n        draw: function (easingValue) {\n            var me = this;\n            me.clear();\n            if (helpers.isNullOrUndef(easingValue)) {\n                easingValue = 1;\n            }\n            me.transition(easingValue);\n            if (me.width <= 0 || me.height <= 0) {\n                return;\n            }\n            if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n                return;\n            }\n            helpers.each(me.boxes, function (box) {\n                box.draw(me.chartArea);\n            }, me);\n            me.drawDatasets(easingValue);\n            me._drawTooltip(easingValue);\n            plugins.notify(me, 'afterDraw', [easingValue]);\n        },\n        transition: function (easingValue) {\n            var me = this;\n            for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {\n                if (me.isDatasetVisible(i)) {\n                    me.getDatasetMeta(i).controller.transition(easingValue);\n                }\n            }\n            me.tooltip.transition(easingValue);\n        },\n        drawDatasets: function (easingValue) {\n            var me = this;\n            if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n                return;\n            }\n            for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {\n                if (me.isDatasetVisible(i)) {\n                    me.drawDataset(i, easingValue);\n                }\n            }\n            plugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n        },\n        drawDataset: function (index, easingValue) {\n            var me = this;\n            var meta = me.getDatasetMeta(index);\n            var args = {\n                meta: meta,\n                index: index,\n                easingValue: easingValue\n            };\n            if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n                return;\n            }\n            meta.controller.draw(easingValue);\n            plugins.notify(me, 'afterDatasetDraw', [args]);\n        },\n        _drawTooltip: function (easingValue) {\n            var me = this;\n            var tooltip = me.tooltip;\n            var args = {\n                tooltip: tooltip,\n                easingValue: easingValue\n            };\n            if (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\n                return;\n            }\n            tooltip.draw();\n            plugins.notify(me, 'afterTooltipDraw', [args]);\n        },\n        getElementAtEvent: function (e) {\n            return Interaction.modes.single(this, e);\n        },\n        getElementsAtEvent: function (e) {\n            return Interaction.modes.label(this, e, { intersect: true });\n        },\n        getElementsAtXAxis: function (e) {\n            return Interaction.modes['x-axis'](this, e, { intersect: true });\n        },\n        getElementsAtEventForMode: function (e, mode, options) {\n            var method = Interaction.modes[mode];\n            if (typeof method === 'function') {\n                return method(this, e, options);\n            }\n            return [];\n        },\n        getDatasetAtEvent: function (e) {\n            return Interaction.modes.dataset(this, e, { intersect: true });\n        },\n        getDatasetMeta: function (datasetIndex) {\n            var me = this;\n            var dataset = me.data.datasets[datasetIndex];\n            if (!dataset._meta) {\n                dataset._meta = {};\n            }\n            var meta = dataset._meta[me.id];\n            if (!meta) {\n                meta = dataset._meta[me.id] = {\n                    type: null,\n                    data: [],\n                    dataset: null,\n                    controller: null,\n                    hidden: null,\n                    xAxisID: null,\n                    yAxisID: null\n                };\n            }\n            return meta;\n        },\n        getVisibleDatasetCount: function () {\n            var count = 0;\n            for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n                if (this.isDatasetVisible(i)) {\n                    count++;\n                }\n            }\n            return count;\n        },\n        isDatasetVisible: function (datasetIndex) {\n            var meta = this.getDatasetMeta(datasetIndex);\n            return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n        },\n        generateLegend: function () {\n            return this.options.legendCallback(this);\n        },\n        destroyDatasetMeta: function (datasetIndex) {\n            var id = this.id;\n            var dataset = this.data.datasets[datasetIndex];\n            var meta = dataset._meta && dataset._meta[id];\n            if (meta) {\n                meta.controller.destroy();\n                delete dataset._meta[id];\n            }\n        },\n        destroy: function () {\n            var me = this;\n            var canvas = me.canvas;\n            var i, ilen;\n            me.stop();\n            for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n                me.destroyDatasetMeta(i);\n            }\n            if (canvas) {\n                me.unbindEvents();\n                helpers.canvas.clear(me);\n                platform.releaseContext(me.ctx);\n                me.canvas = null;\n                me.ctx = null;\n            }\n            plugins.notify(me, 'destroy');\n            delete Chart.instances[me.id];\n        },\n        toBase64Image: function () {\n            return this.canvas.toDataURL.apply(this.canvas, arguments);\n        },\n        initToolTip: function () {\n            var me = this;\n            me.tooltip = new Tooltip({\n                _chart: me,\n                _chartInstance: me,\n                _data: me.data,\n                _options: me.options.tooltips\n            }, me);\n        },\n        bindEvents: function () {\n            var me = this;\n            var listeners = me._listeners = {};\n            var listener = function () {\n                me.eventHandler.apply(me, arguments);\n            };\n            helpers.each(me.options.events, function (type) {\n                platform.addEventListener(me, type, listener);\n                listeners[type] = listener;\n            });\n            if (me.options.responsive) {\n                listener = function () {\n                    me.resize();\n                };\n                platform.addEventListener(me, 'resize', listener);\n                listeners.resize = listener;\n            }\n        },\n        unbindEvents: function () {\n            var me = this;\n            var listeners = me._listeners;\n            if (!listeners) {\n                return;\n            }\n            delete me._listeners;\n            helpers.each(listeners, function (listener, type) {\n                platform.removeEventListener(me, type, listener);\n            });\n        },\n        updateHoverStyle: function (elements, mode, enabled) {\n            var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';\n            var element, i, ilen;\n            for (i = 0, ilen = elements.length; i < ilen; ++i) {\n                element = elements[i];\n                if (element) {\n                    this.getDatasetMeta(element._datasetIndex).controller[method](element);\n                }\n            }\n        },\n        eventHandler: function (e) {\n            var me = this;\n            var tooltip = me.tooltip;\n            if (plugins.notify(me, 'beforeEvent', [e]) === false) {\n                return;\n            }\n            me._bufferedRender = true;\n            me._bufferedRequest = null;\n            var changed = me.handleEvent(e);\n            if (tooltip) {\n                changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);\n            }\n            plugins.notify(me, 'afterEvent', [e]);\n            var bufferedRequest = me._bufferedRequest;\n            if (bufferedRequest) {\n                me.render(bufferedRequest);\n            } else if (changed && !me.animating) {\n                me.stop();\n                me.render({\n                    duration: me.options.hover.animationDuration,\n                    lazy: true\n                });\n            }\n            me._bufferedRender = false;\n            me._bufferedRequest = null;\n            return me;\n        },\n        handleEvent: function (e) {\n            var me = this;\n            var options = me.options || {};\n            var hoverOptions = options.hover;\n            var changed = false;\n            me.lastActive = me.lastActive || [];\n            if (e.type === 'mouseout') {\n                me.active = [];\n            } else {\n                me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n            }\n            helpers.callback(options.onHover || options.hover.onHover, [\n                e.native,\n                me.active\n            ], me);\n            if (e.type === 'mouseup' || e.type === 'click') {\n                if (options.onClick) {\n                    options.onClick.call(me, e.native, me.active);\n                }\n            }\n            if (me.lastActive.length) {\n                me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n            }\n            if (me.active.length && hoverOptions.mode) {\n                me.updateHoverStyle(me.active, hoverOptions.mode, true);\n            }\n            changed = !helpers.arrayEquals(me.active, me.lastActive);\n            me.lastActive = me.active;\n            return changed;\n        }\n    });\n    Chart.instances = {};\n    module.exports = Chart;\n    Chart.Controller = Chart;\n    Chart.types = {};\n    helpers.configMerge = mergeConfig;\n    helpers.scaleMerge = mergeScaleConfig;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.helpers',[\n    '../../packages/chartjs-color',\n    './core.defaults',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var color = __module__0;\n    var defaults = __module__1;\n    var helpers = __module__2;\n    module.exports = function () {\n        helpers.where = function (collection, filterCallback) {\n            if (helpers.isArray(collection) && Array.prototype.filter) {\n                return collection.filter(filterCallback);\n            }\n            var filtered = [];\n            helpers.each(collection, function (item) {\n                if (filterCallback(item)) {\n                    filtered.push(item);\n                }\n            });\n            return filtered;\n        };\n        helpers.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {\n            return array.findIndex(callback, scope);\n        } : function (array, callback, scope) {\n            scope = scope === undefined ? array : scope;\n            for (var i = 0, ilen = array.length; i < ilen; ++i) {\n                if (callback.call(scope, array[i], i, array)) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n        helpers.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {\n            if (helpers.isNullOrUndef(startIndex)) {\n                startIndex = -1;\n            }\n            for (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n                var currentItem = arrayToSearch[i];\n                if (filterCallback(currentItem)) {\n                    return currentItem;\n                }\n            }\n        };\n        helpers.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {\n            if (helpers.isNullOrUndef(startIndex)) {\n                startIndex = arrayToSearch.length;\n            }\n            for (var i = startIndex - 1; i >= 0; i--) {\n                var currentItem = arrayToSearch[i];\n                if (filterCallback(currentItem)) {\n                    return currentItem;\n                }\n            }\n        };\n        helpers.isNumber = function (n) {\n            return !isNaN(parseFloat(n)) && isFinite(n);\n        };\n        helpers.almostEquals = function (x, y, epsilon) {\n            return Math.abs(x - y) < epsilon;\n        };\n        helpers.almostWhole = function (x, epsilon) {\n            var rounded = Math.round(x);\n            return rounded - epsilon < x && rounded + epsilon > x;\n        };\n        helpers.max = function (array) {\n            return array.reduce(function (max, value) {\n                if (!isNaN(value)) {\n                    return Math.max(max, value);\n                }\n                return max;\n            }, Number.NEGATIVE_INFINITY);\n        };\n        helpers.min = function (array) {\n            return array.reduce(function (min, value) {\n                if (!isNaN(value)) {\n                    return Math.min(min, value);\n                }\n                return min;\n            }, Number.POSITIVE_INFINITY);\n        };\n        helpers.sign = Math.sign ? function (x) {\n            return Math.sign(x);\n        } : function (x) {\n            x = +x;\n            if (x === 0 || isNaN(x)) {\n                return x;\n            }\n            return x > 0 ? 1 : -1;\n        };\n        helpers.log10 = Math.log10 ? function (x) {\n            return Math.log10(x);\n        } : function (x) {\n            var exponent = Math.log(x) * Math.LOG10E;\n            var powerOf10 = Math.round(exponent);\n            var isPowerOf10 = x === Math.pow(10, powerOf10);\n            return isPowerOf10 ? powerOf10 : exponent;\n        };\n        helpers.toRadians = function (degrees) {\n            return degrees * (Math.PI / 180);\n        };\n        helpers.toDegrees = function (radians) {\n            return radians * (180 / Math.PI);\n        };\n        helpers._decimalPlaces = function (x) {\n            if (!helpers.isFinite(x)) {\n                return;\n            }\n            var e = 1;\n            var p = 0;\n            while (Math.round(x * e) / e !== x) {\n                e *= 10;\n                p++;\n            }\n            return p;\n        };\n        helpers.getAngleFromPoint = function (centrePoint, anglePoint) {\n            var distanceFromXCenter = anglePoint.x - centrePoint.x;\n            var distanceFromYCenter = anglePoint.y - centrePoint.y;\n            var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n            var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n            if (angle < -0.5 * Math.PI) {\n                angle += 2 * Math.PI;\n            }\n            return {\n                angle: angle,\n                distance: radialDistanceFromCenter\n            };\n        };\n        helpers.distanceBetweenPoints = function (pt1, pt2) {\n            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n        };\n        helpers.aliasPixel = function (pixelWidth) {\n            return pixelWidth % 2 === 0 ? 0 : 0.5;\n        };\n        helpers._alignPixel = function (chart, pixel, width) {\n            var devicePixelRatio = chart.currentDevicePixelRatio;\n            var halfWidth = width / 2;\n            return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n        };\n        helpers.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {\n            var previous = firstPoint.skip ? middlePoint : firstPoint;\n            var current = middlePoint;\n            var next = afterPoint.skip ? middlePoint : afterPoint;\n            var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n            var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n            var s01 = d01 / (d01 + d12);\n            var s12 = d12 / (d01 + d12);\n            s01 = isNaN(s01) ? 0 : s01;\n            s12 = isNaN(s12) ? 0 : s12;\n            var fa = t * s01;\n            var fb = t * s12;\n            return {\n                previous: {\n                    x: current.x - fa * (next.x - previous.x),\n                    y: current.y - fa * (next.y - previous.y)\n                },\n                next: {\n                    x: current.x + fb * (next.x - previous.x),\n                    y: current.y + fb * (next.y - previous.y)\n                }\n            };\n        };\n        helpers.EPSILON = Number.EPSILON || 1e-14;\n        helpers.splineCurveMonotone = function (points) {\n            var pointsWithTangents = (points || []).map(function (point) {\n                return {\n                    model: point._model,\n                    deltaK: 0,\n                    mK: 0\n                };\n            });\n            var pointsLen = pointsWithTangents.length;\n            var i, pointBefore, pointCurrent, pointAfter;\n            for (i = 0; i < pointsLen; ++i) {\n                pointCurrent = pointsWithTangents[i];\n                if (pointCurrent.model.skip) {\n                    continue;\n                }\n                pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n                pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n                if (pointAfter && !pointAfter.model.skip) {\n                    var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;\n                    pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n                }\n                if (!pointBefore || pointBefore.model.skip) {\n                    pointCurrent.mK = pointCurrent.deltaK;\n                } else if (!pointAfter || pointAfter.model.skip) {\n                    pointCurrent.mK = pointBefore.deltaK;\n                } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n                    pointCurrent.mK = 0;\n                } else {\n                    pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n                }\n            }\n            var alphaK, betaK, tauK, squaredMagnitude;\n            for (i = 0; i < pointsLen - 1; ++i) {\n                pointCurrent = pointsWithTangents[i];\n                pointAfter = pointsWithTangents[i + 1];\n                if (pointCurrent.model.skip || pointAfter.model.skip) {\n                    continue;\n                }\n                if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n                    pointCurrent.mK = pointAfter.mK = 0;\n                    continue;\n                }\n                alphaK = pointCurrent.mK / pointCurrent.deltaK;\n                betaK = pointAfter.mK / pointCurrent.deltaK;\n                squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n                if (squaredMagnitude <= 9) {\n                    continue;\n                }\n                tauK = 3 / Math.sqrt(squaredMagnitude);\n                pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n                pointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n            }\n            var deltaX;\n            for (i = 0; i < pointsLen; ++i) {\n                pointCurrent = pointsWithTangents[i];\n                if (pointCurrent.model.skip) {\n                    continue;\n                }\n                pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n                pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n                if (pointBefore && !pointBefore.model.skip) {\n                    deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n                    pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n                    pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n                }\n                if (pointAfter && !pointAfter.model.skip) {\n                    deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n                    pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n                    pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n                }\n            }\n        };\n        helpers.nextItem = function (collection, index, loop) {\n            if (loop) {\n                return index >= collection.length - 1 ? collection[0] : collection[index + 1];\n            }\n            return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n        };\n        helpers.previousItem = function (collection, index, loop) {\n            if (loop) {\n                return index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n            }\n            return index <= 0 ? collection[0] : collection[index - 1];\n        };\n        helpers.niceNum = function (range, round) {\n            var exponent = Math.floor(helpers.log10(range));\n            var fraction = range / Math.pow(10, exponent);\n            var niceFraction;\n            if (round) {\n                if (fraction < 1.5) {\n                    niceFraction = 1;\n                } else if (fraction < 3) {\n                    niceFraction = 2;\n                } else if (fraction < 7) {\n                    niceFraction = 5;\n                } else {\n                    niceFraction = 10;\n                }\n            } else if (fraction <= 1) {\n                niceFraction = 1;\n            } else if (fraction <= 2) {\n                niceFraction = 2;\n            } else if (fraction <= 5) {\n                niceFraction = 5;\n            } else {\n                niceFraction = 10;\n            }\n            return niceFraction * Math.pow(10, exponent);\n        };\n        helpers.requestAnimFrame = function () {\n            if (typeof window === 'undefined') {\n                return function (callback) {\n                    callback();\n                };\n            }\n            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n                return window.setTimeout(callback, 1000 / 60);\n            };\n        }();\n        helpers.getRelativePosition = function (evt, chart) {\n            var mouseX, mouseY;\n            var e = evt.originalEvent || evt;\n            var canvas = evt.target || evt.srcElement;\n            var boundingRect = canvas.getBoundingClientRect();\n            var touches = e.touches;\n            if (touches && touches.length > 0) {\n                mouseX = touches[0].clientX;\n                mouseY = touches[0].clientY;\n            } else {\n                mouseX = e.clientX;\n                mouseY = e.clientY;\n            }\n            var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\n            var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\n            var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\n            var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\n            var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n            var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n            mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);\n            mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);\n            return {\n                x: mouseX,\n                y: mouseY\n            };\n        };\n        function parseMaxStyle(styleValue, node, parentProperty) {\n            var valueInPixels;\n            if (typeof styleValue === 'string') {\n                valueInPixels = parseInt(styleValue, 10);\n                if (styleValue.indexOf('%') !== -1) {\n                    valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n                }\n            } else {\n                valueInPixels = styleValue;\n            }\n            return valueInPixels;\n        }\n        function isConstrainedValue(value) {\n            return value !== undefined && value !== null && value !== 'none';\n        }\n        function getConstraintDimension(domNode, maxStyle, percentageProperty) {\n            var view = document.defaultView;\n            var parentNode = helpers._getParentNode(domNode);\n            var constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n            var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n            var hasCNode = isConstrainedValue(constrainedNode);\n            var hasCContainer = isConstrainedValue(constrainedContainer);\n            var infinity = Number.POSITIVE_INFINITY;\n            if (hasCNode || hasCContainer) {\n                return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n            }\n            return 'none';\n        }\n        helpers.getConstraintWidth = function (domNode) {\n            return getConstraintDimension(domNode, 'max-width', 'clientWidth');\n        };\n        helpers.getConstraintHeight = function (domNode) {\n            return getConstraintDimension(domNode, 'max-height', 'clientHeight');\n        };\n        helpers._calculatePadding = function (container, padding, parentDimension) {\n            padding = helpers.getStyle(container, padding);\n            return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);\n        };\n        helpers._getParentNode = function (domNode) {\n            var parent = domNode.parentNode;\n            if (parent && parent.toString() === '[object ShadowRoot]') {\n                parent = parent.host;\n            }\n            return parent;\n        };\n        helpers.getMaximumWidth = function (domNode) {\n            var container = helpers._getParentNode(domNode);\n            if (!container) {\n                return domNode.clientWidth;\n            }\n            var clientWidth = container.clientWidth;\n            var paddingLeft = helpers._calculatePadding(container, 'padding-left', clientWidth);\n            var paddingRight = helpers._calculatePadding(container, 'padding-right', clientWidth);\n            var w = clientWidth - paddingLeft - paddingRight;\n            var cw = helpers.getConstraintWidth(domNode);\n            return isNaN(cw) ? w : Math.min(w, cw);\n        };\n        helpers.getMaximumHeight = function (domNode) {\n            var container = helpers._getParentNode(domNode);\n            if (!container) {\n                return domNode.clientHeight;\n            }\n            var clientHeight = container.clientHeight;\n            var paddingTop = helpers._calculatePadding(container, 'padding-top', clientHeight);\n            var paddingBottom = helpers._calculatePadding(container, 'padding-bottom', clientHeight);\n            var h = clientHeight - paddingTop - paddingBottom;\n            var ch = helpers.getConstraintHeight(domNode);\n            return isNaN(ch) ? h : Math.min(h, ch);\n        };\n        helpers.getStyle = function (el, property) {\n            return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n        };\n        helpers.retinaScale = function (chart, forceRatio) {\n            var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;\n            if (pixelRatio === 1) {\n                return;\n            }\n            var canvas = chart.canvas;\n            var height = chart.height;\n            var width = chart.width;\n            canvas.height = height * pixelRatio;\n            canvas.width = width * pixelRatio;\n            chart.ctx.scale(pixelRatio, pixelRatio);\n            if (!canvas.style.height && !canvas.style.width) {\n                canvas.style.height = height + 'px';\n                canvas.style.width = width + 'px';\n            }\n        };\n        helpers.fontString = function (pixelSize, fontStyle, fontFamily) {\n            return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n        };\n        helpers.longestText = function (ctx, font, arrayOfThings, cache) {\n            cache = cache || {};\n            var data = cache.data = cache.data || {};\n            var gc = cache.garbageCollect = cache.garbageCollect || [];\n            if (cache.font !== font) {\n                data = cache.data = {};\n                gc = cache.garbageCollect = [];\n                cache.font = font;\n            }\n            ctx.font = font;\n            var longest = 0;\n            helpers.each(arrayOfThings, function (thing) {\n                if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\n                    longest = helpers.measureText(ctx, data, gc, longest, thing);\n                } else if (helpers.isArray(thing)) {\n                    helpers.each(thing, function (nestedThing) {\n                        if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\n                            longest = helpers.measureText(ctx, data, gc, longest, nestedThing);\n                        }\n                    });\n                }\n            });\n            var gcLen = gc.length / 2;\n            if (gcLen > arrayOfThings.length) {\n                for (var i = 0; i < gcLen; i++) {\n                    delete data[gc[i]];\n                }\n                gc.splice(0, gcLen);\n            }\n            return longest;\n        };\n        helpers.measureText = function (ctx, data, gc, longest, string) {\n            var textWidth = data[string];\n            if (!textWidth) {\n                textWidth = data[string] = ctx.measureText(string).width;\n                gc.push(string);\n            }\n            if (textWidth > longest) {\n                longest = textWidth;\n            }\n            return longest;\n        };\n        helpers.numberOfLabelLines = function (arrayOfThings) {\n            var numberOfLines = 1;\n            helpers.each(arrayOfThings, function (thing) {\n                if (helpers.isArray(thing)) {\n                    if (thing.length > numberOfLines) {\n                        numberOfLines = thing.length;\n                    }\n                }\n            });\n            return numberOfLines;\n        };\n        helpers.color = !color ? function (value) {\n            console.error('Color.js not found!');\n            return value;\n        } : function (value) {\n            if (value instanceof CanvasGradient) {\n                value = defaults.global.defaultColor;\n            }\n            return color(value);\n        };\n        helpers.getHoverColor = function (colorValue) {\n            return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n        };\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.adapters',['../helpers/index'], function (__module__0) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    function abstract() {\n        throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');\n    }\n    function DateAdapter(options) {\n        this.options = options || {};\n    }\n    helpers.extend(DateAdapter.prototype, {\n        formats: abstract,\n        parse: abstract,\n        format: abstract,\n        add: abstract,\n        diff: abstract,\n        startOf: abstract,\n        endOf: abstract,\n        _create: function (value) {\n            return value;\n        }\n    });\n    DateAdapter.override = function (members) {\n        helpers.extend(DateAdapter.prototype, members);\n    };\n    module.exports._date = DateAdapter;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.ticks',['../helpers/index'], function (__module__0) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    module.exports = {\n        formatters: {\n            values: function (value) {\n                return helpers.isArray(value) ? value : '' + value;\n            },\n            linear: function (tickValue, index, ticks) {\n                var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n                if (Math.abs(delta) > 1) {\n                    if (tickValue !== Math.floor(tickValue)) {\n                        delta = tickValue - Math.floor(tickValue);\n                    }\n                }\n                var logDelta = helpers.log10(Math.abs(delta));\n                var tickString = '';\n                if (tickValue !== 0) {\n                    var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));\n                    if (maxTick < 0.0001) {\n                        var logTick = helpers.log10(Math.abs(tickValue));\n                        tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));\n                    } else {\n                        var numDecimal = -1 * Math.floor(logDelta);\n                        numDecimal = Math.max(Math.min(numDecimal, 20), 0);\n                        tickString = tickValue.toFixed(numDecimal);\n                    }\n                } else {\n                    tickString = '0';\n                }\n                return tickString;\n            },\n            logarithmic: function (tickValue, index, ticks) {\n                var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));\n                if (tickValue === 0) {\n                    return '0';\n                } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n                    return tickValue.toExponential();\n                }\n                return '';\n            }\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/core/core.scale',[\n    './core.defaults',\n    './core.element',\n    '../helpers/index',\n    './core.ticks'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var Element = __module__1;\n    var helpers = __module__2;\n    var Ticks = __module__3;\n    var valueOrDefault = helpers.valueOrDefault;\n    var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n    defaults._set('scale', {\n        display: true,\n        position: 'left',\n        offset: false,\n        gridLines: {\n            display: true,\n            color: 'rgba(0, 0, 0, 0.1)',\n            lineWidth: 1,\n            drawBorder: true,\n            drawOnChartArea: true,\n            drawTicks: true,\n            tickMarkLength: 10,\n            zeroLineWidth: 1,\n            zeroLineColor: 'rgba(0,0,0,0.25)',\n            zeroLineBorderDash: [],\n            zeroLineBorderDashOffset: 0,\n            offsetGridLines: false,\n            borderDash: [],\n            borderDashOffset: 0\n        },\n        scaleLabel: {\n            display: false,\n            labelString: '',\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            beginAtZero: false,\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: false,\n            padding: 0,\n            reverse: false,\n            display: true,\n            autoSkip: true,\n            autoSkipPadding: 0,\n            labelOffset: 0,\n            callback: Ticks.formatters.values,\n            minor: {},\n            major: {}\n        }\n    });\n    function labelsFromTicks(ticks) {\n        var labels = [];\n        var i, ilen;\n        for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n            labels.push(ticks[i].label);\n        }\n        return labels;\n    }\n    function getPixelForGridLine(scale, index, offsetGridLines) {\n        var lineValue = scale.getPixelForTick(index);\n        if (offsetGridLines) {\n            if (scale.getTicks().length === 1) {\n                lineValue -= scale.isHorizontal() ? Math.max(lineValue - scale.left, scale.right - lineValue) : Math.max(lineValue - scale.top, scale.bottom - lineValue);\n            } else if (index === 0) {\n                lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n            } else {\n                lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n            }\n        }\n        return lineValue;\n    }\n    function computeTextSize(context, tick, font) {\n        return helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;\n    }\n    module.exports = Element.extend({\n        getPadding: function () {\n            var me = this;\n            return {\n                left: me.paddingLeft || 0,\n                top: me.paddingTop || 0,\n                right: me.paddingRight || 0,\n                bottom: me.paddingBottom || 0\n            };\n        },\n        getTicks: function () {\n            return this._ticks;\n        },\n        mergeTicksOptions: function () {\n            var ticks = this.options.ticks;\n            if (ticks.minor === false) {\n                ticks.minor = { display: false };\n            }\n            if (ticks.major === false) {\n                ticks.major = { display: false };\n            }\n            for (var key in ticks) {\n                if (key !== 'major' && key !== 'minor') {\n                    if (typeof ticks.minor[key] === 'undefined') {\n                        ticks.minor[key] = ticks[key];\n                    }\n                    if (typeof ticks.major[key] === 'undefined') {\n                        ticks.major[key] = ticks[key];\n                    }\n                }\n            }\n        },\n        beforeUpdate: function () {\n            helpers.callback(this.options.beforeUpdate, [this]);\n        },\n        update: function (maxWidth, maxHeight, margins) {\n            var me = this;\n            var i, ilen, labels, label, ticks, tick;\n            me.beforeUpdate();\n            me.maxWidth = maxWidth;\n            me.maxHeight = maxHeight;\n            me.margins = helpers.extend({\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, margins);\n            me._maxLabelLines = 0;\n            me.longestLabelWidth = 0;\n            me.longestTextCache = me.longestTextCache || {};\n            me.beforeSetDimensions();\n            me.setDimensions();\n            me.afterSetDimensions();\n            me.beforeDataLimits();\n            me.determineDataLimits();\n            me.afterDataLimits();\n            me.beforeBuildTicks();\n            ticks = me.buildTicks() || [];\n            ticks = me.afterBuildTicks(ticks) || ticks;\n            me.beforeTickToLabelConversion();\n            labels = me.convertTicksToLabels(ticks) || me.ticks;\n            me.afterTickToLabelConversion();\n            me.ticks = labels;\n            for (i = 0, ilen = labels.length; i < ilen; ++i) {\n                label = labels[i];\n                tick = ticks[i];\n                if (!tick) {\n                    ticks.push(tick = {\n                        label: label,\n                        major: false\n                    });\n                } else {\n                    tick.label = label;\n                }\n            }\n            me._ticks = ticks;\n            me.beforeCalculateTickRotation();\n            me.calculateTickRotation();\n            me.afterCalculateTickRotation();\n            me.beforeFit();\n            me.fit();\n            me.afterFit();\n            me.afterUpdate();\n            return me.minSize;\n        },\n        afterUpdate: function () {\n            helpers.callback(this.options.afterUpdate, [this]);\n        },\n        beforeSetDimensions: function () {\n            helpers.callback(this.options.beforeSetDimensions, [this]);\n        },\n        setDimensions: function () {\n            var me = this;\n            if (me.isHorizontal()) {\n                me.width = me.maxWidth;\n                me.left = 0;\n                me.right = me.width;\n            } else {\n                me.height = me.maxHeight;\n                me.top = 0;\n                me.bottom = me.height;\n            }\n            me.paddingLeft = 0;\n            me.paddingTop = 0;\n            me.paddingRight = 0;\n            me.paddingBottom = 0;\n        },\n        afterSetDimensions: function () {\n            helpers.callback(this.options.afterSetDimensions, [this]);\n        },\n        beforeDataLimits: function () {\n            helpers.callback(this.options.beforeDataLimits, [this]);\n        },\n        determineDataLimits: helpers.noop,\n        afterDataLimits: function () {\n            helpers.callback(this.options.afterDataLimits, [this]);\n        },\n        beforeBuildTicks: function () {\n            helpers.callback(this.options.beforeBuildTicks, [this]);\n        },\n        buildTicks: helpers.noop,\n        afterBuildTicks: function (ticks) {\n            var me = this;\n            if (helpers.isArray(ticks) && ticks.length) {\n                return helpers.callback(me.options.afterBuildTicks, [\n                    me,\n                    ticks\n                ]);\n            }\n            me.ticks = helpers.callback(me.options.afterBuildTicks, [\n                me,\n                me.ticks\n            ]) || me.ticks;\n            return ticks;\n        },\n        beforeTickToLabelConversion: function () {\n            helpers.callback(this.options.beforeTickToLabelConversion, [this]);\n        },\n        convertTicksToLabels: function () {\n            var me = this;\n            var tickOpts = me.options.ticks;\n            me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n        },\n        afterTickToLabelConversion: function () {\n            helpers.callback(this.options.afterTickToLabelConversion, [this]);\n        },\n        beforeCalculateTickRotation: function () {\n            helpers.callback(this.options.beforeCalculateTickRotation, [this]);\n        },\n        calculateTickRotation: function () {\n            var me = this;\n            var context = me.ctx;\n            var tickOpts = me.options.ticks;\n            var labels = labelsFromTicks(me._ticks);\n            var tickFont = helpers.options._parseFont(tickOpts);\n            context.font = tickFont.string;\n            var labelRotation = tickOpts.minRotation || 0;\n            if (labels.length && me.options.display && me.isHorizontal()) {\n                var originalLabelWidth = helpers.longestText(context, tickFont.string, labels, me.longestTextCache);\n                var labelWidth = originalLabelWidth;\n                var cosRotation, sinRotation;\n                var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n                while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n                    var angleRadians = helpers.toRadians(labelRotation);\n                    cosRotation = Math.cos(angleRadians);\n                    sinRotation = Math.sin(angleRadians);\n                    if (sinRotation * originalLabelWidth > me.maxHeight) {\n                        labelRotation--;\n                        break;\n                    }\n                    labelRotation++;\n                    labelWidth = cosRotation * originalLabelWidth;\n                }\n            }\n            me.labelRotation = labelRotation;\n        },\n        afterCalculateTickRotation: function () {\n            helpers.callback(this.options.afterCalculateTickRotation, [this]);\n        },\n        beforeFit: function () {\n            helpers.callback(this.options.beforeFit, [this]);\n        },\n        fit: function () {\n            var me = this;\n            var minSize = me.minSize = {\n                width: 0,\n                height: 0\n            };\n            var labels = labelsFromTicks(me._ticks);\n            var opts = me.options;\n            var tickOpts = opts.ticks;\n            var scaleLabelOpts = opts.scaleLabel;\n            var gridLineOpts = opts.gridLines;\n            var display = me._isVisible();\n            var position = opts.position;\n            var isHorizontal = me.isHorizontal();\n            var parseFont = helpers.options._parseFont;\n            var tickFont = parseFont(tickOpts);\n            var tickMarkLength = opts.gridLines.tickMarkLength;\n            if (isHorizontal) {\n                minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n            } else {\n                minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n            }\n            if (isHorizontal) {\n                minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n            } else {\n                minSize.height = me.maxHeight;\n            }\n            if (scaleLabelOpts.display && display) {\n                var scaleLabelFont = parseFont(scaleLabelOpts);\n                var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\n                var deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;\n                if (isHorizontal) {\n                    minSize.height += deltaHeight;\n                } else {\n                    minSize.width += deltaHeight;\n                }\n            }\n            if (tickOpts.display && display) {\n                var largestTextWidth = helpers.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);\n                var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\n                var lineSpace = tickFont.size * 0.5;\n                var tickPadding = me.options.ticks.padding;\n                me._maxLabelLines = tallestLabelHeightInLines;\n                me.longestLabelWidth = largestTextWidth;\n                if (isHorizontal) {\n                    var angleRadians = helpers.toRadians(me.labelRotation);\n                    var cosRotation = Math.cos(angleRadians);\n                    var sinRotation = Math.sin(angleRadians);\n                    var labelHeight = sinRotation * largestTextWidth + tickFont.lineHeight * tallestLabelHeightInLines + lineSpace;\n                    minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n                    me.ctx.font = tickFont.string;\n                    var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);\n                    var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);\n                    var offsetLeft = me.getPixelForTick(0) - me.left;\n                    var offsetRight = me.right - me.getPixelForTick(labels.length - 1);\n                    var paddingLeft, paddingRight;\n                    if (me.labelRotation !== 0) {\n                        paddingLeft = position === 'bottom' ? cosRotation * firstLabelWidth : cosRotation * lineSpace;\n                        paddingRight = position === 'bottom' ? cosRotation * lineSpace : cosRotation * lastLabelWidth;\n                    } else {\n                        paddingLeft = firstLabelWidth / 2;\n                        paddingRight = lastLabelWidth / 2;\n                    }\n                    me.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3;\n                    me.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;\n                } else {\n                    if (tickOpts.mirror) {\n                        largestTextWidth = 0;\n                    } else {\n                        largestTextWidth += tickPadding + lineSpace;\n                    }\n                    minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n                    me.paddingTop = tickFont.size / 2;\n                    me.paddingBottom = tickFont.size / 2;\n                }\n            }\n            me.handleMargins();\n            me.width = minSize.width;\n            me.height = minSize.height;\n        },\n        handleMargins: function () {\n            var me = this;\n            if (me.margins) {\n                me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n                me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n                me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n                me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n            }\n        },\n        afterFit: function () {\n            helpers.callback(this.options.afterFit, [this]);\n        },\n        isHorizontal: function () {\n            return this.options.position === 'top' || this.options.position === 'bottom';\n        },\n        isFullWidth: function () {\n            return this.options.fullWidth;\n        },\n        getRightValue: function (rawValue) {\n            if (helpers.isNullOrUndef(rawValue)) {\n                return NaN;\n            }\n            if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {\n                return NaN;\n            }\n            if (rawValue) {\n                if (this.isHorizontal()) {\n                    if (rawValue.x !== undefined) {\n                        return this.getRightValue(rawValue.x);\n                    }\n                } else if (rawValue.y !== undefined) {\n                    return this.getRightValue(rawValue.y);\n                }\n            }\n            return rawValue;\n        },\n        getLabelForIndex: helpers.noop,\n        getPixelForValue: helpers.noop,\n        getValueForPixel: helpers.noop,\n        getPixelForTick: function (index) {\n            var me = this;\n            var offset = me.options.offset;\n            if (me.isHorizontal()) {\n                var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n                var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);\n                var pixel = tickWidth * index + me.paddingLeft;\n                if (offset) {\n                    pixel += tickWidth / 2;\n                }\n                var finalVal = me.left + pixel;\n                finalVal += me.isFullWidth() ? me.margins.left : 0;\n                return finalVal;\n            }\n            var innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n            return me.top + index * (innerHeight / (me._ticks.length - 1));\n        },\n        getPixelForDecimal: function (decimal) {\n            var me = this;\n            if (me.isHorizontal()) {\n                var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n                var valueOffset = innerWidth * decimal + me.paddingLeft;\n                var finalVal = me.left + valueOffset;\n                finalVal += me.isFullWidth() ? me.margins.left : 0;\n                return finalVal;\n            }\n            return me.top + decimal * me.height;\n        },\n        getBasePixel: function () {\n            return this.getPixelForValue(this.getBaseValue());\n        },\n        getBaseValue: function () {\n            var me = this;\n            var min = me.min;\n            var max = me.max;\n            return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n        },\n        _autoSkip: function (ticks) {\n            var me = this;\n            var isHorizontal = me.isHorizontal();\n            var optionTicks = me.options.ticks.minor;\n            var tickCount = ticks.length;\n            var skipRatio = false;\n            var maxTicks = optionTicks.maxTicksLimit;\n            var ticksLength = me._tickSize() * (tickCount - 1);\n            var axisLength = isHorizontal ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.PaddingBottom);\n            var result = [];\n            var i, tick;\n            if (ticksLength > axisLength) {\n                skipRatio = 1 + Math.floor(ticksLength / axisLength);\n            }\n            if (tickCount > maxTicks) {\n                skipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));\n            }\n            for (i = 0; i < tickCount; i++) {\n                tick = ticks[i];\n                if (skipRatio > 1 && i % skipRatio > 0) {\n                    delete tick.label;\n                }\n                result.push(tick);\n            }\n            return result;\n        },\n        _tickSize: function () {\n            var me = this;\n            var isHorizontal = me.isHorizontal();\n            var optionTicks = me.options.ticks.minor;\n            var rot = helpers.toRadians(me.labelRotation);\n            var cos = Math.abs(Math.cos(rot));\n            var sin = Math.abs(Math.sin(rot));\n            var padding = optionTicks.autoSkipPadding || 0;\n            var w = me.longestLabelWidth + padding || 0;\n            var tickFont = helpers.options._parseFont(optionTicks);\n            var h = me._maxLabelLines * tickFont.lineHeight + padding || 0;\n            return isHorizontal ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n        },\n        _isVisible: function () {\n            var me = this;\n            var chart = me.chart;\n            var display = me.options.display;\n            var i, ilen, meta;\n            if (display !== 'auto') {\n                return !!display;\n            }\n            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    if (meta.xAxisID === me.id || meta.yAxisID === me.id) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        draw: function (chartArea) {\n            var me = this;\n            var options = me.options;\n            if (!me._isVisible()) {\n                return;\n            }\n            var chart = me.chart;\n            var context = me.ctx;\n            var globalDefaults = defaults.global;\n            var defaultFontColor = globalDefaults.defaultFontColor;\n            var optionTicks = options.ticks.minor;\n            var optionMajorTicks = options.ticks.major || optionTicks;\n            var gridLines = options.gridLines;\n            var scaleLabel = options.scaleLabel;\n            var position = options.position;\n            var isRotated = me.labelRotation !== 0;\n            var isMirrored = optionTicks.mirror;\n            var isHorizontal = me.isHorizontal();\n            var parseFont = helpers.options._parseFont;\n            var ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n            var tickFontColor = valueOrDefault(optionTicks.fontColor, defaultFontColor);\n            var tickFont = parseFont(optionTicks);\n            var lineHeight = tickFont.lineHeight;\n            var majorTickFontColor = valueOrDefault(optionMajorTicks.fontColor, defaultFontColor);\n            var majorTickFont = parseFont(optionMajorTicks);\n            var tickPadding = optionTicks.padding;\n            var labelOffset = optionTicks.labelOffset;\n            var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n            var scaleLabelFontColor = valueOrDefault(scaleLabel.fontColor, defaultFontColor);\n            var scaleLabelFont = parseFont(scaleLabel);\n            var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);\n            var labelRotationRadians = helpers.toRadians(me.labelRotation);\n            var itemsToDraw = [];\n            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\n            var alignPixel = helpers._alignPixel;\n            var borderValue, tickStart, tickEnd;\n            if (position === 'top') {\n                borderValue = alignPixel(chart, me.bottom, axisWidth);\n                tickStart = me.bottom - tl;\n                tickEnd = borderValue - axisWidth / 2;\n            } else if (position === 'bottom') {\n                borderValue = alignPixel(chart, me.top, axisWidth);\n                tickStart = borderValue + axisWidth / 2;\n                tickEnd = me.top + tl;\n            } else if (position === 'left') {\n                borderValue = alignPixel(chart, me.right, axisWidth);\n                tickStart = me.right - tl;\n                tickEnd = borderValue - axisWidth / 2;\n            } else {\n                borderValue = alignPixel(chart, me.left, axisWidth);\n                tickStart = borderValue + axisWidth / 2;\n                tickEnd = me.left + tl;\n            }\n            var epsilon = 1e-7;\n            helpers.each(ticks, function (tick, index) {\n                if (helpers.isNullOrUndef(tick.label)) {\n                    return;\n                }\n                var label = tick.label;\n                var lineWidth, lineColor, borderDash, borderDashOffset;\n                if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n                    lineWidth = gridLines.zeroLineWidth;\n                    lineColor = gridLines.zeroLineColor;\n                    borderDash = gridLines.zeroLineBorderDash || [];\n                    borderDashOffset = gridLines.zeroLineBorderDashOffset || 0;\n                } else {\n                    lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);\n                    lineColor = valueAtIndexOrDefault(gridLines.color, index);\n                    borderDash = gridLines.borderDash || [];\n                    borderDashOffset = gridLines.borderDashOffset || 0;\n                }\n                var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;\n                var labelCount = helpers.isArray(label) ? label.length : 1;\n                var lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);\n                if (isHorizontal) {\n                    var labelYOffset = tl + tickPadding;\n                    if (lineValue < me.left - epsilon) {\n                        lineColor = 'rgba(0,0,0,0)';\n                    }\n                    tx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);\n                    ty1 = tickStart;\n                    ty2 = tickEnd;\n                    labelX = me.getPixelForTick(index) + labelOffset;\n                    if (position === 'top') {\n                        y1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;\n                        y2 = chartArea.bottom;\n                        textOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;\n                        textAlign = !isRotated ? 'center' : 'left';\n                        labelY = me.bottom - labelYOffset;\n                    } else {\n                        y1 = chartArea.top;\n                        y2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;\n                        textOffset = (!isRotated ? 0.5 : 0) * lineHeight;\n                        textAlign = !isRotated ? 'center' : 'right';\n                        labelY = me.top + labelYOffset;\n                    }\n                } else {\n                    var labelXOffset = (isMirrored ? 0 : tl) + tickPadding;\n                    if (lineValue < me.top - epsilon) {\n                        lineColor = 'rgba(0,0,0,0)';\n                    }\n                    tx1 = tickStart;\n                    tx2 = tickEnd;\n                    ty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);\n                    labelY = me.getPixelForTick(index) + labelOffset;\n                    textOffset = (1 - labelCount) * lineHeight / 2;\n                    if (position === 'left') {\n                        x1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;\n                        x2 = chartArea.right;\n                        textAlign = isMirrored ? 'left' : 'right';\n                        labelX = me.right - labelXOffset;\n                    } else {\n                        x1 = chartArea.left;\n                        x2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;\n                        textAlign = isMirrored ? 'right' : 'left';\n                        labelX = me.left + labelXOffset;\n                    }\n                }\n                itemsToDraw.push({\n                    tx1: tx1,\n                    ty1: ty1,\n                    tx2: tx2,\n                    ty2: ty2,\n                    x1: x1,\n                    y1: y1,\n                    x2: x2,\n                    y2: y2,\n                    labelX: labelX,\n                    labelY: labelY,\n                    glWidth: lineWidth,\n                    glColor: lineColor,\n                    glBorderDash: borderDash,\n                    glBorderDashOffset: borderDashOffset,\n                    rotation: -1 * labelRotationRadians,\n                    label: label,\n                    major: tick.major,\n                    textOffset: textOffset,\n                    textAlign: textAlign\n                });\n            });\n            helpers.each(itemsToDraw, function (itemToDraw) {\n                var glWidth = itemToDraw.glWidth;\n                var glColor = itemToDraw.glColor;\n                if (gridLines.display && glWidth && glColor) {\n                    context.save();\n                    context.lineWidth = glWidth;\n                    context.strokeStyle = glColor;\n                    if (context.setLineDash) {\n                        context.setLineDash(itemToDraw.glBorderDash);\n                        context.lineDashOffset = itemToDraw.glBorderDashOffset;\n                    }\n                    context.beginPath();\n                    if (gridLines.drawTicks) {\n                        context.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n                        context.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n                    }\n                    if (gridLines.drawOnChartArea) {\n                        context.moveTo(itemToDraw.x1, itemToDraw.y1);\n                        context.lineTo(itemToDraw.x2, itemToDraw.y2);\n                    }\n                    context.stroke();\n                    context.restore();\n                }\n                if (optionTicks.display) {\n                    context.save();\n                    context.translate(itemToDraw.labelX, itemToDraw.labelY);\n                    context.rotate(itemToDraw.rotation);\n                    context.font = itemToDraw.major ? majorTickFont.string : tickFont.string;\n                    context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n                    context.textBaseline = 'middle';\n                    context.textAlign = itemToDraw.textAlign;\n                    var label = itemToDraw.label;\n                    var y = itemToDraw.textOffset;\n                    if (helpers.isArray(label)) {\n                        for (var i = 0; i < label.length; ++i) {\n                            context.fillText('' + label[i], 0, y);\n                            y += lineHeight;\n                        }\n                    } else {\n                        context.fillText(label, 0, y);\n                    }\n                    context.restore();\n                }\n            });\n            if (scaleLabel.display) {\n                var scaleLabelX;\n                var scaleLabelY;\n                var rotation = 0;\n                var halfLineHeight = scaleLabelFont.lineHeight / 2;\n                if (isHorizontal) {\n                    scaleLabelX = me.left + (me.right - me.left) / 2;\n                    scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;\n                } else {\n                    var isLeft = position === 'left';\n                    scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;\n                    scaleLabelY = me.top + (me.bottom - me.top) / 2;\n                    rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n                }\n                context.save();\n                context.translate(scaleLabelX, scaleLabelY);\n                context.rotate(rotation);\n                context.textAlign = 'center';\n                context.textBaseline = 'middle';\n                context.fillStyle = scaleLabelFontColor;\n                context.font = scaleLabelFont.string;\n                context.fillText(scaleLabel.labelString, 0, 0);\n                context.restore();\n            }\n            if (axisWidth) {\n                var firstLineWidth = axisWidth;\n                var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);\n                var x1, x2, y1, y2;\n                if (isHorizontal) {\n                    x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;\n                    x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;\n                    y1 = y2 = borderValue;\n                } else {\n                    y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;\n                    y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\n                    x1 = x2 = borderValue;\n                }\n                context.lineWidth = axisWidth;\n                context.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);\n                context.beginPath();\n                context.moveTo(x1, y1);\n                context.lineTo(x2, y2);\n                context.stroke();\n            }\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/scales/scale.category',['../core/core.scale'], function (__module__0) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var Scale = __module__0;\n    var defaultConfig = { position: 'bottom' };\n    module.exports = Scale.extend({\n        getLabels: function () {\n            var data = this.chart.data;\n            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n        },\n        determineDataLimits: function () {\n            var me = this;\n            var labels = me.getLabels();\n            me.minIndex = 0;\n            me.maxIndex = labels.length - 1;\n            var findIndex;\n            if (me.options.ticks.min !== undefined) {\n                findIndex = labels.indexOf(me.options.ticks.min);\n                me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n            }\n            if (me.options.ticks.max !== undefined) {\n                findIndex = labels.indexOf(me.options.ticks.max);\n                me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n            }\n            me.min = labels[me.minIndex];\n            me.max = labels[me.maxIndex];\n        },\n        buildTicks: function () {\n            var me = this;\n            var labels = me.getLabels();\n            me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n        },\n        getLabelForIndex: function (index, datasetIndex) {\n            var me = this;\n            var chart = me.chart;\n            if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {\n                return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);\n            }\n            return me.ticks[index - me.minIndex];\n        },\n        getPixelForValue: function (value, index) {\n            var me = this;\n            var offset = me.options.offset;\n            var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1);\n            var valueCategory;\n            if (value !== undefined && value !== null) {\n                valueCategory = me.isHorizontal() ? value.x : value.y;\n            }\n            if (valueCategory !== undefined || value !== undefined && isNaN(index)) {\n                var labels = me.getLabels();\n                value = valueCategory || value;\n                var idx = labels.indexOf(value);\n                index = idx !== -1 ? idx : index;\n            }\n            if (me.isHorizontal()) {\n                var valueWidth = me.width / offsetAmt;\n                var widthOffset = valueWidth * (index - me.minIndex);\n                if (offset) {\n                    widthOffset += valueWidth / 2;\n                }\n                return me.left + widthOffset;\n            }\n            var valueHeight = me.height / offsetAmt;\n            var heightOffset = valueHeight * (index - me.minIndex);\n            if (offset) {\n                heightOffset += valueHeight / 2;\n            }\n            return me.top + heightOffset;\n        },\n        getPixelForTick: function (index) {\n            return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n        },\n        getValueForPixel: function (pixel) {\n            var me = this;\n            var offset = me.options.offset;\n            var value;\n            var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);\n            var horz = me.isHorizontal();\n            var valueDimension = (horz ? me.width : me.height) / offsetAmt;\n            pixel -= horz ? me.left : me.top;\n            if (offset) {\n                pixel -= valueDimension / 2;\n            }\n            if (pixel <= 0) {\n                value = 0;\n            } else {\n                value = Math.round(pixel / valueDimension);\n            }\n            return value + me.minIndex;\n        },\n        getBasePixel: function () {\n            return this.bottom;\n        }\n    });\n    module.exports._defaults = defaultConfig;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/scales/scale.linearbase',[\n    '../helpers/index',\n    '../core/core.scale'\n], function (__module__0, __module__1) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    var Scale = __module__1;\n    var noop = helpers.noop;\n    var isNullOrUndef = helpers.isNullOrUndef;\n    function generateTicks(generationOptions, dataRange) {\n        var ticks = [];\n        var MIN_SPACING = 1e-14;\n        var stepSize = generationOptions.stepSize;\n        var unit = stepSize || 1;\n        var maxNumSpaces = generationOptions.maxTicks - 1;\n        var min = generationOptions.min;\n        var max = generationOptions.max;\n        var precision = generationOptions.precision;\n        var rmin = dataRange.min;\n        var rmax = dataRange.max;\n        var spacing = helpers.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;\n        var factor, niceMin, niceMax, numSpaces;\n        if (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {\n            return [\n                rmin,\n                rmax\n            ];\n        }\n        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n        if (numSpaces > maxNumSpaces) {\n            spacing = helpers.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;\n        }\n        if (stepSize || isNullOrUndef(precision)) {\n            factor = Math.pow(10, helpers._decimalPlaces(spacing));\n        } else {\n            factor = Math.pow(10, precision);\n            spacing = Math.ceil(spacing * factor) / factor;\n        }\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n        if (stepSize) {\n            if (!isNullOrUndef(min) && helpers.almostWhole(min / spacing, spacing / 1000)) {\n                niceMin = min;\n            }\n            if (!isNullOrUndef(max) && helpers.almostWhole(max / spacing, spacing / 1000)) {\n                niceMax = max;\n            }\n        }\n        numSpaces = (niceMax - niceMin) / spacing;\n        if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n        niceMin = Math.round(niceMin * factor) / factor;\n        niceMax = Math.round(niceMax * factor) / factor;\n        ticks.push(isNullOrUndef(min) ? niceMin : min);\n        for (var j = 1; j < numSpaces; ++j) {\n            ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);\n        }\n        ticks.push(isNullOrUndef(max) ? niceMax : max);\n        return ticks;\n    }\n    module.exports = Scale.extend({\n        getRightValue: function (value) {\n            if (typeof value === 'string') {\n                return +value;\n            }\n            return Scale.prototype.getRightValue.call(this, value);\n        },\n        handleTickRangeOptions: function () {\n            var me = this;\n            var opts = me.options;\n            var tickOpts = opts.ticks;\n            if (tickOpts.beginAtZero) {\n                var minSign = helpers.sign(me.min);\n                var maxSign = helpers.sign(me.max);\n                if (minSign < 0 && maxSign < 0) {\n                    me.max = 0;\n                } else if (minSign > 0 && maxSign > 0) {\n                    me.min = 0;\n                }\n            }\n            var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n            var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n            if (tickOpts.min !== undefined) {\n                me.min = tickOpts.min;\n            } else if (tickOpts.suggestedMin !== undefined) {\n                if (me.min === null) {\n                    me.min = tickOpts.suggestedMin;\n                } else {\n                    me.min = Math.min(me.min, tickOpts.suggestedMin);\n                }\n            }\n            if (tickOpts.max !== undefined) {\n                me.max = tickOpts.max;\n            } else if (tickOpts.suggestedMax !== undefined) {\n                if (me.max === null) {\n                    me.max = tickOpts.suggestedMax;\n                } else {\n                    me.max = Math.max(me.max, tickOpts.suggestedMax);\n                }\n            }\n            if (setMin !== setMax) {\n                if (me.min >= me.max) {\n                    if (setMin) {\n                        me.max = me.min + 1;\n                    } else {\n                        me.min = me.max - 1;\n                    }\n                }\n            }\n            if (me.min === me.max) {\n                me.max++;\n                if (!tickOpts.beginAtZero) {\n                    me.min--;\n                }\n            }\n        },\n        getTickLimit: function () {\n            var me = this;\n            var tickOpts = me.options.ticks;\n            var stepSize = tickOpts.stepSize;\n            var maxTicksLimit = tickOpts.maxTicksLimit;\n            var maxTicks;\n            if (stepSize) {\n                maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\n            } else {\n                maxTicks = me._computeTickLimit();\n                maxTicksLimit = maxTicksLimit || 11;\n            }\n            if (maxTicksLimit) {\n                maxTicks = Math.min(maxTicksLimit, maxTicks);\n            }\n            return maxTicks;\n        },\n        _computeTickLimit: function () {\n            return Number.POSITIVE_INFINITY;\n        },\n        handleDirectionalChanges: noop,\n        buildTicks: function () {\n            var me = this;\n            var opts = me.options;\n            var tickOpts = opts.ticks;\n            var maxTicks = me.getTickLimit();\n            maxTicks = Math.max(2, maxTicks);\n            var numericGeneratorOptions = {\n                maxTicks: maxTicks,\n                min: tickOpts.min,\n                max: tickOpts.max,\n                precision: tickOpts.precision,\n                stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n            };\n            var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n            me.handleDirectionalChanges();\n            me.max = helpers.max(ticks);\n            me.min = helpers.min(ticks);\n            if (tickOpts.reverse) {\n                ticks.reverse();\n                me.start = me.max;\n                me.end = me.min;\n            } else {\n                me.start = me.min;\n                me.end = me.max;\n            }\n        },\n        convertTicksToLabels: function () {\n            var me = this;\n            me.ticksAsNumbers = me.ticks.slice();\n            me.zeroLineIndex = me.ticks.indexOf(0);\n            Scale.prototype.convertTicksToLabels.call(me);\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/scales/scale.linear',[\n    '../helpers/index',\n    './scale.linearbase',\n    '../core/core.ticks'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    var LinearScaleBase = __module__1;\n    var Ticks = __module__2;\n    var defaultConfig = {\n        position: 'left',\n        ticks: { callback: Ticks.formatters.linear }\n    };\n    module.exports = LinearScaleBase.extend({\n        determineDataLimits: function () {\n            var me = this;\n            var opts = me.options;\n            var chart = me.chart;\n            var data = chart.data;\n            var datasets = data.datasets;\n            var isHorizontal = me.isHorizontal();\n            var DEFAULT_MIN = 0;\n            var DEFAULT_MAX = 1;\n            function IDMatches(meta) {\n                return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n            }\n            me.min = null;\n            me.max = null;\n            var hasStacks = opts.stacked;\n            if (hasStacks === undefined) {\n                helpers.each(datasets, function (dataset, datasetIndex) {\n                    if (hasStacks) {\n                        return;\n                    }\n                    var meta = chart.getDatasetMeta(datasetIndex);\n                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n                        hasStacks = true;\n                    }\n                });\n            }\n            if (opts.stacked || hasStacks) {\n                var valuesPerStack = {};\n                helpers.each(datasets, function (dataset, datasetIndex) {\n                    var meta = chart.getDatasetMeta(datasetIndex);\n                    var key = [\n                        meta.type,\n                        opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '',\n                        meta.stack\n                    ].join('.');\n                    if (valuesPerStack[key] === undefined) {\n                        valuesPerStack[key] = {\n                            positiveValues: [],\n                            negativeValues: []\n                        };\n                    }\n                    var positiveValues = valuesPerStack[key].positiveValues;\n                    var negativeValues = valuesPerStack[key].negativeValues;\n                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n                        helpers.each(dataset.data, function (rawValue, index) {\n                            var value = +me.getRightValue(rawValue);\n                            if (isNaN(value) || meta.data[index].hidden) {\n                                return;\n                            }\n                            positiveValues[index] = positiveValues[index] || 0;\n                            negativeValues[index] = negativeValues[index] || 0;\n                            if (opts.relativePoints) {\n                                positiveValues[index] = 100;\n                            } else if (value < 0) {\n                                negativeValues[index] += value;\n                            } else {\n                                positiveValues[index] += value;\n                            }\n                        });\n                    }\n                });\n                helpers.each(valuesPerStack, function (valuesForType) {\n                    var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n                    var minVal = helpers.min(values);\n                    var maxVal = helpers.max(values);\n                    me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n                    me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n                });\n            } else {\n                helpers.each(datasets, function (dataset, datasetIndex) {\n                    var meta = chart.getDatasetMeta(datasetIndex);\n                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n                        helpers.each(dataset.data, function (rawValue, index) {\n                            var value = +me.getRightValue(rawValue);\n                            if (isNaN(value) || meta.data[index].hidden) {\n                                return;\n                            }\n                            if (me.min === null) {\n                                me.min = value;\n                            } else if (value < me.min) {\n                                me.min = value;\n                            }\n                            if (me.max === null) {\n                                me.max = value;\n                            } else if (value > me.max) {\n                                me.max = value;\n                            }\n                        });\n                    }\n                });\n            }\n            me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n            me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\n            this.handleTickRangeOptions();\n        },\n        _computeTickLimit: function () {\n            var me = this;\n            var tickFont;\n            if (me.isHorizontal()) {\n                return Math.ceil(me.width / 40);\n            }\n            tickFont = helpers.options._parseFont(me.options.ticks);\n            return Math.ceil(me.height / tickFont.lineHeight);\n        },\n        handleDirectionalChanges: function () {\n            if (!this.isHorizontal()) {\n                this.ticks.reverse();\n            }\n        },\n        getLabelForIndex: function (index, datasetIndex) {\n            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n        },\n        getPixelForValue: function (value) {\n            var me = this;\n            var start = me.start;\n            var rightValue = +me.getRightValue(value);\n            var pixel;\n            var range = me.end - start;\n            if (me.isHorizontal()) {\n                pixel = me.left + me.width / range * (rightValue - start);\n            } else {\n                pixel = me.bottom - me.height / range * (rightValue - start);\n            }\n            return pixel;\n        },\n        getValueForPixel: function (pixel) {\n            var me = this;\n            var isHorizontal = me.isHorizontal();\n            var innerDimension = isHorizontal ? me.width : me.height;\n            var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n            return me.start + (me.end - me.start) * offset;\n        },\n        getPixelForTick: function (index) {\n            return this.getPixelForValue(this.ticksAsNumbers[index]);\n        }\n    });\n    module.exports._defaults = defaultConfig;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/scales/scale.logarithmic',[\n    '../core/core.defaults',\n    '../helpers/index',\n    '../core/core.scale',\n    '../core/core.ticks'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var helpers = __module__1;\n    var Scale = __module__2;\n    var Ticks = __module__3;\n    var valueOrDefault = helpers.valueOrDefault;\n    function generateTicks(generationOptions, dataRange) {\n        var ticks = [];\n        var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n        var endExp = Math.floor(helpers.log10(dataRange.max));\n        var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n        var exp, significand;\n        if (tickVal === 0) {\n            exp = Math.floor(helpers.log10(dataRange.minNotZero));\n            significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n            ticks.push(tickVal);\n            tickVal = significand * Math.pow(10, exp);\n        } else {\n            exp = Math.floor(helpers.log10(tickVal));\n            significand = Math.floor(tickVal / Math.pow(10, exp));\n        }\n        var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n        do {\n            ticks.push(tickVal);\n            ++significand;\n            if (significand === 10) {\n                significand = 1;\n                ++exp;\n                precision = exp >= 0 ? 1 : precision;\n            }\n            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n        } while (exp < endExp || exp === endExp && significand < endSignificand);\n        var lastTick = valueOrDefault(generationOptions.max, tickVal);\n        ticks.push(lastTick);\n        return ticks;\n    }\n    var defaultConfig = {\n        position: 'left',\n        ticks: { callback: Ticks.formatters.logarithmic }\n    };\n    function nonNegativeOrDefault(value, defaultValue) {\n        return helpers.isFinite(value) && value >= 0 ? value : defaultValue;\n    }\n    module.exports = Scale.extend({\n        determineDataLimits: function () {\n            var me = this;\n            var opts = me.options;\n            var chart = me.chart;\n            var data = chart.data;\n            var datasets = data.datasets;\n            var isHorizontal = me.isHorizontal();\n            function IDMatches(meta) {\n                return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n            }\n            me.min = null;\n            me.max = null;\n            me.minNotZero = null;\n            var hasStacks = opts.stacked;\n            if (hasStacks === undefined) {\n                helpers.each(datasets, function (dataset, datasetIndex) {\n                    if (hasStacks) {\n                        return;\n                    }\n                    var meta = chart.getDatasetMeta(datasetIndex);\n                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n                        hasStacks = true;\n                    }\n                });\n            }\n            if (opts.stacked || hasStacks) {\n                var valuesPerStack = {};\n                helpers.each(datasets, function (dataset, datasetIndex) {\n                    var meta = chart.getDatasetMeta(datasetIndex);\n                    var key = [\n                        meta.type,\n                        opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '',\n                        meta.stack\n                    ].join('.');\n                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n                        if (valuesPerStack[key] === undefined) {\n                            valuesPerStack[key] = [];\n                        }\n                        helpers.each(dataset.data, function (rawValue, index) {\n                            var values = valuesPerStack[key];\n                            var value = +me.getRightValue(rawValue);\n                            if (isNaN(value) || meta.data[index].hidden || value < 0) {\n                                return;\n                            }\n                            values[index] = values[index] || 0;\n                            values[index] += value;\n                        });\n                    }\n                });\n                helpers.each(valuesPerStack, function (valuesForType) {\n                    if (valuesForType.length > 0) {\n                        var minVal = helpers.min(valuesForType);\n                        var maxVal = helpers.max(valuesForType);\n                        me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n                        me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n                    }\n                });\n            } else {\n                helpers.each(datasets, function (dataset, datasetIndex) {\n                    var meta = chart.getDatasetMeta(datasetIndex);\n                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n                        helpers.each(dataset.data, function (rawValue, index) {\n                            var value = +me.getRightValue(rawValue);\n                            if (isNaN(value) || meta.data[index].hidden || value < 0) {\n                                return;\n                            }\n                            if (me.min === null) {\n                                me.min = value;\n                            } else if (value < me.min) {\n                                me.min = value;\n                            }\n                            if (me.max === null) {\n                                me.max = value;\n                            } else if (value > me.max) {\n                                me.max = value;\n                            }\n                            if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n                                me.minNotZero = value;\n                            }\n                        });\n                    }\n                });\n            }\n            this.handleTickRangeOptions();\n        },\n        handleTickRangeOptions: function () {\n            var me = this;\n            var tickOpts = me.options.ticks;\n            var DEFAULT_MIN = 1;\n            var DEFAULT_MAX = 10;\n            me.min = nonNegativeOrDefault(tickOpts.min, me.min);\n            me.max = nonNegativeOrDefault(tickOpts.max, me.max);\n            if (me.min === me.max) {\n                if (me.min !== 0 && me.min !== null) {\n                    me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n                    me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n                } else {\n                    me.min = DEFAULT_MIN;\n                    me.max = DEFAULT_MAX;\n                }\n            }\n            if (me.min === null) {\n                me.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);\n            }\n            if (me.max === null) {\n                me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1) : DEFAULT_MAX;\n            }\n            if (me.minNotZero === null) {\n                if (me.min > 0) {\n                    me.minNotZero = me.min;\n                } else if (me.max < 1) {\n                    me.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));\n                } else {\n                    me.minNotZero = DEFAULT_MIN;\n                }\n            }\n        },\n        buildTicks: function () {\n            var me = this;\n            var tickOpts = me.options.ticks;\n            var reverse = !me.isHorizontal();\n            var generationOptions = {\n                min: nonNegativeOrDefault(tickOpts.min),\n                max: nonNegativeOrDefault(tickOpts.max)\n            };\n            var ticks = me.ticks = generateTicks(generationOptions, me);\n            me.max = helpers.max(ticks);\n            me.min = helpers.min(ticks);\n            if (tickOpts.reverse) {\n                reverse = !reverse;\n                me.start = me.max;\n                me.end = me.min;\n            } else {\n                me.start = me.min;\n                me.end = me.max;\n            }\n            if (reverse) {\n                ticks.reverse();\n            }\n        },\n        convertTicksToLabels: function () {\n            this.tickValues = this.ticks.slice();\n            Scale.prototype.convertTicksToLabels.call(this);\n        },\n        getLabelForIndex: function (index, datasetIndex) {\n            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n        },\n        getPixelForTick: function (index) {\n            return this.getPixelForValue(this.tickValues[index]);\n        },\n        _getFirstTickValue: function (value) {\n            var exp = Math.floor(helpers.log10(value));\n            var significand = Math.floor(value / Math.pow(10, exp));\n            return significand * Math.pow(10, exp);\n        },\n        getPixelForValue: function (value) {\n            var me = this;\n            var tickOpts = me.options.ticks;\n            var reverse = tickOpts.reverse;\n            var log10 = helpers.log10;\n            var firstTickValue = me._getFirstTickValue(me.minNotZero);\n            var offset = 0;\n            var innerDimension, pixel, start, end, sign;\n            value = +me.getRightValue(value);\n            if (reverse) {\n                start = me.end;\n                end = me.start;\n                sign = -1;\n            } else {\n                start = me.start;\n                end = me.end;\n                sign = 1;\n            }\n            if (me.isHorizontal()) {\n                innerDimension = me.width;\n                pixel = reverse ? me.right : me.left;\n            } else {\n                innerDimension = me.height;\n                sign *= -1;\n                pixel = reverse ? me.top : me.bottom;\n            }\n            if (value !== start) {\n                if (start === 0) {\n                    offset = valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);\n                    innerDimension -= offset;\n                    start = firstTickValue;\n                }\n                if (value !== 0) {\n                    offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));\n                }\n                pixel += sign * offset;\n            }\n            return pixel;\n        },\n        getValueForPixel: function (pixel) {\n            var me = this;\n            var tickOpts = me.options.ticks;\n            var reverse = tickOpts.reverse;\n            var log10 = helpers.log10;\n            var firstTickValue = me._getFirstTickValue(me.minNotZero);\n            var innerDimension, start, end, value;\n            if (reverse) {\n                start = me.end;\n                end = me.start;\n            } else {\n                start = me.start;\n                end = me.end;\n            }\n            if (me.isHorizontal()) {\n                innerDimension = me.width;\n                value = reverse ? me.right - pixel : pixel - me.left;\n            } else {\n                innerDimension = me.height;\n                value = reverse ? pixel - me.top : me.bottom - pixel;\n            }\n            if (value !== start) {\n                if (start === 0) {\n                    var offset = valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);\n                    value -= offset;\n                    innerDimension -= offset;\n                    start = firstTickValue;\n                }\n                value *= log10(end) - log10(start);\n                value /= innerDimension;\n                value = Math.pow(10, log10(start) + value);\n            }\n            return value;\n        }\n    });\n    module.exports._defaults = defaultConfig;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/scales/scale.radialLinear',[\n    '../core/core.defaults',\n    '../helpers/index',\n    './scale.linearbase',\n    '../core/core.ticks'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var helpers = __module__1;\n    var LinearScaleBase = __module__2;\n    var Ticks = __module__3;\n    var valueOrDefault = helpers.valueOrDefault;\n    var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n    var resolve = helpers.options.resolve;\n    var defaultConfig = {\n        display: true,\n        animate: true,\n        position: 'chartArea',\n        angleLines: {\n            display: true,\n            color: 'rgba(0, 0, 0, 0.1)',\n            lineWidth: 1,\n            borderDash: [],\n            borderDashOffset: 0\n        },\n        gridLines: { circular: false },\n        ticks: {\n            showLabelBackdrop: true,\n            backdropColor: 'rgba(255,255,255,0.75)',\n            backdropPaddingY: 2,\n            backdropPaddingX: 2,\n            callback: Ticks.formatters.linear\n        },\n        pointLabels: {\n            display: true,\n            fontSize: 10,\n            callback: function (label) {\n                return label;\n            }\n        }\n    };\n    function getValueCount(scale) {\n        var opts = scale.options;\n        return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n    }\n    function getTickBackdropHeight(opts) {\n        var tickOpts = opts.ticks;\n        if (tickOpts.display && opts.display) {\n            return valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;\n        }\n        return 0;\n    }\n    function measureLabelSize(ctx, lineHeight, label) {\n        if (helpers.isArray(label)) {\n            return {\n                w: helpers.longestText(ctx, ctx.font, label),\n                h: label.length * lineHeight\n            };\n        }\n        return {\n            w: ctx.measureText(label).width,\n            h: lineHeight\n        };\n    }\n    function determineLimits(angle, pos, size, min, max) {\n        if (angle === min || angle === max) {\n            return {\n                start: pos - size / 2,\n                end: pos + size / 2\n            };\n        } else if (angle < min || angle > max) {\n            return {\n                start: pos - size,\n                end: pos\n            };\n        }\n        return {\n            start: pos,\n            end: pos + size\n        };\n    }\n    function fitWithPointLabels(scale) {\n        var plFont = helpers.options._parseFont(scale.options.pointLabels);\n        var furthestLimits = {\n            l: 0,\n            r: scale.width,\n            t: 0,\n            b: scale.height - scale.paddingTop\n        };\n        var furthestAngles = {};\n        var i, textSize, pointPosition;\n        scale.ctx.font = plFont.string;\n        scale._pointLabelSizes = [];\n        var valueCount = getValueCount(scale);\n        for (i = 0; i < valueCount; i++) {\n            pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\n            textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');\n            scale._pointLabelSizes[i] = textSize;\n            var angleRadians = scale.getIndexAngle(i);\n            var angle = helpers.toDegrees(angleRadians) % 360;\n            var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n            var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n            if (hLimits.start < furthestLimits.l) {\n                furthestLimits.l = hLimits.start;\n                furthestAngles.l = angleRadians;\n            }\n            if (hLimits.end > furthestLimits.r) {\n                furthestLimits.r = hLimits.end;\n                furthestAngles.r = angleRadians;\n            }\n            if (vLimits.start < furthestLimits.t) {\n                furthestLimits.t = vLimits.start;\n                furthestAngles.t = angleRadians;\n            }\n            if (vLimits.end > furthestLimits.b) {\n                furthestLimits.b = vLimits.end;\n                furthestAngles.b = angleRadians;\n            }\n        }\n        scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);\n    }\n    function getTextAlignForAngle(angle) {\n        if (angle === 0 || angle === 180) {\n            return 'center';\n        } else if (angle < 180) {\n            return 'left';\n        }\n        return 'right';\n    }\n    function fillText(ctx, text, position, lineHeight) {\n        var y = position.y + lineHeight / 2;\n        var i, ilen;\n        if (helpers.isArray(text)) {\n            for (i = 0, ilen = text.length; i < ilen; ++i) {\n                ctx.fillText(text[i], position.x, y);\n                y += lineHeight;\n            }\n        } else {\n            ctx.fillText(text, position.x, y);\n        }\n    }\n    function adjustPointPositionForLabelHeight(angle, textSize, position) {\n        if (angle === 90 || angle === 270) {\n            position.y -= textSize.h / 2;\n        } else if (angle > 270 || angle < 90) {\n            position.y -= textSize.h;\n        }\n    }\n    function drawPointLabels(scale) {\n        var ctx = scale.ctx;\n        var opts = scale.options;\n        var angleLineOpts = opts.angleLines;\n        var gridLineOpts = opts.gridLines;\n        var pointLabelOpts = opts.pointLabels;\n        var lineWidth = valueOrDefault(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\n        var lineColor = valueOrDefault(angleLineOpts.color, gridLineOpts.color);\n        var tickBackdropHeight = getTickBackdropHeight(opts);\n        ctx.save();\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = lineColor;\n        if (ctx.setLineDash) {\n            ctx.setLineDash(resolve([\n                angleLineOpts.borderDash,\n                gridLineOpts.borderDash,\n                []\n            ]));\n            ctx.lineDashOffset = resolve([\n                angleLineOpts.borderDashOffset,\n                gridLineOpts.borderDashOffset,\n                0\n            ]);\n        }\n        var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n        var plFont = helpers.options._parseFont(pointLabelOpts);\n        ctx.font = plFont.string;\n        ctx.textBaseline = 'middle';\n        for (var i = getValueCount(scale) - 1; i >= 0; i--) {\n            if (angleLineOpts.display && lineWidth && lineColor) {\n                var outerPosition = scale.getPointPosition(i, outerDistance);\n                ctx.beginPath();\n                ctx.moveTo(scale.xCenter, scale.yCenter);\n                ctx.lineTo(outerPosition.x, outerPosition.y);\n                ctx.stroke();\n            }\n            if (pointLabelOpts.display) {\n                var extra = i === 0 ? tickBackdropHeight / 2 : 0;\n                var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);\n                var pointLabelFontColor = valueAtIndexOrDefault(pointLabelOpts.fontColor, i, defaults.global.defaultFontColor);\n                ctx.fillStyle = pointLabelFontColor;\n                var angleRadians = scale.getIndexAngle(i);\n                var angle = helpers.toDegrees(angleRadians);\n                ctx.textAlign = getTextAlignForAngle(angle);\n                adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n                fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);\n            }\n        }\n        ctx.restore();\n    }\n    function drawRadiusLine(scale, gridLineOpts, radius, index) {\n        var ctx = scale.ctx;\n        var circular = gridLineOpts.circular;\n        var valueCount = getValueCount(scale);\n        var lineColor = valueAtIndexOrDefault(gridLineOpts.color, index - 1);\n        var lineWidth = valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n        var pointPosition;\n        if (!circular && !valueCount || !lineColor || !lineWidth) {\n            return;\n        }\n        ctx.save();\n        ctx.strokeStyle = lineColor;\n        ctx.lineWidth = lineWidth;\n        if (ctx.setLineDash) {\n            ctx.setLineDash(gridLineOpts.borderDash || []);\n            ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0;\n        }\n        ctx.beginPath();\n        if (circular) {\n            ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n        } else {\n            pointPosition = scale.getPointPosition(0, radius);\n            ctx.moveTo(pointPosition.x, pointPosition.y);\n            for (var i = 1; i < valueCount; i++) {\n                pointPosition = scale.getPointPosition(i, radius);\n                ctx.lineTo(pointPosition.x, pointPosition.y);\n            }\n        }\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n    function numberOrZero(param) {\n        return helpers.isNumber(param) ? param : 0;\n    }\n    module.exports = LinearScaleBase.extend({\n        setDimensions: function () {\n            var me = this;\n            me.width = me.maxWidth;\n            me.height = me.maxHeight;\n            me.paddingTop = getTickBackdropHeight(me.options) / 2;\n            me.xCenter = Math.floor(me.width / 2);\n            me.yCenter = Math.floor((me.height - me.paddingTop) / 2);\n            me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\n        },\n        determineDataLimits: function () {\n            var me = this;\n            var chart = me.chart;\n            var min = Number.POSITIVE_INFINITY;\n            var max = Number.NEGATIVE_INFINITY;\n            helpers.each(chart.data.datasets, function (dataset, datasetIndex) {\n                if (chart.isDatasetVisible(datasetIndex)) {\n                    var meta = chart.getDatasetMeta(datasetIndex);\n                    helpers.each(dataset.data, function (rawValue, index) {\n                        var value = +me.getRightValue(rawValue);\n                        if (isNaN(value) || meta.data[index].hidden) {\n                            return;\n                        }\n                        min = Math.min(value, min);\n                        max = Math.max(value, max);\n                    });\n                }\n            });\n            me.min = min === Number.POSITIVE_INFINITY ? 0 : min;\n            me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;\n            me.handleTickRangeOptions();\n        },\n        _computeTickLimit: function () {\n            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n        },\n        convertTicksToLabels: function () {\n            var me = this;\n            LinearScaleBase.prototype.convertTicksToLabels.call(me);\n            me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n        },\n        getLabelForIndex: function (index, datasetIndex) {\n            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n        },\n        fit: function () {\n            var me = this;\n            var opts = me.options;\n            if (opts.display && opts.pointLabels.display) {\n                fitWithPointLabels(me);\n            } else {\n                me.setCenterPoint(0, 0, 0, 0);\n            }\n        },\n        setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {\n            var me = this;\n            var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n            var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n            var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n            var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\n            radiusReductionLeft = numberOrZero(radiusReductionLeft);\n            radiusReductionRight = numberOrZero(radiusReductionRight);\n            radiusReductionTop = numberOrZero(radiusReductionTop);\n            radiusReductionBottom = numberOrZero(radiusReductionBottom);\n            me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n            me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n        },\n        setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {\n            var me = this;\n            var maxRight = me.width - rightMovement - me.drawingArea;\n            var maxLeft = leftMovement + me.drawingArea;\n            var maxTop = topMovement + me.drawingArea;\n            var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;\n            me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);\n            me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);\n        },\n        getIndexAngle: function (index) {\n            var angleMultiplier = Math.PI * 2 / getValueCount(this);\n            var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;\n            var startAngleRadians = startAngle * Math.PI * 2 / 360;\n            return index * angleMultiplier + startAngleRadians;\n        },\n        getDistanceFromCenterForValue: function (value) {\n            var me = this;\n            if (value === null) {\n                return 0;\n            }\n            var scalingFactor = me.drawingArea / (me.max - me.min);\n            if (me.options.ticks.reverse) {\n                return (me.max - value) * scalingFactor;\n            }\n            return (value - me.min) * scalingFactor;\n        },\n        getPointPosition: function (index, distanceFromCenter) {\n            var me = this;\n            var thisAngle = me.getIndexAngle(index) - Math.PI / 2;\n            return {\n                x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,\n                y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter\n            };\n        },\n        getPointPositionForValue: function (index, value) {\n            return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n        },\n        getBasePosition: function () {\n            var me = this;\n            var min = me.min;\n            var max = me.max;\n            return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);\n        },\n        draw: function () {\n            var me = this;\n            var opts = me.options;\n            var gridLineOpts = opts.gridLines;\n            var tickOpts = opts.ticks;\n            if (opts.display) {\n                var ctx = me.ctx;\n                var startAngle = this.getIndexAngle(0);\n                var tickFont = helpers.options._parseFont(tickOpts);\n                if (opts.angleLines.display || opts.pointLabels.display) {\n                    drawPointLabels(me);\n                }\n                helpers.each(me.ticks, function (label, index) {\n                    if (index > 0 || tickOpts.reverse) {\n                        var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n                        if (gridLineOpts.display && index !== 0) {\n                            drawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n                        }\n                        if (tickOpts.display) {\n                            var tickFontColor = valueOrDefault(tickOpts.fontColor, defaults.global.defaultFontColor);\n                            ctx.font = tickFont.string;\n                            ctx.save();\n                            ctx.translate(me.xCenter, me.yCenter);\n                            ctx.rotate(startAngle);\n                            if (tickOpts.showLabelBackdrop) {\n                                var labelWidth = ctx.measureText(label).width;\n                                ctx.fillStyle = tickOpts.backdropColor;\n                                ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);\n                            }\n                            ctx.textAlign = 'center';\n                            ctx.textBaseline = 'middle';\n                            ctx.fillStyle = tickFontColor;\n                            ctx.fillText(label, 0, -yCenterOffset);\n                            ctx.restore();\n                        }\n                    }\n                });\n            }\n        }\n    });\n    module.exports._defaults = defaultConfig;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/scales/scale.time',[\n    '../core/core.adapters',\n    '../core/core.defaults',\n    '../helpers/index',\n    '../core/core.scale'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var adapters = __module__0;\n    var defaults = __module__1;\n    var helpers = __module__2;\n    var Scale = __module__3;\n    var valueOrDefault = helpers.valueOrDefault;\n    var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\n    var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n    var INTERVALS = {\n        millisecond: {\n            common: true,\n            size: 1,\n            steps: [\n                1,\n                2,\n                5,\n                10,\n                20,\n                50,\n                100,\n                250,\n                500\n            ]\n        },\n        second: {\n            common: true,\n            size: 1000,\n            steps: [\n                1,\n                2,\n                5,\n                10,\n                15,\n                30\n            ]\n        },\n        minute: {\n            common: true,\n            size: 60000,\n            steps: [\n                1,\n                2,\n                5,\n                10,\n                15,\n                30\n            ]\n        },\n        hour: {\n            common: true,\n            size: 3600000,\n            steps: [\n                1,\n                2,\n                3,\n                6,\n                12\n            ]\n        },\n        day: {\n            common: true,\n            size: 86400000,\n            steps: [\n                1,\n                2,\n                5\n            ]\n        },\n        week: {\n            common: false,\n            size: 604800000,\n            steps: [\n                1,\n                2,\n                3,\n                4\n            ]\n        },\n        month: {\n            common: true,\n            size: 2628000000,\n            steps: [\n                1,\n                2,\n                3\n            ]\n        },\n        quarter: {\n            common: false,\n            size: 7884000000,\n            steps: [\n                1,\n                2,\n                3,\n                4\n            ]\n        },\n        year: {\n            common: true,\n            size: 31540000000\n        }\n    };\n    var UNITS = Object.keys(INTERVALS);\n    function sorter(a, b) {\n        return a - b;\n    }\n    function arrayUnique(items) {\n        var hash = {};\n        var out = [];\n        var i, ilen, item;\n        for (i = 0, ilen = items.length; i < ilen; ++i) {\n            item = items[i];\n            if (!hash[item]) {\n                hash[item] = true;\n                out.push(item);\n            }\n        }\n        return out;\n    }\n    function buildLookupTable(timestamps, min, max, distribution) {\n        if (distribution === 'linear' || !timestamps.length) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        var table = [];\n        var items = [min];\n        var i, ilen, prev, curr, next;\n        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n            curr = timestamps[i];\n            if (curr > min && curr < max) {\n                items.push(curr);\n            }\n        }\n        items.push(max);\n        for (i = 0, ilen = items.length; i < ilen; ++i) {\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n    function lookup(table, key, value) {\n        var lo = 0;\n        var hi = table.length - 1;\n        var mid, i0, i1;\n        while (lo >= 0 && lo <= hi) {\n            mid = lo + hi >> 1;\n            i0 = table[mid - 1] || null;\n            i1 = table[mid];\n            if (!i0) {\n                return {\n                    lo: null,\n                    hi: i1\n                };\n            } else if (i1[key] < value) {\n                lo = mid + 1;\n            } else if (i0[key] > value) {\n                hi = mid - 1;\n            } else {\n                return {\n                    lo: i0,\n                    hi: i1\n                };\n            }\n        }\n        return {\n            lo: i1,\n            hi: null\n        };\n    }\n    function interpolate(table, skey, sval, tkey) {\n        var range = lookup(table, skey, sval);\n        var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n        var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n        var span = next[skey] - prev[skey];\n        var ratio = span ? (sval - prev[skey]) / span : 0;\n        var offset = (next[tkey] - prev[tkey]) * ratio;\n        return prev[tkey] + offset;\n    }\n    function toTimestamp(scale, input) {\n        var adapter = scale._adapter;\n        var options = scale.options.time;\n        var parser = options.parser;\n        var format = parser || options.format;\n        var value = input;\n        if (typeof parser === 'function') {\n            value = parser(value);\n        }\n        if (!helpers.isFinite(value)) {\n            value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);\n        }\n        if (value !== null) {\n            return +value;\n        }\n        if (!parser && typeof format === 'function') {\n            value = format(input);\n            if (!helpers.isFinite(value)) {\n                value = adapter.parse(value);\n            }\n        }\n        return value;\n    }\n    function parse(scale, input) {\n        if (helpers.isNullOrUndef(input)) {\n            return null;\n        }\n        var options = scale.options.time;\n        var value = toTimestamp(scale, scale.getRightValue(input));\n        if (value === null) {\n            return value;\n        }\n        if (options.round) {\n            value = +scale._adapter.startOf(value, options.round);\n        }\n        return value;\n    }\n    function determineStepSize(min, max, unit, capacity) {\n        var range = max - min;\n        var interval = INTERVALS[unit];\n        var milliseconds = interval.size;\n        var steps = interval.steps;\n        var i, ilen, factor;\n        if (!steps) {\n            return Math.ceil(range / (capacity * milliseconds));\n        }\n        for (i = 0, ilen = steps.length; i < ilen; ++i) {\n            factor = steps[i];\n            if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n                break;\n            }\n        }\n        return factor;\n    }\n    function determineUnitForAutoTicks(minUnit, min, max, capacity) {\n        var ilen = UNITS.length;\n        var i, interval, factor;\n        for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n            interval = INTERVALS[UNITS[i]];\n            factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;\n            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n                return UNITS[i];\n            }\n        }\n        return UNITS[ilen - 1];\n    }\n    function determineUnitForFormatting(scale, ticks, minUnit, min, max) {\n        var ilen = UNITS.length;\n        var i, unit;\n        for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {\n            unit = UNITS[i];\n            if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {\n                return unit;\n            }\n        }\n        return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n    }\n    function determineMajorUnit(unit) {\n        for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n            if (INTERVALS[UNITS[i]].common) {\n                return UNITS[i];\n            }\n        }\n    }\n    function generate(scale, min, max, capacity) {\n        var adapter = scale._adapter;\n        var options = scale.options;\n        var timeOpts = options.time;\n        var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n        var major = determineMajorUnit(minor);\n        var stepSize = valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\n        var weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n        var majorTicksEnabled = options.ticks.major.enabled;\n        var interval = INTERVALS[minor];\n        var first = min;\n        var last = max;\n        var ticks = [];\n        var time;\n        if (!stepSize) {\n            stepSize = determineStepSize(min, max, minor, capacity);\n        }\n        if (weekday) {\n            first = +adapter.startOf(first, 'isoWeek', weekday);\n            last = +adapter.startOf(last, 'isoWeek', weekday);\n        }\n        first = +adapter.startOf(first, weekday ? 'day' : minor);\n        last = +adapter.startOf(last, weekday ? 'day' : minor);\n        if (last < max) {\n            last = +adapter.add(last, 1, minor);\n        }\n        time = first;\n        if (majorTicksEnabled && major && !weekday && !timeOpts.round) {\n            time = +adapter.startOf(time, major);\n            time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n        }\n        for (; time < last; time = +adapter.add(time, stepSize, minor)) {\n            ticks.push(+time);\n        }\n        ticks.push(+time);\n        return ticks;\n    }\n    function computeOffsets(table, ticks, min, max, options) {\n        var start = 0;\n        var end = 0;\n        var first, last;\n        if (options.offset && ticks.length) {\n            if (!options.time.min) {\n                first = interpolate(table, 'time', ticks[0], 'pos');\n                if (ticks.length === 1) {\n                    start = 1 - first;\n                } else {\n                    start = (interpolate(table, 'time', ticks[1], 'pos') - first) / 2;\n                }\n            }\n            if (!options.time.max) {\n                last = interpolate(table, 'time', ticks[ticks.length - 1], 'pos');\n                if (ticks.length === 1) {\n                    end = last;\n                } else {\n                    end = (last - interpolate(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;\n                }\n            }\n        }\n        return {\n            start: start,\n            end: end\n        };\n    }\n    function ticksFromTimestamps(scale, values, majorUnit) {\n        var ticks = [];\n        var i, ilen, value, major;\n        for (i = 0, ilen = values.length; i < ilen; ++i) {\n            value = values[i];\n            major = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;\n            ticks.push({\n                value: value,\n                major: major\n            });\n        }\n        return ticks;\n    }\n    var defaultConfig = {\n        position: 'bottom',\n        distribution: 'linear',\n        bounds: 'data',\n        adapters: {},\n        time: {\n            parser: false,\n            format: false,\n            unit: false,\n            round: false,\n            displayFormat: false,\n            isoWeekday: false,\n            minUnit: 'millisecond',\n            displayFormats: {}\n        },\n        ticks: {\n            autoSkip: false,\n            source: 'auto',\n            major: { enabled: false }\n        }\n    };\n    module.exports = Scale.extend({\n        initialize: function () {\n            this.mergeTicksOptions();\n            Scale.prototype.initialize.call(this);\n        },\n        update: function () {\n            var me = this;\n            var options = me.options;\n            var time = options.time || (options.time = {});\n            var adapter = me._adapter = new adapters._date(options.adapters.date);\n            if (time.format) {\n                console.warn('options.time.format is deprecated and replaced by options.time.parser.');\n            }\n            helpers.mergeIf(time.displayFormats, adapter.formats());\n            return Scale.prototype.update.apply(me, arguments);\n        },\n        getRightValue: function (rawValue) {\n            if (rawValue && rawValue.t !== undefined) {\n                rawValue = rawValue.t;\n            }\n            return Scale.prototype.getRightValue.call(this, rawValue);\n        },\n        determineDataLimits: function () {\n            var me = this;\n            var chart = me.chart;\n            var adapter = me._adapter;\n            var timeOpts = me.options.time;\n            var unit = timeOpts.unit || 'day';\n            var min = MAX_INTEGER;\n            var max = MIN_INTEGER;\n            var timestamps = [];\n            var datasets = [];\n            var labels = [];\n            var i, j, ilen, jlen, data, timestamp;\n            var dataLabels = chart.data.labels || [];\n            for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\n                labels.push(parse(me, dataLabels[i]));\n            }\n            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n                if (chart.isDatasetVisible(i)) {\n                    data = chart.data.datasets[i].data;\n                    if (helpers.isObject(data[0])) {\n                        datasets[i] = [];\n                        for (j = 0, jlen = data.length; j < jlen; ++j) {\n                            timestamp = parse(me, data[j]);\n                            timestamps.push(timestamp);\n                            datasets[i][j] = timestamp;\n                        }\n                    } else {\n                        for (j = 0, jlen = labels.length; j < jlen; ++j) {\n                            timestamps.push(labels[j]);\n                        }\n                        datasets[i] = labels.slice(0);\n                    }\n                } else {\n                    datasets[i] = [];\n                }\n            }\n            if (labels.length) {\n                labels = arrayUnique(labels).sort(sorter);\n                min = Math.min(min, labels[0]);\n                max = Math.max(max, labels[labels.length - 1]);\n            }\n            if (timestamps.length) {\n                timestamps = arrayUnique(timestamps).sort(sorter);\n                min = Math.min(min, timestamps[0]);\n                max = Math.max(max, timestamps[timestamps.length - 1]);\n            }\n            min = parse(me, timeOpts.min) || min;\n            max = parse(me, timeOpts.max) || max;\n            min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;\n            max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;\n            me.min = Math.min(min, max);\n            me.max = Math.max(min + 1, max);\n            me._horizontal = me.isHorizontal();\n            me._table = [];\n            me._timestamps = {\n                data: timestamps,\n                datasets: datasets,\n                labels: labels\n            };\n        },\n        buildTicks: function () {\n            var me = this;\n            var min = me.min;\n            var max = me.max;\n            var options = me.options;\n            var timeOpts = options.time;\n            var timestamps = [];\n            var ticks = [];\n            var i, ilen, timestamp;\n            switch (options.ticks.source) {\n            case 'data':\n                timestamps = me._timestamps.data;\n                break;\n            case 'labels':\n                timestamps = me._timestamps.labels;\n                break;\n            case 'auto':\n            default:\n                timestamps = generate(me, min, max, me.getLabelCapacity(min), options);\n            }\n            if (options.bounds === 'ticks' && timestamps.length) {\n                min = timestamps[0];\n                max = timestamps[timestamps.length - 1];\n            }\n            min = parse(me, timeOpts.min) || min;\n            max = parse(me, timeOpts.max) || max;\n            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n                timestamp = timestamps[i];\n                if (timestamp >= min && timestamp <= max) {\n                    ticks.push(timestamp);\n                }\n            }\n            me.min = min;\n            me.max = max;\n            me._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);\n            me._majorUnit = determineMajorUnit(me._unit);\n            me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\n            me._offsets = computeOffsets(me._table, ticks, min, max, options);\n            if (options.ticks.reverse) {\n                ticks.reverse();\n            }\n            return ticksFromTimestamps(me, ticks, me._majorUnit);\n        },\n        getLabelForIndex: function (index, datasetIndex) {\n            var me = this;\n            var adapter = me._adapter;\n            var data = me.chart.data;\n            var timeOpts = me.options.time;\n            var label = data.labels && index < data.labels.length ? data.labels[index] : '';\n            var value = data.datasets[datasetIndex].data[index];\n            if (helpers.isObject(value)) {\n                label = me.getRightValue(value);\n            }\n            if (timeOpts.tooltipFormat) {\n                return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);\n            }\n            if (typeof label === 'string') {\n                return label;\n            }\n            return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);\n        },\n        tickFormatFunction: function (time, index, ticks, format) {\n            var me = this;\n            var adapter = me._adapter;\n            var options = me.options;\n            var formats = options.time.displayFormats;\n            var minorFormat = formats[me._unit];\n            var majorUnit = me._majorUnit;\n            var majorFormat = formats[majorUnit];\n            var majorTime = +adapter.startOf(time, majorUnit);\n            var majorTickOpts = options.ticks.major;\n            var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n            var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);\n            var tickOpts = major ? majorTickOpts : options.ticks.minor;\n            var formatter = valueOrDefault(tickOpts.callback, tickOpts.userCallback);\n            return formatter ? formatter(label, index, ticks) : label;\n        },\n        convertTicksToLabels: function (ticks) {\n            var labels = [];\n            var i, ilen;\n            for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n                labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));\n            }\n            return labels;\n        },\n        getPixelForOffset: function (time) {\n            var me = this;\n            var isReverse = me.options.ticks.reverse;\n            var size = me._horizontal ? me.width : me.height;\n            var start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;\n            var pos = interpolate(me._table, 'time', time, 'pos');\n            var offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);\n            return isReverse ? start - offset : start + offset;\n        },\n        getPixelForValue: function (value, index, datasetIndex) {\n            var me = this;\n            var time = null;\n            if (index !== undefined && datasetIndex !== undefined) {\n                time = me._timestamps.datasets[datasetIndex][index];\n            }\n            if (time === null) {\n                time = parse(me, value);\n            }\n            if (time !== null) {\n                return me.getPixelForOffset(time);\n            }\n        },\n        getPixelForTick: function (index) {\n            var ticks = this.getTicks();\n            return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;\n        },\n        getValueForPixel: function (pixel) {\n            var me = this;\n            var size = me._horizontal ? me.width : me.height;\n            var start = me._horizontal ? me.left : me.top;\n            var pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;\n            var time = interpolate(me._table, 'pos', pos, 'time');\n            return me._adapter._create(time);\n        },\n        getLabelWidth: function (label) {\n            var me = this;\n            var ticksOpts = me.options.ticks;\n            var tickLabelWidth = me.ctx.measureText(label).width;\n            var angle = helpers.toRadians(ticksOpts.maxRotation);\n            var cosRotation = Math.cos(angle);\n            var sinRotation = Math.sin(angle);\n            var tickFontSize = valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);\n            return tickLabelWidth * cosRotation + tickFontSize * sinRotation;\n        },\n        getLabelCapacity: function (exampleTime) {\n            var me = this;\n            var format = me.options.time.displayFormats.millisecond;\n            var exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);\n            var tickLabelWidth = me.getLabelWidth(exampleLabel);\n            var innerWidth = me.isHorizontal() ? me.width : me.height;\n            var capacity = Math.floor(innerWidth / tickLabelWidth);\n            return capacity > 0 ? capacity : 1;\n        }\n    });\n    module.exports._defaults = defaultConfig;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/scales/index',[\n    './scale.category',\n    './scale.linear',\n    './scale.logarithmic',\n    './scale.radialLinear',\n    './scale.time'\n], function (__module__0, __module__1, __module__2, __module__3, __module__4) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var category = __module__0;\n    var linear = __module__1;\n    var logarithmic = __module__2;\n    var radialLinear = __module__3;\n    var time = __module__4;\n    module.exports = {\n        category: category,\n        linear: linear,\n        logarithmic: logarithmic,\n        radialLinear: radialLinear,\n        time: time\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/adapters/adapter.moment',[\n    'skylark-moment',\n    '../core/core.adapters'\n], function (__module__0, __module__1) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var moment = __module__0;\n    var adapters = __module__1;\n    var FORMATS = {\n        datetime: 'MMM D, YYYY, h:mm:ss a',\n        millisecond: 'h:mm:ss.SSS a',\n        second: 'h:mm:ss a',\n        minute: 'h:mm a',\n        hour: 'hA',\n        day: 'MMM D',\n        week: 'll',\n        month: 'MMM YYYY',\n        quarter: '[Q]Q - YYYY',\n        year: 'YYYY'\n    };\n    adapters._date.override(typeof moment === 'function' ? {\n        _id: 'moment',\n        formats: function () {\n            return FORMATS;\n        },\n        parse: function (value, format) {\n            if (typeof value === 'string' && typeof format === 'string') {\n                value = moment(value, format);\n            } else if (!(value instanceof moment)) {\n                value = moment(value);\n            }\n            return value.isValid() ? value.valueOf() : null;\n        },\n        format: function (time, format) {\n            return moment(time).format(format);\n        },\n        add: function (time, amount, unit) {\n            return moment(time).add(amount, unit).valueOf();\n        },\n        diff: function (max, min, unit) {\n            return moment.duration(moment(max).diff(moment(min))).as(unit);\n        },\n        startOf: function (time, unit, weekday) {\n            time = moment(time);\n            if (unit === 'isoWeek') {\n                return time.isoWeekday(weekday).valueOf();\n            }\n            return time.startOf(unit).valueOf();\n        },\n        endOf: function (time, unit) {\n            return moment(time).endOf(unit).valueOf();\n        },\n        _create: function (time) {\n            return moment(time);\n        }\n    } : {});\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/adapters/index',['./adapter.moment'], function (__module__0) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    __module__0;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/plugins/plugin.filler',[\n    '../core/core.defaults',\n    '../elements/index',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var elements = __module__1;\n    var helpers = __module__2;\n    defaults._set('global', { plugins: { filler: { propagate: true } } });\n    var mappers = {\n        dataset: function (source) {\n            var index = source.fill;\n            var chart = source.chart;\n            var meta = chart.getDatasetMeta(index);\n            var visible = meta && chart.isDatasetVisible(index);\n            var points = visible && meta.dataset._children || [];\n            var length = points.length || 0;\n            return !length ? null : function (point, i) {\n                return i < length && points[i]._view || null;\n            };\n        },\n        boundary: function (source) {\n            var boundary = source.boundary;\n            var x = boundary ? boundary.x : null;\n            var y = boundary ? boundary.y : null;\n            return function (point) {\n                return {\n                    x: x === null ? point.x : x,\n                    y: y === null ? point.y : y\n                };\n            };\n        }\n    };\n    function decodeFill(el, index, count) {\n        var model = el._model || {};\n        var fill = model.fill;\n        var target;\n        if (fill === undefined) {\n            fill = !!model.backgroundColor;\n        }\n        if (fill === false || fill === null) {\n            return false;\n        }\n        if (fill === true) {\n            return 'origin';\n        }\n        target = parseFloat(fill, 10);\n        if (isFinite(target) && Math.floor(target) === target) {\n            if (fill[0] === '-' || fill[0] === '+') {\n                target = index + target;\n            }\n            if (target === index || target < 0 || target >= count) {\n                return false;\n            }\n            return target;\n        }\n        switch (fill) {\n        case 'bottom':\n            return 'start';\n        case 'top':\n            return 'end';\n        case 'zero':\n            return 'origin';\n        case 'origin':\n        case 'start':\n        case 'end':\n            return fill;\n        default:\n            return false;\n        }\n    }\n    function computeBoundary(source) {\n        var model = source.el._model || {};\n        var scale = source.el._scale || {};\n        var fill = source.fill;\n        var target = null;\n        var horizontal;\n        if (isFinite(fill)) {\n            return null;\n        }\n        if (fill === 'start') {\n            target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n        } else if (fill === 'end') {\n            target = model.scaleTop === undefined ? scale.top : model.scaleTop;\n        } else if (model.scaleZero !== undefined) {\n            target = model.scaleZero;\n        } else if (scale.getBasePosition) {\n            target = scale.getBasePosition();\n        } else if (scale.getBasePixel) {\n            target = scale.getBasePixel();\n        }\n        if (target !== undefined && target !== null) {\n            if (target.x !== undefined && target.y !== undefined) {\n                return target;\n            }\n            if (helpers.isFinite(target)) {\n                horizontal = scale.isHorizontal();\n                return {\n                    x: horizontal ? target : null,\n                    y: horizontal ? null : target\n                };\n            }\n        }\n        return null;\n    }\n    function resolveTarget(sources, index, propagate) {\n        var source = sources[index];\n        var fill = source.fill;\n        var visited = [index];\n        var target;\n        if (!propagate) {\n            return fill;\n        }\n        while (fill !== false && visited.indexOf(fill) === -1) {\n            if (!isFinite(fill)) {\n                return fill;\n            }\n            target = sources[fill];\n            if (!target) {\n                return false;\n            }\n            if (target.visible) {\n                return fill;\n            }\n            visited.push(fill);\n            fill = target.fill;\n        }\n        return false;\n    }\n    function createMapper(source) {\n        var fill = source.fill;\n        var type = 'dataset';\n        if (fill === false) {\n            return null;\n        }\n        if (!isFinite(fill)) {\n            type = 'boundary';\n        }\n        return mappers[type](source);\n    }\n    function isDrawable(point) {\n        return point && !point.skip;\n    }\n    function drawArea(ctx, curve0, curve1, len0, len1) {\n        var i;\n        if (!len0 || !len1) {\n            return;\n        }\n        ctx.moveTo(curve0[0].x, curve0[0].y);\n        for (i = 1; i < len0; ++i) {\n            helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n        }\n        ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);\n        for (i = len1 - 1; i > 0; --i) {\n            helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n        }\n    }\n    function doFill(ctx, points, mapper, view, color, loop) {\n        var count = points.length;\n        var span = view.spanGaps;\n        var curve0 = [];\n        var curve1 = [];\n        var len0 = 0;\n        var len1 = 0;\n        var i, ilen, index, p0, p1, d0, d1;\n        ctx.beginPath();\n        for (i = 0, ilen = count + !!loop; i < ilen; ++i) {\n            index = i % count;\n            p0 = points[index]._view;\n            p1 = mapper(p0, index, view);\n            d0 = isDrawable(p0);\n            d1 = isDrawable(p1);\n            if (d0 && d1) {\n                len0 = curve0.push(p0);\n                len1 = curve1.push(p1);\n            } else if (len0 && len1) {\n                if (!span) {\n                    drawArea(ctx, curve0, curve1, len0, len1);\n                    len0 = len1 = 0;\n                    curve0 = [];\n                    curve1 = [];\n                } else {\n                    if (d0) {\n                        curve0.push(p0);\n                    }\n                    if (d1) {\n                        curve1.push(p1);\n                    }\n                }\n            }\n        }\n        drawArea(ctx, curve0, curve1, len0, len1);\n        ctx.closePath();\n        ctx.fillStyle = color;\n        ctx.fill();\n    }\n    module.exports = {\n        id: 'filler',\n        afterDatasetsUpdate: function (chart, options) {\n            var count = (chart.data.datasets || []).length;\n            var propagate = options.propagate;\n            var sources = [];\n            var meta, i, el, source;\n            for (i = 0; i < count; ++i) {\n                meta = chart.getDatasetMeta(i);\n                el = meta.dataset;\n                source = null;\n                if (el && el._model && el instanceof elements.Line) {\n                    source = {\n                        visible: chart.isDatasetVisible(i),\n                        fill: decodeFill(el, i, count),\n                        chart: chart,\n                        el: el\n                    };\n                }\n                meta.$filler = source;\n                sources.push(source);\n            }\n            for (i = 0; i < count; ++i) {\n                source = sources[i];\n                if (!source) {\n                    continue;\n                }\n                source.fill = resolveTarget(sources, i, propagate);\n                source.boundary = computeBoundary(source);\n                source.mapper = createMapper(source);\n            }\n        },\n        beforeDatasetDraw: function (chart, args) {\n            var meta = args.meta.$filler;\n            if (!meta) {\n                return;\n            }\n            var ctx = chart.ctx;\n            var el = meta.el;\n            var view = el._view;\n            var points = el._children || [];\n            var mapper = meta.mapper;\n            var color = view.backgroundColor || defaults.global.defaultColor;\n            if (mapper && color && points.length) {\n                helpers.canvas.clipArea(ctx, chart.chartArea);\n                doFill(ctx, points, mapper, view, color, el._loop);\n                helpers.canvas.unclipArea(ctx);\n            }\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/plugins/plugin.legend',[\n    '../core/core.defaults',\n    '../core/core.element',\n    '../helpers/index',\n    '../core/core.layouts'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var Element = __module__1;\n    var helpers = __module__2;\n    var layouts = __module__3;\n    var noop = helpers.noop;\n    var valueOrDefault = helpers.valueOrDefault;\n    defaults._set('global', {\n        legend: {\n            display: true,\n            position: 'top',\n            fullWidth: true,\n            reverse: false,\n            weight: 1000,\n            onClick: function (e, legendItem) {\n                var index = legendItem.datasetIndex;\n                var ci = this.chart;\n                var meta = ci.getDatasetMeta(index);\n                meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\n                ci.update();\n            },\n            onHover: null,\n            onLeave: null,\n            labels: {\n                boxWidth: 40,\n                padding: 10,\n                generateLabels: function (chart) {\n                    var data = chart.data;\n                    return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {\n                        return {\n                            text: dataset.label,\n                            fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],\n                            hidden: !chart.isDatasetVisible(i),\n                            lineCap: dataset.borderCapStyle,\n                            lineDash: dataset.borderDash,\n                            lineDashOffset: dataset.borderDashOffset,\n                            lineJoin: dataset.borderJoinStyle,\n                            lineWidth: dataset.borderWidth,\n                            strokeStyle: dataset.borderColor,\n                            pointStyle: dataset.pointStyle,\n                            datasetIndex: i\n                        };\n                    }, this) : [];\n                }\n            }\n        },\n        legendCallback: function (chart) {\n            var text = [];\n            text.push('<ul class=\"' + chart.id + '-legend\">');\n            for (var i = 0; i < chart.data.datasets.length; i++) {\n                text.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n                if (chart.data.datasets[i].label) {\n                    text.push(chart.data.datasets[i].label);\n                }\n                text.push('</li>');\n            }\n            text.push('</ul>');\n            return text.join('');\n        }\n    });\n    function getBoxWidth(labelOpts, fontSize) {\n        return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;\n    }\n    var Legend = Element.extend({\n        initialize: function (config) {\n            helpers.extend(this, config);\n            this.legendHitBoxes = [];\n            this._hoveredItem = null;\n            this.doughnutMode = false;\n        },\n        beforeUpdate: noop,\n        update: function (maxWidth, maxHeight, margins) {\n            var me = this;\n            me.beforeUpdate();\n            me.maxWidth = maxWidth;\n            me.maxHeight = maxHeight;\n            me.margins = margins;\n            me.beforeSetDimensions();\n            me.setDimensions();\n            me.afterSetDimensions();\n            me.beforeBuildLabels();\n            me.buildLabels();\n            me.afterBuildLabels();\n            me.beforeFit();\n            me.fit();\n            me.afterFit();\n            me.afterUpdate();\n            return me.minSize;\n        },\n        afterUpdate: noop,\n        beforeSetDimensions: noop,\n        setDimensions: function () {\n            var me = this;\n            if (me.isHorizontal()) {\n                me.width = me.maxWidth;\n                me.left = 0;\n                me.right = me.width;\n            } else {\n                me.height = me.maxHeight;\n                me.top = 0;\n                me.bottom = me.height;\n            }\n            me.paddingLeft = 0;\n            me.paddingTop = 0;\n            me.paddingRight = 0;\n            me.paddingBottom = 0;\n            me.minSize = {\n                width: 0,\n                height: 0\n            };\n        },\n        afterSetDimensions: noop,\n        beforeBuildLabels: noop,\n        buildLabels: function () {\n            var me = this;\n            var labelOpts = me.options.labels || {};\n            var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];\n            if (labelOpts.filter) {\n                legendItems = legendItems.filter(function (item) {\n                    return labelOpts.filter(item, me.chart.data);\n                });\n            }\n            if (me.options.reverse) {\n                legendItems.reverse();\n            }\n            me.legendItems = legendItems;\n        },\n        afterBuildLabels: noop,\n        beforeFit: noop,\n        fit: function () {\n            var me = this;\n            var opts = me.options;\n            var labelOpts = opts.labels;\n            var display = opts.display;\n            var ctx = me.ctx;\n            var labelFont = helpers.options._parseFont(labelOpts);\n            var fontSize = labelFont.size;\n            var hitboxes = me.legendHitBoxes = [];\n            var minSize = me.minSize;\n            var isHorizontal = me.isHorizontal();\n            if (isHorizontal) {\n                minSize.width = me.maxWidth;\n                minSize.height = display ? 10 : 0;\n            } else {\n                minSize.width = display ? 10 : 0;\n                minSize.height = me.maxHeight;\n            }\n            if (display) {\n                ctx.font = labelFont.string;\n                if (isHorizontal) {\n                    var lineWidths = me.lineWidths = [0];\n                    var totalHeight = 0;\n                    ctx.textAlign = 'left';\n                    ctx.textBaseline = 'top';\n                    helpers.each(me.legendItems, function (legendItem, i) {\n                        var boxWidth = getBoxWidth(labelOpts, fontSize);\n                        var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n                        if (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {\n                            totalHeight += fontSize + labelOpts.padding;\n                            lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;\n                        }\n                        hitboxes[i] = {\n                            left: 0,\n                            top: 0,\n                            width: width,\n                            height: fontSize\n                        };\n                        lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n                    });\n                    minSize.height += totalHeight;\n                } else {\n                    var vPadding = labelOpts.padding;\n                    var columnWidths = me.columnWidths = [];\n                    var totalWidth = labelOpts.padding;\n                    var currentColWidth = 0;\n                    var currentColHeight = 0;\n                    var itemHeight = fontSize + vPadding;\n                    helpers.each(me.legendItems, function (legendItem, i) {\n                        var boxWidth = getBoxWidth(labelOpts, fontSize);\n                        var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n                        if (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {\n                            totalWidth += currentColWidth + labelOpts.padding;\n                            columnWidths.push(currentColWidth);\n                            currentColWidth = 0;\n                            currentColHeight = 0;\n                        }\n                        currentColWidth = Math.max(currentColWidth, itemWidth);\n                        currentColHeight += itemHeight;\n                        hitboxes[i] = {\n                            left: 0,\n                            top: 0,\n                            width: itemWidth,\n                            height: fontSize\n                        };\n                    });\n                    totalWidth += currentColWidth;\n                    columnWidths.push(currentColWidth);\n                    minSize.width += totalWidth;\n                }\n            }\n            me.width = minSize.width;\n            me.height = minSize.height;\n        },\n        afterFit: noop,\n        isHorizontal: function () {\n            return this.options.position === 'top' || this.options.position === 'bottom';\n        },\n        draw: function () {\n            var me = this;\n            var opts = me.options;\n            var labelOpts = opts.labels;\n            var globalDefaults = defaults.global;\n            var defaultColor = globalDefaults.defaultColor;\n            var lineDefault = globalDefaults.elements.line;\n            var legendWidth = me.width;\n            var lineWidths = me.lineWidths;\n            if (opts.display) {\n                var ctx = me.ctx;\n                var fontColor = valueOrDefault(labelOpts.fontColor, globalDefaults.defaultFontColor);\n                var labelFont = helpers.options._parseFont(labelOpts);\n                var fontSize = labelFont.size;\n                var cursor;\n                ctx.textAlign = 'left';\n                ctx.textBaseline = 'middle';\n                ctx.lineWidth = 0.5;\n                ctx.strokeStyle = fontColor;\n                ctx.fillStyle = fontColor;\n                ctx.font = labelFont.string;\n                var boxWidth = getBoxWidth(labelOpts, fontSize);\n                var hitboxes = me.legendHitBoxes;\n                var drawLegendBox = function (x, y, legendItem) {\n                    if (isNaN(boxWidth) || boxWidth <= 0) {\n                        return;\n                    }\n                    ctx.save();\n                    var lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n                    ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n                    ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n                    ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n                    ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n                    ctx.lineWidth = lineWidth;\n                    ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n                    if (ctx.setLineDash) {\n                        ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n                    }\n                    if (opts.labels && opts.labels.usePointStyle) {\n                        var radius = boxWidth * Math.SQRT2 / 2;\n                        var centerX = x + boxWidth / 2;\n                        var centerY = y + fontSize / 2;\n                        helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n                    } else {\n                        if (lineWidth !== 0) {\n                            ctx.strokeRect(x, y, boxWidth, fontSize);\n                        }\n                        ctx.fillRect(x, y, boxWidth, fontSize);\n                    }\n                    ctx.restore();\n                };\n                var fillText = function (x, y, legendItem, textWidth) {\n                    var halfFontSize = fontSize / 2;\n                    var xLeft = boxWidth + halfFontSize + x;\n                    var yMiddle = y + halfFontSize;\n                    ctx.fillText(legendItem.text, xLeft, yMiddle);\n                    if (legendItem.hidden) {\n                        ctx.beginPath();\n                        ctx.lineWidth = 2;\n                        ctx.moveTo(xLeft, yMiddle);\n                        ctx.lineTo(xLeft + textWidth, yMiddle);\n                        ctx.stroke();\n                    }\n                };\n                var isHorizontal = me.isHorizontal();\n                if (isHorizontal) {\n                    cursor = {\n                        x: me.left + (legendWidth - lineWidths[0]) / 2 + labelOpts.padding,\n                        y: me.top + labelOpts.padding,\n                        line: 0\n                    };\n                } else {\n                    cursor = {\n                        x: me.left + labelOpts.padding,\n                        y: me.top + labelOpts.padding,\n                        line: 0\n                    };\n                }\n                var itemHeight = fontSize + labelOpts.padding;\n                helpers.each(me.legendItems, function (legendItem, i) {\n                    var textWidth = ctx.measureText(legendItem.text).width;\n                    var width = boxWidth + fontSize / 2 + textWidth;\n                    var x = cursor.x;\n                    var y = cursor.y;\n                    if (isHorizontal) {\n                        if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {\n                            y = cursor.y += itemHeight;\n                            cursor.line++;\n                            x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2 + labelOpts.padding;\n                        }\n                    } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {\n                        x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n                        y = cursor.y = me.top + labelOpts.padding;\n                        cursor.line++;\n                    }\n                    drawLegendBox(x, y, legendItem);\n                    hitboxes[i].left = x;\n                    hitboxes[i].top = y;\n                    fillText(x, y, legendItem, textWidth);\n                    if (isHorizontal) {\n                        cursor.x += width + labelOpts.padding;\n                    } else {\n                        cursor.y += itemHeight;\n                    }\n                });\n            }\n        },\n        _getLegendItemAt: function (x, y) {\n            var me = this;\n            var i, hitBox, lh;\n            if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n                lh = me.legendHitBoxes;\n                for (i = 0; i < lh.length; ++i) {\n                    hitBox = lh[i];\n                    if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n                        return me.legendItems[i];\n                    }\n                }\n            }\n            return null;\n        },\n        handleEvent: function (e) {\n            var me = this;\n            var opts = me.options;\n            var type = e.type === 'mouseup' ? 'click' : e.type;\n            var hoveredItem;\n            if (type === 'mousemove') {\n                if (!opts.onHover && !opts.onLeave) {\n                    return;\n                }\n            } else if (type === 'click') {\n                if (!opts.onClick) {\n                    return;\n                }\n            } else {\n                return;\n            }\n            hoveredItem = me._getLegendItemAt(e.x, e.y);\n            if (type === 'click') {\n                if (hoveredItem && opts.onClick) {\n                    opts.onClick.call(me, e.native, hoveredItem);\n                }\n            } else {\n                if (opts.onLeave && hoveredItem !== me._hoveredItem) {\n                    if (me._hoveredItem) {\n                        opts.onLeave.call(me, e.native, me._hoveredItem);\n                    }\n                    me._hoveredItem = hoveredItem;\n                }\n                if (opts.onHover && hoveredItem) {\n                    opts.onHover.call(me, e.native, hoveredItem);\n                }\n            }\n        }\n    });\n    function createNewLegendAndAttach(chart, legendOpts) {\n        var legend = new Legend({\n            ctx: chart.ctx,\n            options: legendOpts,\n            chart: chart\n        });\n        layouts.configure(chart, legend, legendOpts);\n        layouts.addBox(chart, legend);\n        chart.legend = legend;\n    }\n    module.exports = {\n        id: 'legend',\n        _element: Legend,\n        beforeInit: function (chart) {\n            var legendOpts = chart.options.legend;\n            if (legendOpts) {\n                createNewLegendAndAttach(chart, legendOpts);\n            }\n        },\n        beforeUpdate: function (chart) {\n            var legendOpts = chart.options.legend;\n            var legend = chart.legend;\n            if (legendOpts) {\n                helpers.mergeIf(legendOpts, defaults.global.legend);\n                if (legend) {\n                    layouts.configure(chart, legend, legendOpts);\n                    legend.options = legendOpts;\n                } else {\n                    createNewLegendAndAttach(chart, legendOpts);\n                }\n            } else if (legend) {\n                layouts.removeBox(chart, legend);\n                delete chart.legend;\n            }\n        },\n        afterEvent: function (chart, e) {\n            var legend = chart.legend;\n            if (legend) {\n                legend.handleEvent(e);\n            }\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/plugins/plugin.title',[\n    '../core/core.defaults',\n    '../core/core.element',\n    '../helpers/index',\n    '../core/core.layouts'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var Element = __module__1;\n    var helpers = __module__2;\n    var layouts = __module__3;\n    var noop = helpers.noop;\n    defaults._set('global', {\n        title: {\n            display: false,\n            fontStyle: 'bold',\n            fullWidth: true,\n            padding: 10,\n            position: 'top',\n            text: '',\n            weight: 2000\n        }\n    });\n    var Title = Element.extend({\n        initialize: function (config) {\n            var me = this;\n            helpers.extend(me, config);\n            me.legendHitBoxes = [];\n        },\n        beforeUpdate: noop,\n        update: function (maxWidth, maxHeight, margins) {\n            var me = this;\n            me.beforeUpdate();\n            me.maxWidth = maxWidth;\n            me.maxHeight = maxHeight;\n            me.margins = margins;\n            me.beforeSetDimensions();\n            me.setDimensions();\n            me.afterSetDimensions();\n            me.beforeBuildLabels();\n            me.buildLabels();\n            me.afterBuildLabels();\n            me.beforeFit();\n            me.fit();\n            me.afterFit();\n            me.afterUpdate();\n            return me.minSize;\n        },\n        afterUpdate: noop,\n        beforeSetDimensions: noop,\n        setDimensions: function () {\n            var me = this;\n            if (me.isHorizontal()) {\n                me.width = me.maxWidth;\n                me.left = 0;\n                me.right = me.width;\n            } else {\n                me.height = me.maxHeight;\n                me.top = 0;\n                me.bottom = me.height;\n            }\n            me.paddingLeft = 0;\n            me.paddingTop = 0;\n            me.paddingRight = 0;\n            me.paddingBottom = 0;\n            me.minSize = {\n                width: 0,\n                height: 0\n            };\n        },\n        afterSetDimensions: noop,\n        beforeBuildLabels: noop,\n        buildLabels: noop,\n        afterBuildLabels: noop,\n        beforeFit: noop,\n        fit: function () {\n            var me = this;\n            var opts = me.options;\n            var display = opts.display;\n            var minSize = me.minSize;\n            var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;\n            var fontOpts = helpers.options._parseFont(opts);\n            var textSize = display ? lineCount * fontOpts.lineHeight + opts.padding * 2 : 0;\n            if (me.isHorizontal()) {\n                minSize.width = me.maxWidth;\n                minSize.height = textSize;\n            } else {\n                minSize.width = textSize;\n                minSize.height = me.maxHeight;\n            }\n            me.width = minSize.width;\n            me.height = minSize.height;\n        },\n        afterFit: noop,\n        isHorizontal: function () {\n            var pos = this.options.position;\n            return pos === 'top' || pos === 'bottom';\n        },\n        draw: function () {\n            var me = this;\n            var ctx = me.ctx;\n            var opts = me.options;\n            if (opts.display) {\n                var fontOpts = helpers.options._parseFont(opts);\n                var lineHeight = fontOpts.lineHeight;\n                var offset = lineHeight / 2 + opts.padding;\n                var rotation = 0;\n                var top = me.top;\n                var left = me.left;\n                var bottom = me.bottom;\n                var right = me.right;\n                var maxWidth, titleX, titleY;\n                ctx.fillStyle = helpers.valueOrDefault(opts.fontColor, defaults.global.defaultFontColor);\n                ctx.font = fontOpts.string;\n                if (me.isHorizontal()) {\n                    titleX = left + (right - left) / 2;\n                    titleY = top + offset;\n                    maxWidth = right - left;\n                } else {\n                    titleX = opts.position === 'left' ? left + offset : right - offset;\n                    titleY = top + (bottom - top) / 2;\n                    maxWidth = bottom - top;\n                    rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n                }\n                ctx.save();\n                ctx.translate(titleX, titleY);\n                ctx.rotate(rotation);\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                var text = opts.text;\n                if (helpers.isArray(text)) {\n                    var y = 0;\n                    for (var i = 0; i < text.length; ++i) {\n                        ctx.fillText(text[i], 0, y, maxWidth);\n                        y += lineHeight;\n                    }\n                } else {\n                    ctx.fillText(text, 0, 0, maxWidth);\n                }\n                ctx.restore();\n            }\n        }\n    });\n    function createNewTitleBlockAndAttach(chart, titleOpts) {\n        var title = new Title({\n            ctx: chart.ctx,\n            options: titleOpts,\n            chart: chart\n        });\n        layouts.configure(chart, title, titleOpts);\n        layouts.addBox(chart, title);\n        chart.titleBlock = title;\n    }\n    module.exports = {\n        id: 'title',\n        _element: Title,\n        beforeInit: function (chart) {\n            var titleOpts = chart.options.title;\n            if (titleOpts) {\n                createNewTitleBlockAndAttach(chart, titleOpts);\n            }\n        },\n        beforeUpdate: function (chart) {\n            var titleOpts = chart.options.title;\n            var titleBlock = chart.titleBlock;\n            if (titleOpts) {\n                helpers.mergeIf(titleOpts, defaults.global.title);\n                if (titleBlock) {\n                    layouts.configure(chart, titleBlock, titleOpts);\n                    titleBlock.options = titleOpts;\n                } else {\n                    createNewTitleBlockAndAttach(chart, titleOpts);\n                }\n            } else if (titleBlock) {\n                layouts.removeBox(chart, titleBlock);\n                delete chart.titleBlock;\n            }\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/plugins/index',[\n    './plugin.filler',\n    './plugin.legend',\n    './plugin.title'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    module.exports = {};\n    module.exports.filler = __module__0;\n    module.exports.legend = __module__1;\n    module.exports.title = __module__2;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs/main',[\n    './core/core.controller',\n    './helpers/index',\n    './core/core.helpers',\n    './core/core.adapters',\n    './core/core.animation',\n    './core/core.animations',\n    './controllers/index',\n    './core/core.datasetController',\n    './core/core.defaults',\n    './core/core.element',\n    './elements/index',\n    './core/core.interaction',\n    './core/core.layouts',\n    './platforms/platform',\n    './core/core.plugins',\n    './core/core.scale',\n    './core/core.scaleService',\n    './core/core.ticks',\n    './core/core.tooltip',\n    './scales/index',\n    './adapters/index',\n    './plugins/index',\n    './scales/scale.linearbase'\n], function (__module__0, __module__1, __module__2, __module__3, __module__4, __module__5, __module__6, __module__7, __module__8, __module__9, __module__10, __module__11, __module__12, __module__13, __module__14, __module__15, __module__16, __module__17, __module__18, __module__19, __module__20, __module__21, __module__22) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var Chart = __module__0;\n    Chart.helpers = __module__1;\n    __module__2(Chart);\n    Chart._adapters = __module__3;\n    Chart.Animation = __module__4;\n    Chart.animationService = __module__5;\n    Chart.controllers = __module__6;\n    Chart.DatasetController = __module__7;\n    Chart.defaults = __module__8;\n    Chart.Element = __module__9;\n    Chart.elements = __module__10;\n    Chart.Interaction = __module__11;\n    Chart.layouts = __module__12;\n    Chart.platform = __module__13;\n    Chart.plugins = __module__14;\n    Chart.Scale = __module__15;\n    Chart.scaleService = __module__16;\n    Chart.Ticks = __module__17;\n    Chart.Tooltip = __module__18;\n    var scales = __module__19;\n    Chart.helpers.each(scales, function (scale, type) {\n        Chart.scaleService.registerScaleType(type, scale, scale._defaults);\n    });\n    __module__20;\n    var plugins = __module__21;\n    for (var k in plugins) {\n        if (plugins.hasOwnProperty(k)) {\n            Chart.plugins.register(plugins[k]);\n        }\n    }\n    Chart.platform.initialize();\n    module.exports = Chart;\n    if (typeof window !== 'undefined') {\n        window.Chart = Chart;\n    }\n    Chart.Chart = Chart;\n    Chart.Legend = plugins.legend._element;\n    Chart.Title = plugins.title._element;\n    Chart.pluginService = Chart.plugins;\n    Chart.PluginBase = Chart.Element.extend({});\n    Chart.canvasHelpers = Chart.helpers.canvas;\n    Chart.layoutService = Chart.layouts;\n    Chart.LinearScaleBase = __module__22;\n    Chart.helpers.each([\n        'Bar',\n        'Bubble',\n        'Doughnut',\n        'Line',\n        'PolarArea',\n        'Radar',\n        'Scatter'\n    ], function (klass) {\n        Chart[klass] = function (ctx, cfg) {\n            return new Chart(ctx, Chart.helpers.merge(cfg || {}, { type: klass.charAt(0).toLowerCase() + klass.slice(1) }));\n        };\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-chartjs', ['skylark-chartjs/main'], function (main) { return main; });\n\n"]}