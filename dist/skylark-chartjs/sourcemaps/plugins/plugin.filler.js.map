{"version":3,"sources":["plugins/plugin.filler.js"],"names":["define","__module__0","__module__1","__module__2","exports","module","defaults","elements","helpers","_set","plugins","filler","propagate","mappers","dataset","source","index","fill","chart","meta","getDatasetMeta","points","isDatasetVisible","_children","length","point","i","_view","boundary","x","y","decodeFill","el","count","target","model","_model","undefined","backgroundColor","parseFloat","isFinite","Math","floor","computeBoundary","horizontal","scale","_scale","scaleBottom","bottom","scaleTop","top","scaleZero","getBasePosition","getBasePixel","isHorizontal","resolveTarget","sources","visited","indexOf","visible","push","createMapper","type","isDrawable","skip","drawArea","ctx","curve0","curve1","len0","len1","moveTo","canvas","lineTo","__isValidToReturn","obj","Array","isArray","attr","__isEmptyObject","id","afterDatasetsUpdate","options","data","datasets","Line","$filler","mapper","beforeDatasetDraw","args","view","color","global","defaultColor","clipArea","chartArea","loop","ilen","p0","p1","d0","d1","span","spanGaps","beginPath","closePath","fillStyle","doFill","_loop","unclipArea"],"mappings":"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","file":"../../plugins/plugin.filler.js","sourcesContent":["define([\n    '../core/core.defaults',\n    '../elements/index',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var elements = __module__1;\n    var helpers = __module__2;\n    defaults._set('global', { plugins: { filler: { propagate: true } } });\n    var mappers = {\n        dataset: function (source) {\n            var index = source.fill;\n            var chart = source.chart;\n            var meta = chart.getDatasetMeta(index);\n            var visible = meta && chart.isDatasetVisible(index);\n            var points = visible && meta.dataset._children || [];\n            var length = points.length || 0;\n            return !length ? null : function (point, i) {\n                return i < length && points[i]._view || null;\n            };\n        },\n        boundary: function (source) {\n            var boundary = source.boundary;\n            var x = boundary ? boundary.x : null;\n            var y = boundary ? boundary.y : null;\n            return function (point) {\n                return {\n                    x: x === null ? point.x : x,\n                    y: y === null ? point.y : y\n                };\n            };\n        }\n    };\n    function decodeFill(el, index, count) {\n        var model = el._model || {};\n        var fill = model.fill;\n        var target;\n        if (fill === undefined) {\n            fill = !!model.backgroundColor;\n        }\n        if (fill === false || fill === null) {\n            return false;\n        }\n        if (fill === true) {\n            return 'origin';\n        }\n        target = parseFloat(fill, 10);\n        if (isFinite(target) && Math.floor(target) === target) {\n            if (fill[0] === '-' || fill[0] === '+') {\n                target = index + target;\n            }\n            if (target === index || target < 0 || target >= count) {\n                return false;\n            }\n            return target;\n        }\n        switch (fill) {\n        case 'bottom':\n            return 'start';\n        case 'top':\n            return 'end';\n        case 'zero':\n            return 'origin';\n        case 'origin':\n        case 'start':\n        case 'end':\n            return fill;\n        default:\n            return false;\n        }\n    }\n    function computeBoundary(source) {\n        var model = source.el._model || {};\n        var scale = source.el._scale || {};\n        var fill = source.fill;\n        var target = null;\n        var horizontal;\n        if (isFinite(fill)) {\n            return null;\n        }\n        if (fill === 'start') {\n            target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n        } else if (fill === 'end') {\n            target = model.scaleTop === undefined ? scale.top : model.scaleTop;\n        } else if (model.scaleZero !== undefined) {\n            target = model.scaleZero;\n        } else if (scale.getBasePosition) {\n            target = scale.getBasePosition();\n        } else if (scale.getBasePixel) {\n            target = scale.getBasePixel();\n        }\n        if (target !== undefined && target !== null) {\n            if (target.x !== undefined && target.y !== undefined) {\n                return target;\n            }\n            if (helpers.isFinite(target)) {\n                horizontal = scale.isHorizontal();\n                return {\n                    x: horizontal ? target : null,\n                    y: horizontal ? null : target\n                };\n            }\n        }\n        return null;\n    }\n    function resolveTarget(sources, index, propagate) {\n        var source = sources[index];\n        var fill = source.fill;\n        var visited = [index];\n        var target;\n        if (!propagate) {\n            return fill;\n        }\n        while (fill !== false && visited.indexOf(fill) === -1) {\n            if (!isFinite(fill)) {\n                return fill;\n            }\n            target = sources[fill];\n            if (!target) {\n                return false;\n            }\n            if (target.visible) {\n                return fill;\n            }\n            visited.push(fill);\n            fill = target.fill;\n        }\n        return false;\n    }\n    function createMapper(source) {\n        var fill = source.fill;\n        var type = 'dataset';\n        if (fill === false) {\n            return null;\n        }\n        if (!isFinite(fill)) {\n            type = 'boundary';\n        }\n        return mappers[type](source);\n    }\n    function isDrawable(point) {\n        return point && !point.skip;\n    }\n    function drawArea(ctx, curve0, curve1, len0, len1) {\n        var i;\n        if (!len0 || !len1) {\n            return;\n        }\n        ctx.moveTo(curve0[0].x, curve0[0].y);\n        for (i = 1; i < len0; ++i) {\n            helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n        }\n        ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);\n        for (i = len1 - 1; i > 0; --i) {\n            helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n        }\n    }\n    function doFill(ctx, points, mapper, view, color, loop) {\n        var count = points.length;\n        var span = view.spanGaps;\n        var curve0 = [];\n        var curve1 = [];\n        var len0 = 0;\n        var len1 = 0;\n        var i, ilen, index, p0, p1, d0, d1;\n        ctx.beginPath();\n        for (i = 0, ilen = count + !!loop; i < ilen; ++i) {\n            index = i % count;\n            p0 = points[index]._view;\n            p1 = mapper(p0, index, view);\n            d0 = isDrawable(p0);\n            d1 = isDrawable(p1);\n            if (d0 && d1) {\n                len0 = curve0.push(p0);\n                len1 = curve1.push(p1);\n            } else if (len0 && len1) {\n                if (!span) {\n                    drawArea(ctx, curve0, curve1, len0, len1);\n                    len0 = len1 = 0;\n                    curve0 = [];\n                    curve1 = [];\n                } else {\n                    if (d0) {\n                        curve0.push(p0);\n                    }\n                    if (d1) {\n                        curve1.push(p1);\n                    }\n                }\n            }\n        }\n        drawArea(ctx, curve0, curve1, len0, len1);\n        ctx.closePath();\n        ctx.fillStyle = color;\n        ctx.fill();\n    }\n    module.exports = {\n        id: 'filler',\n        afterDatasetsUpdate: function (chart, options) {\n            var count = (chart.data.datasets || []).length;\n            var propagate = options.propagate;\n            var sources = [];\n            var meta, i, el, source;\n            for (i = 0; i < count; ++i) {\n                meta = chart.getDatasetMeta(i);\n                el = meta.dataset;\n                source = null;\n                if (el && el._model && el instanceof elements.Line) {\n                    source = {\n                        visible: chart.isDatasetVisible(i),\n                        fill: decodeFill(el, i, count),\n                        chart: chart,\n                        el: el\n                    };\n                }\n                meta.$filler = source;\n                sources.push(source);\n            }\n            for (i = 0; i < count; ++i) {\n                source = sources[i];\n                if (!source) {\n                    continue;\n                }\n                source.fill = resolveTarget(sources, i, propagate);\n                source.boundary = computeBoundary(source);\n                source.mapper = createMapper(source);\n            }\n        },\n        beforeDatasetDraw: function (chart, args) {\n            var meta = args.meta.$filler;\n            if (!meta) {\n                return;\n            }\n            var ctx = chart.ctx;\n            var el = meta.el;\n            var view = el._view;\n            var points = el._children || [];\n            var mapper = meta.mapper;\n            var color = view.backgroundColor || defaults.global.defaultColor;\n            if (mapper && color && points.length) {\n                helpers.canvas.clipArea(ctx, chart.chartArea);\n                doFill(ctx, points, mapper, view, color, el._loop);\n                helpers.canvas.unclipArea(ctx);\n            }\n        }\n    };\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});"]}