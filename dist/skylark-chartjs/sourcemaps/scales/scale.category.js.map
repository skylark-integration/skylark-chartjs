{"version":3,"sources":["scales/scale.category.js"],"names":["define","__module__0","exports","module","Scale","__isValidToReturn","obj","Array","isArray","attr","__isEmptyObject","extend","getLabels","data","this","chart","options","labels","isHorizontal","xLabels","yLabels","determineDataLimits","findIndex","me","minIndex","maxIndex","length","undefined","ticks","min","indexOf","max","buildTicks","slice","getLabelForIndex","index","datasetIndex","getDatasetMeta","controller","_getValueScaleId","id","getRightValue","datasets","getPixelForValue","value","valueCategory","offset","offsetAmt","Math","x","y","isNaN","idx","valueWidth","width","widthOffset","left","valueHeight","height","heightOffset","top","getPixelForTick","getValueForPixel","pixel","_ticks","horz","valueDimension","round","getBasePixel","bottom","_defaults","position"],"mappings":"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","file":"../../scales/scale.category.js","sourcesContent":["define(['../core/core.scale'], function (__module__0) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var Scale = __module__0;\n    var defaultConfig = { position: 'bottom' };\n    module.exports = Scale.extend({\n        getLabels: function () {\n            var data = this.chart.data;\n            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n        },\n        determineDataLimits: function () {\n            var me = this;\n            var labels = me.getLabels();\n            me.minIndex = 0;\n            me.maxIndex = labels.length - 1;\n            var findIndex;\n            if (me.options.ticks.min !== undefined) {\n                findIndex = labels.indexOf(me.options.ticks.min);\n                me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n            }\n            if (me.options.ticks.max !== undefined) {\n                findIndex = labels.indexOf(me.options.ticks.max);\n                me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n            }\n            me.min = labels[me.minIndex];\n            me.max = labels[me.maxIndex];\n        },\n        buildTicks: function () {\n            var me = this;\n            var labels = me.getLabels();\n            me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n        },\n        getLabelForIndex: function (index, datasetIndex) {\n            var me = this;\n            var chart = me.chart;\n            if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {\n                return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);\n            }\n            return me.ticks[index - me.minIndex];\n        },\n        getPixelForValue: function (value, index) {\n            var me = this;\n            var offset = me.options.offset;\n            var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1);\n            var valueCategory;\n            if (value !== undefined && value !== null) {\n                valueCategory = me.isHorizontal() ? value.x : value.y;\n            }\n            if (valueCategory !== undefined || value !== undefined && isNaN(index)) {\n                var labels = me.getLabels();\n                value = valueCategory || value;\n                var idx = labels.indexOf(value);\n                index = idx !== -1 ? idx : index;\n            }\n            if (me.isHorizontal()) {\n                var valueWidth = me.width / offsetAmt;\n                var widthOffset = valueWidth * (index - me.minIndex);\n                if (offset) {\n                    widthOffset += valueWidth / 2;\n                }\n                return me.left + widthOffset;\n            }\n            var valueHeight = me.height / offsetAmt;\n            var heightOffset = valueHeight * (index - me.minIndex);\n            if (offset) {\n                heightOffset += valueHeight / 2;\n            }\n            return me.top + heightOffset;\n        },\n        getPixelForTick: function (index) {\n            return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n        },\n        getValueForPixel: function (pixel) {\n            var me = this;\n            var offset = me.options.offset;\n            var value;\n            var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);\n            var horz = me.isHorizontal();\n            var valueDimension = (horz ? me.width : me.height) / offsetAmt;\n            pixel -= horz ? me.left : me.top;\n            if (offset) {\n                pixel -= valueDimension / 2;\n            }\n            if (pixel <= 0) {\n                value = 0;\n            } else {\n                value = Math.round(pixel / valueDimension);\n            }\n            return value + me.minIndex;\n        },\n        getBasePixel: function () {\n            return this.bottom;\n        }\n    });\n    module.exports._defaults = defaultConfig;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});"]}