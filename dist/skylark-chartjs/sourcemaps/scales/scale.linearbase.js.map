{"version":3,"sources":["scales/scale.linearbase.js"],"names":["define","__module__0","__module__1","exports","module","helpers","Scale","noop","isNullOrUndef","__isValidToReturn","obj","Array","isArray","attr","__isEmptyObject","extend","getRightValue","value","prototype","call","this","handleTickRangeOptions","me","tickOpts","options","ticks","beginAtZero","minSign","sign","min","maxSign","max","setMin","undefined","suggestedMin","setMax","suggestedMax","Math","getTickLimit","maxTicks","stepSize","maxTicksLimit","ceil","floor","_computeTickLimit","Number","POSITIVE_INFINITY","handleDirectionalChanges","buildTicks","numericGeneratorOptions","precision","valueOrDefault","fixedStepSize","generationOptions","dataRange","factor","niceMin","niceMax","numSpaces","unit","maxNumSpaces","rmin","rmax","spacing","niceNum","pow","_decimalPlaces","almostWhole","almostEquals","round","push","j","generateTicks","reverse","start","end","convertTicksToLabels","ticksAsNumbers","slice","zeroLineIndex","indexOf"],"mappings":"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","file":"../../scales/scale.linearbase.js","sourcesContent":["define([\n    '../helpers/index',\n    '../core/core.scale'\n], function (__module__0, __module__1) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    var Scale = __module__1;\n    var noop = helpers.noop;\n    var isNullOrUndef = helpers.isNullOrUndef;\n    function generateTicks(generationOptions, dataRange) {\n        var ticks = [];\n        var MIN_SPACING = 1e-14;\n        var stepSize = generationOptions.stepSize;\n        var unit = stepSize || 1;\n        var maxNumSpaces = generationOptions.maxTicks - 1;\n        var min = generationOptions.min;\n        var max = generationOptions.max;\n        var precision = generationOptions.precision;\n        var rmin = dataRange.min;\n        var rmax = dataRange.max;\n        var spacing = helpers.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;\n        var factor, niceMin, niceMax, numSpaces;\n        if (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {\n            return [\n                rmin,\n                rmax\n            ];\n        }\n        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n        if (numSpaces > maxNumSpaces) {\n            spacing = helpers.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;\n        }\n        if (stepSize || isNullOrUndef(precision)) {\n            factor = Math.pow(10, helpers._decimalPlaces(spacing));\n        } else {\n            factor = Math.pow(10, precision);\n            spacing = Math.ceil(spacing * factor) / factor;\n        }\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n        if (stepSize) {\n            if (!isNullOrUndef(min) && helpers.almostWhole(min / spacing, spacing / 1000)) {\n                niceMin = min;\n            }\n            if (!isNullOrUndef(max) && helpers.almostWhole(max / spacing, spacing / 1000)) {\n                niceMax = max;\n            }\n        }\n        numSpaces = (niceMax - niceMin) / spacing;\n        if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n        niceMin = Math.round(niceMin * factor) / factor;\n        niceMax = Math.round(niceMax * factor) / factor;\n        ticks.push(isNullOrUndef(min) ? niceMin : min);\n        for (var j = 1; j < numSpaces; ++j) {\n            ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);\n        }\n        ticks.push(isNullOrUndef(max) ? niceMax : max);\n        return ticks;\n    }\n    module.exports = Scale.extend({\n        getRightValue: function (value) {\n            if (typeof value === 'string') {\n                return +value;\n            }\n            return Scale.prototype.getRightValue.call(this, value);\n        },\n        handleTickRangeOptions: function () {\n            var me = this;\n            var opts = me.options;\n            var tickOpts = opts.ticks;\n            if (tickOpts.beginAtZero) {\n                var minSign = helpers.sign(me.min);\n                var maxSign = helpers.sign(me.max);\n                if (minSign < 0 && maxSign < 0) {\n                    me.max = 0;\n                } else if (minSign > 0 && maxSign > 0) {\n                    me.min = 0;\n                }\n            }\n            var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n            var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n            if (tickOpts.min !== undefined) {\n                me.min = tickOpts.min;\n            } else if (tickOpts.suggestedMin !== undefined) {\n                if (me.min === null) {\n                    me.min = tickOpts.suggestedMin;\n                } else {\n                    me.min = Math.min(me.min, tickOpts.suggestedMin);\n                }\n            }\n            if (tickOpts.max !== undefined) {\n                me.max = tickOpts.max;\n            } else if (tickOpts.suggestedMax !== undefined) {\n                if (me.max === null) {\n                    me.max = tickOpts.suggestedMax;\n                } else {\n                    me.max = Math.max(me.max, tickOpts.suggestedMax);\n                }\n            }\n            if (setMin !== setMax) {\n                if (me.min >= me.max) {\n                    if (setMin) {\n                        me.max = me.min + 1;\n                    } else {\n                        me.min = me.max - 1;\n                    }\n                }\n            }\n            if (me.min === me.max) {\n                me.max++;\n                if (!tickOpts.beginAtZero) {\n                    me.min--;\n                }\n            }\n        },\n        getTickLimit: function () {\n            var me = this;\n            var tickOpts = me.options.ticks;\n            var stepSize = tickOpts.stepSize;\n            var maxTicksLimit = tickOpts.maxTicksLimit;\n            var maxTicks;\n            if (stepSize) {\n                maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\n            } else {\n                maxTicks = me._computeTickLimit();\n                maxTicksLimit = maxTicksLimit || 11;\n            }\n            if (maxTicksLimit) {\n                maxTicks = Math.min(maxTicksLimit, maxTicks);\n            }\n            return maxTicks;\n        },\n        _computeTickLimit: function () {\n            return Number.POSITIVE_INFINITY;\n        },\n        handleDirectionalChanges: noop,\n        buildTicks: function () {\n            var me = this;\n            var opts = me.options;\n            var tickOpts = opts.ticks;\n            var maxTicks = me.getTickLimit();\n            maxTicks = Math.max(2, maxTicks);\n            var numericGeneratorOptions = {\n                maxTicks: maxTicks,\n                min: tickOpts.min,\n                max: tickOpts.max,\n                precision: tickOpts.precision,\n                stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n            };\n            var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n            me.handleDirectionalChanges();\n            me.max = helpers.max(ticks);\n            me.min = helpers.min(ticks);\n            if (tickOpts.reverse) {\n                ticks.reverse();\n                me.start = me.max;\n                me.end = me.min;\n            } else {\n                me.start = me.min;\n                me.end = me.max;\n            }\n        },\n        convertTicksToLabels: function () {\n            var me = this;\n            me.ticksAsNumbers = me.ticks.slice();\n            me.zeroLineIndex = me.ticks.indexOf(0);\n            Scale.prototype.convertTicksToLabels.call(me);\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});"]}