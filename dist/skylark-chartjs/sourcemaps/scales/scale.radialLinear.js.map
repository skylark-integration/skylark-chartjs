{"version":3,"sources":["scales/scale.radialLinear.js"],"names":["define","__module__0","__module__1","__module__2","__module__3","exports","module","defaults","helpers","LinearScaleBase","Ticks","valueOrDefault","valueAtIndexOrDefault","resolve","options","defaultConfig","display","animate","position","angleLines","color","lineWidth","borderDash","borderDashOffset","gridLines","circular","ticks","showLabelBackdrop","backdropColor","backdropPaddingY","backdropPaddingX","callback","formatters","linear","pointLabels","fontSize","label","getValueCount","scale","opts","chart","data","labels","length","getTickBackdropHeight","tickOpts","global","defaultFontSize","determineLimits","angle","pos","size","min","max","start","end","getTextAlignForAngle","fillText","ctx","text","lineHeight","i","ilen","y","isArray","x","adjustPointPositionForLabelHeight","textSize","h","numberOrZero","param","isNumber","__isValidToReturn","obj","Array","attr","__isEmptyObject","extend","setDimensions","me","this","width","maxWidth","height","maxHeight","paddingTop","xCenter","Math","floor","yCenter","drawingArea","determineDataLimits","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","each","datasets","dataset","datasetIndex","isDatasetVisible","meta","getDatasetMeta","rawValue","index","value","getRightValue","isNaN","hidden","handleTickRangeOptions","_computeTickLimit","ceil","convertTicksToLabels","prototype","call","map","getLabelForIndex","fit","pointPosition","plFont","_parseFont","furthestLimits","l","r","t","b","furthestAngles","font","string","_pointLabelSizes","valueCount","getPointPosition","w","longestText","measureText","angleRadians","getIndexAngle","toDegrees","hLimits","vLimits","setReductions","fitWithPointLabels","setCenterPoint","largestPossibleRadius","radiusReductionLeft","sin","radiusReductionRight","radiusReductionTop","cos","radiusReductionBottom","leftMovement","rightMovement","topMovement","bottomMovement","maxRight","maxLeft","maxTop","maxBottom","left","top","PI","startAngle","getDistanceFromCenterForValue","scalingFactor","reverse","distanceFromCenter","thisAngle","getPointPositionForValue","getBasePosition","beginAtZero","draw","gridLineOpts","tickFont","angleLineOpts","pointLabelOpts","lineColor","tickBackdropHeight","save","strokeStyle","setLineDash","lineDashOffset","outerDistance","textBaseline","outerPosition","beginPath","moveTo","lineTo","stroke","extra","pointLabelPosition","pointLabelFontColor","fontColor","defaultFontColor","fillStyle","textAlign","restore","drawPointLabels","yCenterOffset","ticksAsNumbers","radius","arc","closePath","drawRadiusLine","tickFontColor","translate","rotate","labelWidth","fillRect","_defaults"],"mappings":"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","file":"../../scales/scale.radialLinear.js","sourcesContent":["define([\n    '../core/core.defaults',\n    '../helpers/index',\n    './scale.linearbase',\n    '../core/core.ticks'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var helpers = __module__1;\n    var LinearScaleBase = __module__2;\n    var Ticks = __module__3;\n    var valueOrDefault = helpers.valueOrDefault;\n    var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n    var resolve = helpers.options.resolve;\n    var defaultConfig = {\n        display: true,\n        animate: true,\n        position: 'chartArea',\n        angleLines: {\n            display: true,\n            color: 'rgba(0, 0, 0, 0.1)',\n            lineWidth: 1,\n            borderDash: [],\n            borderDashOffset: 0\n        },\n        gridLines: { circular: false },\n        ticks: {\n            showLabelBackdrop: true,\n            backdropColor: 'rgba(255,255,255,0.75)',\n            backdropPaddingY: 2,\n            backdropPaddingX: 2,\n            callback: Ticks.formatters.linear\n        },\n        pointLabels: {\n            display: true,\n            fontSize: 10,\n            callback: function (label) {\n                return label;\n            }\n        }\n    };\n    function getValueCount(scale) {\n        var opts = scale.options;\n        return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n    }\n    function getTickBackdropHeight(opts) {\n        var tickOpts = opts.ticks;\n        if (tickOpts.display && opts.display) {\n            return valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;\n        }\n        return 0;\n    }\n    function measureLabelSize(ctx, lineHeight, label) {\n        if (helpers.isArray(label)) {\n            return {\n                w: helpers.longestText(ctx, ctx.font, label),\n                h: label.length * lineHeight\n            };\n        }\n        return {\n            w: ctx.measureText(label).width,\n            h: lineHeight\n        };\n    }\n    function determineLimits(angle, pos, size, min, max) {\n        if (angle === min || angle === max) {\n            return {\n                start: pos - size / 2,\n                end: pos + size / 2\n            };\n        } else if (angle < min || angle > max) {\n            return {\n                start: pos - size,\n                end: pos\n            };\n        }\n        return {\n            start: pos,\n            end: pos + size\n        };\n    }\n    function fitWithPointLabels(scale) {\n        var plFont = helpers.options._parseFont(scale.options.pointLabels);\n        var furthestLimits = {\n            l: 0,\n            r: scale.width,\n            t: 0,\n            b: scale.height - scale.paddingTop\n        };\n        var furthestAngles = {};\n        var i, textSize, pointPosition;\n        scale.ctx.font = plFont.string;\n        scale._pointLabelSizes = [];\n        var valueCount = getValueCount(scale);\n        for (i = 0; i < valueCount; i++) {\n            pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\n            textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');\n            scale._pointLabelSizes[i] = textSize;\n            var angleRadians = scale.getIndexAngle(i);\n            var angle = helpers.toDegrees(angleRadians) % 360;\n            var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n            var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n            if (hLimits.start < furthestLimits.l) {\n                furthestLimits.l = hLimits.start;\n                furthestAngles.l = angleRadians;\n            }\n            if (hLimits.end > furthestLimits.r) {\n                furthestLimits.r = hLimits.end;\n                furthestAngles.r = angleRadians;\n            }\n            if (vLimits.start < furthestLimits.t) {\n                furthestLimits.t = vLimits.start;\n                furthestAngles.t = angleRadians;\n            }\n            if (vLimits.end > furthestLimits.b) {\n                furthestLimits.b = vLimits.end;\n                furthestAngles.b = angleRadians;\n            }\n        }\n        scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);\n    }\n    function getTextAlignForAngle(angle) {\n        if (angle === 0 || angle === 180) {\n            return 'center';\n        } else if (angle < 180) {\n            return 'left';\n        }\n        return 'right';\n    }\n    function fillText(ctx, text, position, lineHeight) {\n        var y = position.y + lineHeight / 2;\n        var i, ilen;\n        if (helpers.isArray(text)) {\n            for (i = 0, ilen = text.length; i < ilen; ++i) {\n                ctx.fillText(text[i], position.x, y);\n                y += lineHeight;\n            }\n        } else {\n            ctx.fillText(text, position.x, y);\n        }\n    }\n    function adjustPointPositionForLabelHeight(angle, textSize, position) {\n        if (angle === 90 || angle === 270) {\n            position.y -= textSize.h / 2;\n        } else if (angle > 270 || angle < 90) {\n            position.y -= textSize.h;\n        }\n    }\n    function drawPointLabels(scale) {\n        var ctx = scale.ctx;\n        var opts = scale.options;\n        var angleLineOpts = opts.angleLines;\n        var gridLineOpts = opts.gridLines;\n        var pointLabelOpts = opts.pointLabels;\n        var lineWidth = valueOrDefault(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\n        var lineColor = valueOrDefault(angleLineOpts.color, gridLineOpts.color);\n        var tickBackdropHeight = getTickBackdropHeight(opts);\n        ctx.save();\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = lineColor;\n        if (ctx.setLineDash) {\n            ctx.setLineDash(resolve([\n                angleLineOpts.borderDash,\n                gridLineOpts.borderDash,\n                []\n            ]));\n            ctx.lineDashOffset = resolve([\n                angleLineOpts.borderDashOffset,\n                gridLineOpts.borderDashOffset,\n                0\n            ]);\n        }\n        var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n        var plFont = helpers.options._parseFont(pointLabelOpts);\n        ctx.font = plFont.string;\n        ctx.textBaseline = 'middle';\n        for (var i = getValueCount(scale) - 1; i >= 0; i--) {\n            if (angleLineOpts.display && lineWidth && lineColor) {\n                var outerPosition = scale.getPointPosition(i, outerDistance);\n                ctx.beginPath();\n                ctx.moveTo(scale.xCenter, scale.yCenter);\n                ctx.lineTo(outerPosition.x, outerPosition.y);\n                ctx.stroke();\n            }\n            if (pointLabelOpts.display) {\n                var extra = i === 0 ? tickBackdropHeight / 2 : 0;\n                var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);\n                var pointLabelFontColor = valueAtIndexOrDefault(pointLabelOpts.fontColor, i, defaults.global.defaultFontColor);\n                ctx.fillStyle = pointLabelFontColor;\n                var angleRadians = scale.getIndexAngle(i);\n                var angle = helpers.toDegrees(angleRadians);\n                ctx.textAlign = getTextAlignForAngle(angle);\n                adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n                fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);\n            }\n        }\n        ctx.restore();\n    }\n    function drawRadiusLine(scale, gridLineOpts, radius, index) {\n        var ctx = scale.ctx;\n        var circular = gridLineOpts.circular;\n        var valueCount = getValueCount(scale);\n        var lineColor = valueAtIndexOrDefault(gridLineOpts.color, index - 1);\n        var lineWidth = valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n        var pointPosition;\n        if (!circular && !valueCount || !lineColor || !lineWidth) {\n            return;\n        }\n        ctx.save();\n        ctx.strokeStyle = lineColor;\n        ctx.lineWidth = lineWidth;\n        if (ctx.setLineDash) {\n            ctx.setLineDash(gridLineOpts.borderDash || []);\n            ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0;\n        }\n        ctx.beginPath();\n        if (circular) {\n            ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n        } else {\n            pointPosition = scale.getPointPosition(0, radius);\n            ctx.moveTo(pointPosition.x, pointPosition.y);\n            for (var i = 1; i < valueCount; i++) {\n                pointPosition = scale.getPointPosition(i, radius);\n                ctx.lineTo(pointPosition.x, pointPosition.y);\n            }\n        }\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n    function numberOrZero(param) {\n        return helpers.isNumber(param) ? param : 0;\n    }\n    module.exports = LinearScaleBase.extend({\n        setDimensions: function () {\n            var me = this;\n            me.width = me.maxWidth;\n            me.height = me.maxHeight;\n            me.paddingTop = getTickBackdropHeight(me.options) / 2;\n            me.xCenter = Math.floor(me.width / 2);\n            me.yCenter = Math.floor((me.height - me.paddingTop) / 2);\n            me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\n        },\n        determineDataLimits: function () {\n            var me = this;\n            var chart = me.chart;\n            var min = Number.POSITIVE_INFINITY;\n            var max = Number.NEGATIVE_INFINITY;\n            helpers.each(chart.data.datasets, function (dataset, datasetIndex) {\n                if (chart.isDatasetVisible(datasetIndex)) {\n                    var meta = chart.getDatasetMeta(datasetIndex);\n                    helpers.each(dataset.data, function (rawValue, index) {\n                        var value = +me.getRightValue(rawValue);\n                        if (isNaN(value) || meta.data[index].hidden) {\n                            return;\n                        }\n                        min = Math.min(value, min);\n                        max = Math.max(value, max);\n                    });\n                }\n            });\n            me.min = min === Number.POSITIVE_INFINITY ? 0 : min;\n            me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;\n            me.handleTickRangeOptions();\n        },\n        _computeTickLimit: function () {\n            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n        },\n        convertTicksToLabels: function () {\n            var me = this;\n            LinearScaleBase.prototype.convertTicksToLabels.call(me);\n            me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n        },\n        getLabelForIndex: function (index, datasetIndex) {\n            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n        },\n        fit: function () {\n            var me = this;\n            var opts = me.options;\n            if (opts.display && opts.pointLabels.display) {\n                fitWithPointLabels(me);\n            } else {\n                me.setCenterPoint(0, 0, 0, 0);\n            }\n        },\n        setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {\n            var me = this;\n            var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n            var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n            var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n            var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\n            radiusReductionLeft = numberOrZero(radiusReductionLeft);\n            radiusReductionRight = numberOrZero(radiusReductionRight);\n            radiusReductionTop = numberOrZero(radiusReductionTop);\n            radiusReductionBottom = numberOrZero(radiusReductionBottom);\n            me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n            me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n        },\n        setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {\n            var me = this;\n            var maxRight = me.width - rightMovement - me.drawingArea;\n            var maxLeft = leftMovement + me.drawingArea;\n            var maxTop = topMovement + me.drawingArea;\n            var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;\n            me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);\n            me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);\n        },\n        getIndexAngle: function (index) {\n            var angleMultiplier = Math.PI * 2 / getValueCount(this);\n            var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;\n            var startAngleRadians = startAngle * Math.PI * 2 / 360;\n            return index * angleMultiplier + startAngleRadians;\n        },\n        getDistanceFromCenterForValue: function (value) {\n            var me = this;\n            if (value === null) {\n                return 0;\n            }\n            var scalingFactor = me.drawingArea / (me.max - me.min);\n            if (me.options.ticks.reverse) {\n                return (me.max - value) * scalingFactor;\n            }\n            return (value - me.min) * scalingFactor;\n        },\n        getPointPosition: function (index, distanceFromCenter) {\n            var me = this;\n            var thisAngle = me.getIndexAngle(index) - Math.PI / 2;\n            return {\n                x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,\n                y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter\n            };\n        },\n        getPointPositionForValue: function (index, value) {\n            return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n        },\n        getBasePosition: function () {\n            var me = this;\n            var min = me.min;\n            var max = me.max;\n            return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);\n        },\n        draw: function () {\n            var me = this;\n            var opts = me.options;\n            var gridLineOpts = opts.gridLines;\n            var tickOpts = opts.ticks;\n            if (opts.display) {\n                var ctx = me.ctx;\n                var startAngle = this.getIndexAngle(0);\n                var tickFont = helpers.options._parseFont(tickOpts);\n                if (opts.angleLines.display || opts.pointLabels.display) {\n                    drawPointLabels(me);\n                }\n                helpers.each(me.ticks, function (label, index) {\n                    if (index > 0 || tickOpts.reverse) {\n                        var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n                        if (gridLineOpts.display && index !== 0) {\n                            drawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n                        }\n                        if (tickOpts.display) {\n                            var tickFontColor = valueOrDefault(tickOpts.fontColor, defaults.global.defaultFontColor);\n                            ctx.font = tickFont.string;\n                            ctx.save();\n                            ctx.translate(me.xCenter, me.yCenter);\n                            ctx.rotate(startAngle);\n                            if (tickOpts.showLabelBackdrop) {\n                                var labelWidth = ctx.measureText(label).width;\n                                ctx.fillStyle = tickOpts.backdropColor;\n                                ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);\n                            }\n                            ctx.textAlign = 'center';\n                            ctx.textBaseline = 'middle';\n                            ctx.fillStyle = tickFontColor;\n                            ctx.fillText(label, 0, -yCenterOffset);\n                            ctx.restore();\n                        }\n                    }\n                });\n            }\n        }\n    });\n    module.exports._defaults = defaultConfig;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});"]}