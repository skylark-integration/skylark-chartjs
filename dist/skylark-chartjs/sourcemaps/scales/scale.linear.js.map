{"version":3,"sources":["scales/scale.linear.js"],"names":["define","__module__0","__module__1","__module__2","exports","module","helpers","LinearScaleBase","defaultConfig","position","ticks","callback","formatters","linear","__isValidToReturn","obj","Array","isArray","attr","__isEmptyObject","extend","determineDataLimits","me","this","opts","options","chart","datasets","data","isHorizontal","IDMatches","meta","xAxisID","id","yAxisID","min","max","hasStacks","stacked","undefined","each","dataset","datasetIndex","getDatasetMeta","isDatasetVisible","stack","valuesPerStack","key","type","join","positiveValues","negativeValues","rawValue","index","value","getRightValue","isNaN","hidden","relativePoints","valuesForType","values","concat","minVal","maxVal","Math","isFinite","handleTickRangeOptions","_computeTickLimit","tickFont","ceil","width","_parseFont","height","lineHeight","handleDirectionalChanges","reverse","getLabelForIndex","getPixelForValue","start","rightValue","range","end","left","bottom","getValueForPixel","pixel","innerDimension","offset","getPixelForTick","ticksAsNumbers","_defaults"],"mappings":"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","file":"../../scales/scale.linear.js","sourcesContent":["define([\n    '../helpers/index',\n    './scale.linearbase',\n    '../core/core.ticks'\n], function (__module__0, __module__1, __module__2) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var helpers = __module__0;\n    var LinearScaleBase = __module__1;\n    var Ticks = __module__2;\n    var defaultConfig = {\n        position: 'left',\n        ticks: { callback: Ticks.formatters.linear }\n    };\n    module.exports = LinearScaleBase.extend({\n        determineDataLimits: function () {\n            var me = this;\n            var opts = me.options;\n            var chart = me.chart;\n            var data = chart.data;\n            var datasets = data.datasets;\n            var isHorizontal = me.isHorizontal();\n            var DEFAULT_MIN = 0;\n            var DEFAULT_MAX = 1;\n            function IDMatches(meta) {\n                return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n            }\n            me.min = null;\n            me.max = null;\n            var hasStacks = opts.stacked;\n            if (hasStacks === undefined) {\n                helpers.each(datasets, function (dataset, datasetIndex) {\n                    if (hasStacks) {\n                        return;\n                    }\n                    var meta = chart.getDatasetMeta(datasetIndex);\n                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n                        hasStacks = true;\n                    }\n                });\n            }\n            if (opts.stacked || hasStacks) {\n                var valuesPerStack = {};\n                helpers.each(datasets, function (dataset, datasetIndex) {\n                    var meta = chart.getDatasetMeta(datasetIndex);\n                    var key = [\n                        meta.type,\n                        opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '',\n                        meta.stack\n                    ].join('.');\n                    if (valuesPerStack[key] === undefined) {\n                        valuesPerStack[key] = {\n                            positiveValues: [],\n                            negativeValues: []\n                        };\n                    }\n                    var positiveValues = valuesPerStack[key].positiveValues;\n                    var negativeValues = valuesPerStack[key].negativeValues;\n                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n                        helpers.each(dataset.data, function (rawValue, index) {\n                            var value = +me.getRightValue(rawValue);\n                            if (isNaN(value) || meta.data[index].hidden) {\n                                return;\n                            }\n                            positiveValues[index] = positiveValues[index] || 0;\n                            negativeValues[index] = negativeValues[index] || 0;\n                            if (opts.relativePoints) {\n                                positiveValues[index] = 100;\n                            } else if (value < 0) {\n                                negativeValues[index] += value;\n                            } else {\n                                positiveValues[index] += value;\n                            }\n                        });\n                    }\n                });\n                helpers.each(valuesPerStack, function (valuesForType) {\n                    var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n                    var minVal = helpers.min(values);\n                    var maxVal = helpers.max(values);\n                    me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n                    me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n                });\n            } else {\n                helpers.each(datasets, function (dataset, datasetIndex) {\n                    var meta = chart.getDatasetMeta(datasetIndex);\n                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n                        helpers.each(dataset.data, function (rawValue, index) {\n                            var value = +me.getRightValue(rawValue);\n                            if (isNaN(value) || meta.data[index].hidden) {\n                                return;\n                            }\n                            if (me.min === null) {\n                                me.min = value;\n                            } else if (value < me.min) {\n                                me.min = value;\n                            }\n                            if (me.max === null) {\n                                me.max = value;\n                            } else if (value > me.max) {\n                                me.max = value;\n                            }\n                        });\n                    }\n                });\n            }\n            me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n            me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\n            this.handleTickRangeOptions();\n        },\n        _computeTickLimit: function () {\n            var me = this;\n            var tickFont;\n            if (me.isHorizontal()) {\n                return Math.ceil(me.width / 40);\n            }\n            tickFont = helpers.options._parseFont(me.options.ticks);\n            return Math.ceil(me.height / tickFont.lineHeight);\n        },\n        handleDirectionalChanges: function () {\n            if (!this.isHorizontal()) {\n                this.ticks.reverse();\n            }\n        },\n        getLabelForIndex: function (index, datasetIndex) {\n            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n        },\n        getPixelForValue: function (value) {\n            var me = this;\n            var start = me.start;\n            var rightValue = +me.getRightValue(value);\n            var pixel;\n            var range = me.end - start;\n            if (me.isHorizontal()) {\n                pixel = me.left + me.width / range * (rightValue - start);\n            } else {\n                pixel = me.bottom - me.height / range * (rightValue - start);\n            }\n            return pixel;\n        },\n        getValueForPixel: function (pixel) {\n            var me = this;\n            var isHorizontal = me.isHorizontal();\n            var innerDimension = isHorizontal ? me.width : me.height;\n            var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n            return me.start + (me.end - me.start) * offset;\n        },\n        getPixelForTick: function (index) {\n            return this.getPixelForValue(this.ticksAsNumbers[index]);\n        }\n    });\n    module.exports._defaults = defaultConfig;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});"]}