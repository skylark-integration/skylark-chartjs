{"version":3,"sources":["controllers/controller.bar.js"],"names":["define","__module__0","__module__1","__module__2","__module__3","exports","module","DatasetController","defaults","elements","helpers","resolve","options","__isValidToReturn","obj","Array","isArray","attr","__isEmptyObject","_set","hover","mode","scales","xAxes","type","categoryPercentage","barPercentage","offset","gridLines","offsetGridLines","yAxes","extend","dataElementType","Rectangle","initialize","meta","prototype","apply","this","arguments","getMeta","stack","getDataset","bar","update","reset","i","ilen","rects","data","_ruler","getRuler","length","updateElement","rectangle","index","me","dataset","_resolveElementOptions","_xScale","getScaleForId","xAxisID","_yScale","yAxisID","_datasetIndex","_index","_model","backgroundColor","borderColor","borderSkipped","borderWidth","datasetLabel","label","chart","labels","_updateElementGeometry","pivot","model","vscale","_getValueScale","base","getBasePixel","horizontal","isHorizontal","ruler","vpixels","calculateBarValuePixels","ipixels","calculateBarIndexPixels","x","head","center","y","height","size","undefined","width","_getStacks","last","stacked","_getIndexScale","datasets","stacks","getDatasetMeta","isDatasetVisible","indexOf","push","getStackCount","getStackIndex","datasetIndex","name","scale","stackCount","start","left","top","end","pixels","getPixelForValue","min","isNullOrUndef","barThickness","prev","curr","ticks","getTicks","Math","abs","getPixelForTick","computeMinSampleSize","imeta","ivalue","value","getRightValue","minBarLength","controller","_getValueScaleId","id","range","next","percent","chunk","ratio","computeFlexCategoryTraits","thickness","count","computeFitCategoryTraits","stackIndex","valueOrDefault","maxBarThickness","Infinity","draw","canvas","clipArea","ctx","chartArea","isNaN","unclipArea","key","custom","values","context","dataIndex","keys"],"mappings":"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","file":"../../controllers/controller.bar.js","sourcesContent":["define([\n    '../core/core.datasetController',\n    '../core/core.defaults',\n    '../elements/index',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var DatasetController = __module__0;\n    var defaults = __module__1;\n    var elements = __module__2;\n    var helpers = __module__3;\n    var resolve = helpers.options.resolve;\n    defaults._set('bar', {\n        hover: { mode: 'label' },\n        scales: {\n            xAxes: [{\n                    type: 'category',\n                    categoryPercentage: 0.8,\n                    barPercentage: 0.9,\n                    offset: true,\n                    gridLines: { offsetGridLines: true }\n                }],\n            yAxes: [{ type: 'linear' }]\n        }\n    });\n    function computeMinSampleSize(scale, pixels) {\n        var min = scale.isHorizontal() ? scale.width : scale.height;\n        var ticks = scale.getTicks();\n        var prev, curr, i, ilen;\n        for (i = 1, ilen = pixels.length; i < ilen; ++i) {\n            min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));\n        }\n        for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n            curr = scale.getPixelForTick(i);\n            min = i > 0 ? Math.min(min, curr - prev) : min;\n            prev = curr;\n        }\n        return min;\n    }\n    function computeFitCategoryTraits(index, ruler, options) {\n        var thickness = options.barThickness;\n        var count = ruler.stackCount;\n        var curr = ruler.pixels[index];\n        var size, ratio;\n        if (helpers.isNullOrUndef(thickness)) {\n            size = ruler.min * options.categoryPercentage;\n            ratio = options.barPercentage;\n        } else {\n            size = thickness * count;\n            ratio = 1;\n        }\n        return {\n            chunk: size / count,\n            ratio: ratio,\n            start: curr - size / 2\n        };\n    }\n    function computeFlexCategoryTraits(index, ruler, options) {\n        var pixels = ruler.pixels;\n        var curr = pixels[index];\n        var prev = index > 0 ? pixels[index - 1] : null;\n        var next = index < pixels.length - 1 ? pixels[index + 1] : null;\n        var percent = options.categoryPercentage;\n        var start, size;\n        if (prev === null) {\n            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n        }\n        if (next === null) {\n            next = curr + curr - prev;\n        }\n        start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n        size = Math.abs(next - prev) / 2 * percent;\n        return {\n            chunk: size / ruler.stackCount,\n            ratio: options.barPercentage,\n            start: start\n        };\n    }\n    module.exports = DatasetController.extend({\n        dataElementType: elements.Rectangle,\n        initialize: function () {\n            var me = this;\n            var meta;\n            DatasetController.prototype.initialize.apply(me, arguments);\n            meta = me.getMeta();\n            meta.stack = me.getDataset().stack;\n            meta.bar = true;\n        },\n        update: function (reset) {\n            var me = this;\n            var rects = me.getMeta().data;\n            var i, ilen;\n            me._ruler = me.getRuler();\n            for (i = 0, ilen = rects.length; i < ilen; ++i) {\n                me.updateElement(rects[i], i, reset);\n            }\n        },\n        updateElement: function (rectangle, index, reset) {\n            var me = this;\n            var meta = me.getMeta();\n            var dataset = me.getDataset();\n            var options = me._resolveElementOptions(rectangle, index);\n            rectangle._xScale = me.getScaleForId(meta.xAxisID);\n            rectangle._yScale = me.getScaleForId(meta.yAxisID);\n            rectangle._datasetIndex = me.index;\n            rectangle._index = index;\n            rectangle._model = {\n                backgroundColor: options.backgroundColor,\n                borderColor: options.borderColor,\n                borderSkipped: options.borderSkipped,\n                borderWidth: options.borderWidth,\n                datasetLabel: dataset.label,\n                label: me.chart.data.labels[index]\n            };\n            me._updateElementGeometry(rectangle, index, reset);\n            rectangle.pivot();\n        },\n        _updateElementGeometry: function (rectangle, index, reset) {\n            var me = this;\n            var model = rectangle._model;\n            var vscale = me._getValueScale();\n            var base = vscale.getBasePixel();\n            var horizontal = vscale.isHorizontal();\n            var ruler = me._ruler || me.getRuler();\n            var vpixels = me.calculateBarValuePixels(me.index, index);\n            var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n            model.horizontal = horizontal;\n            model.base = reset ? base : vpixels.base;\n            model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n            model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n            model.height = horizontal ? ipixels.size : undefined;\n            model.width = horizontal ? undefined : ipixels.size;\n        },\n        _getStacks: function (last) {\n            var me = this;\n            var chart = me.chart;\n            var scale = me._getIndexScale();\n            var stacked = scale.options.stacked;\n            var ilen = last === undefined ? chart.data.datasets.length : last + 1;\n            var stacks = [];\n            var i, meta;\n            for (i = 0; i < ilen; ++i) {\n                meta = chart.getDatasetMeta(i);\n                if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {\n                    stacks.push(meta.stack);\n                }\n            }\n            return stacks;\n        },\n        getStackCount: function () {\n            return this._getStacks().length;\n        },\n        getStackIndex: function (datasetIndex, name) {\n            var stacks = this._getStacks(datasetIndex);\n            var index = name !== undefined ? stacks.indexOf(name) : -1;\n            return index === -1 ? stacks.length - 1 : index;\n        },\n        getRuler: function () {\n            var me = this;\n            var scale = me._getIndexScale();\n            var stackCount = me.getStackCount();\n            var datasetIndex = me.index;\n            var isHorizontal = scale.isHorizontal();\n            var start = isHorizontal ? scale.left : scale.top;\n            var end = start + (isHorizontal ? scale.width : scale.height);\n            var pixels = [];\n            var i, ilen, min;\n            for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n                pixels.push(scale.getPixelForValue(null, i, datasetIndex));\n            }\n            min = helpers.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;\n            return {\n                min: min,\n                pixels: pixels,\n                start: start,\n                end: end,\n                stackCount: stackCount,\n                scale: scale\n            };\n        },\n        calculateBarValuePixels: function (datasetIndex, index) {\n            var me = this;\n            var chart = me.chart;\n            var meta = me.getMeta();\n            var scale = me._getValueScale();\n            var isHorizontal = scale.isHorizontal();\n            var datasets = chart.data.datasets;\n            var value = +scale.getRightValue(datasets[datasetIndex].data[index]);\n            var minBarLength = scale.options.minBarLength;\n            var stacked = scale.options.stacked;\n            var stack = meta.stack;\n            var start = 0;\n            var i, imeta, ivalue, base, head, size;\n            if (stacked || stacked === undefined && stack !== undefined) {\n                for (i = 0; i < datasetIndex; ++i) {\n                    imeta = chart.getDatasetMeta(i);\n                    if (imeta.bar && imeta.stack === stack && imeta.controller._getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {\n                        ivalue = +scale.getRightValue(datasets[i].data[index]);\n                        if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {\n                            start += ivalue;\n                        }\n                    }\n                }\n            }\n            base = scale.getPixelForValue(start);\n            head = scale.getPixelForValue(start + value);\n            size = head - base;\n            if (minBarLength !== undefined && Math.abs(size) < minBarLength) {\n                size = minBarLength;\n                if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {\n                    head = base - minBarLength;\n                } else {\n                    head = base + minBarLength;\n                }\n            }\n            return {\n                size: size,\n                base: base,\n                head: head,\n                center: head + size / 2\n            };\n        },\n        calculateBarIndexPixels: function (datasetIndex, index, ruler) {\n            var me = this;\n            var options = ruler.scale.options;\n            var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);\n            var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n            var center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            var size = Math.min(helpers.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);\n            return {\n                base: center - size / 2,\n                head: center + size / 2,\n                center: center,\n                size: size\n            };\n        },\n        draw: function () {\n            var me = this;\n            var chart = me.chart;\n            var scale = me._getValueScale();\n            var rects = me.getMeta().data;\n            var dataset = me.getDataset();\n            var ilen = rects.length;\n            var i = 0;\n            helpers.canvas.clipArea(chart.ctx, chart.chartArea);\n            for (; i < ilen; ++i) {\n                if (!isNaN(scale.getRightValue(dataset.data[i]))) {\n                    rects[i].draw();\n                }\n            }\n            helpers.canvas.unclipArea(chart.ctx);\n        },\n        _resolveElementOptions: function (rectangle, index) {\n            var me = this;\n            var chart = me.chart;\n            var datasets = chart.data.datasets;\n            var dataset = datasets[me.index];\n            var custom = rectangle.custom || {};\n            var options = chart.options.elements.rectangle;\n            var values = {};\n            var i, ilen, key;\n            var context = {\n                chart: chart,\n                dataIndex: index,\n                dataset: dataset,\n                datasetIndex: me.index\n            };\n            var keys = [\n                'backgroundColor',\n                'borderColor',\n                'borderSkipped',\n                'borderWidth'\n            ];\n            for (i = 0, ilen = keys.length; i < ilen; ++i) {\n                key = keys[i];\n                values[key] = resolve([\n                    custom[key],\n                    dataset[key],\n                    options[key]\n                ], context, index);\n            }\n            return values;\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});"]}