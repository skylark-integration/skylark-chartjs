{"version":3,"sources":["controllers/controller.line.js"],"names":["define","__module__0","__module__1","__module__2","__module__3","exports","module","DatasetController","defaults","elements","helpers","valueOrDefault","resolve","options","isPointInArea","canvas","_isPointInArea","lineEnabled","dataset","showLine","showLines","__isValidToReturn","obj","Array","isArray","attr","__isEmptyObject","_set","spanGaps","hover","mode","scales","xAxes","type","id","yAxes","extend","datasetElementType","Line","dataElementType","Point","update","reset","i","ilen","me","this","meta","getMeta","line","points","data","scale","getScaleForId","yAxisID","getDataset","chart","undefined","tension","lineTension","_scale","_datasetIndex","index","_children","_model","_resolveLineOptions","pivot","length","updateElement","updateBezierControlPoints","point","x","y","custom","datasetIndex","value","yScale","xScale","xAxisID","lineModel","_resolvePointOptions","getPixelForValue","NaN","getBasePixel","calculatePointY","_xScale","_yScale","_options","_index","skip","isNaN","radius","pointStyle","rotation","backgroundColor","borderColor","borderWidth","steppedLine","hitRadius","element","key","datasets","values","context","dataIndex","ELEMENT_OPTIONS","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth","hoverRadius","keys","Object","elementOptions","stepped","ds","dsMeta","sumPos","sumNeg","stacked","getDatasetMeta","isDatasetVisible","stackedRightValue","Number","getRightValue","rightValue","model","controlPoints","area","chartArea","capControlPoint","pt","min","max","Math","filter","cubicInterpolationMode","splineCurveMonotone","splineCurve","previousItem","nextItem","controlPointPreviousX","previous","controlPointPreviousY","controlPointNextX","next","controlPointNextY","capBezierPoints","left","right","top","bottom","draw","halfBorderWidth","clipArea","ctx","unclipArea","setHoverStyle","getHoverColor","$previousStyle"],"mappings":";;;;;;;AAAAA,QACI,iCACA,wBACA,oBACA,oBACD,SAAUC,EAAaC,EAAaC,EAAaC,GAChD,aACA,IAAIC,WACAC,QAAWD,YACXE,EAAoBN,EACpBO,EAAWN,EACXO,EAAWN,EACXO,EAAUN,EACVO,EAAiBD,EAAQC,eACzBC,EAAUF,EAAQG,QAAQD,QAC1BE,EAAgBJ,EAAQK,OAAOC,eAgBnC,SAASC,EAAYC,EAASL,GAC1B,OAAOF,EAAeO,EAAQC,SAAUN,EAAQO,WAuQpD,SAASC,EAAkBC,GACvB,MAAqB,iBAAPA,GAAmBC,MAAMC,QAAQF,KAPnD,SAAyBA,GACrB,IAAIG,EACJ,IAAKA,KAAQH,EACT,OAAO,EACX,OAAO,EAGiDI,CAAgBJ,GAE5E,OA1RAd,EAASmB,KAAK,QACVP,WAAW,EACXQ,UAAU,EACVC,OAASC,KAAM,SACfC,QACIC,QACQC,KAAM,WACNC,GAAI,aAEZC,QACQF,KAAM,SACNC,GAAI,gBAOpB5B,OAAOD,QAAUE,EAAkB6B,QAC/BC,mBAAoB5B,EAAS6B,KAC7BC,gBAAiB9B,EAAS+B,MAC1BC,OAAQ,SAAUC,GACd,IAOIC,EAAGC,EAPHC,EAAKC,KACLC,EAAOF,EAAGG,UACVC,EAAOF,EAAK7B,QACZgC,EAASH,EAAKI,SACdC,EAAQP,EAAGQ,cAAcN,EAAKO,SAC9BpC,EAAU2B,EAAGU,aACbpC,EAAWF,EAAYC,EAAS2B,EAAGW,MAAM3C,SAY7C,IAVIM,SACwBsC,IAApBvC,EAAQwC,cAAiDD,IAAxBvC,EAAQyC,cACzCzC,EAAQyC,YAAczC,EAAQwC,SAElCT,EAAKW,OAASR,EACdH,EAAKY,cAAgBhB,EAAGiB,MACxBb,EAAKc,UAAYb,EACjBD,EAAKe,OAASnB,EAAGoB,oBAAoBhB,GACrCA,EAAKiB,SAEJvB,EAAI,EAAGC,EAAOM,EAAOiB,OAAQxB,EAAIC,IAAQD,EAC1CE,EAAGuB,cAAclB,EAAOP,GAAIA,EAAGD,GAKnC,IAHIvB,GAAoC,IAAxB8B,EAAKe,OAAON,SACxBb,EAAGwB,4BAEF1B,EAAI,EAAGC,EAAOM,EAAOiB,OAAQxB,EAAIC,IAAQD,EAC1CO,EAAOP,GAAGuB,SAGlBE,cAAe,SAAUE,EAAOR,EAAOpB,GACnC,IASI6B,EAAGC,EATH3B,EAAKC,KACLC,EAAOF,EAAGG,UACVyB,EAASH,EAAMG,WACfvD,EAAU2B,EAAGU,aACbmB,EAAe7B,EAAGiB,MAClBa,EAAQzD,EAAQiC,KAAKW,GACrBc,EAAS/B,EAAGQ,cAAcN,EAAKO,SAC/BuB,EAAShC,EAAGQ,cAAcN,EAAK+B,SAC/BC,EAAYhC,EAAK7B,QAAQ8C,OAEzBnD,EAAUgC,EAAGmC,qBAAqBV,EAAOR,GAC7CS,EAAIM,EAAOI,iBAAkC,iBAAVN,EAAqBA,EAAQO,IAAKpB,EAAOY,GAC5EF,EAAI9B,EAAQkC,EAAOO,eAAiBtC,EAAGuC,gBAAgBT,EAAOb,EAAOY,GACrEJ,EAAMe,QAAUR,EAChBP,EAAMgB,QAAUV,EAChBN,EAAMiB,SAAW1E,EACjByD,EAAMT,cAAgBa,EACtBJ,EAAMkB,OAAS1B,EACfQ,EAAMN,QACFO,EAAGA,EACHC,EAAGA,EACHiB,KAAMhB,EAAOgB,MAAQC,MAAMnB,IAAMmB,MAAMlB,GACvCmB,OAAQ9E,EAAQ8E,OAChBC,WAAY/E,EAAQ+E,WACpBC,SAAUhF,EAAQgF,SAClBC,gBAAiBjF,EAAQiF,gBACzBC,YAAalF,EAAQkF,YACrBC,YAAanF,EAAQmF,YACrBtC,QAAS/C,EAAe8D,EAAOf,QAASqB,EAAYA,EAAUrB,QAAU,GACxEuC,cAAalB,GAAYA,EAAUkB,YACnCC,UAAWrF,EAAQqF,YAG3BlB,qBAAsB,SAAUmB,EAASrC,GACrC,IAMInB,EAAGC,EAAMwD,EALT5C,EADKV,KACMU,MACXtC,EAAUsC,EAAML,KAAKkD,SAFhBvD,KAE4BgB,OACjCW,EAAS0B,EAAQ1B,WACjB5D,EAAU2C,EAAM3C,QAAQJ,SAAS6D,MACjCgC,KAEAC,GACA/C,MAAOA,EACPgD,UAAW1C,EACX5C,QAASA,EACTwD,aAXK5B,KAWYgB,OAEjB2C,GACAX,gBAAiB,uBACjBC,YAAa,mBACbC,YAAa,mBACbE,UAAW,iBACXQ,qBAAsB,4BACtBC,iBAAkB,wBAClBC,iBAAkB,wBAClBC,YAAa,mBACbjB,WAAY,aACZD,OAAQ,cACRE,SAAU,iBAEViB,EAAOC,OAAOD,KAAKL,GACvB,IAAK9D,EAAI,EAAGC,EAAOkE,EAAK3C,OAAQxB,EAAIC,IAAQD,EAExC2D,EADAF,EAAMU,EAAKnE,IACG/B,GACV6D,EAAO2B,GACPlF,EAAQuF,EAAgBL,IACxBlF,EAAQkF,GACRvF,EAAQuF,IACTG,EAASzC,GAEhB,OAAOwC,GAEXrC,oBAAqB,SAAUkC,GAC3B,IAOIxD,EAAGC,EAAMwD,EANT5C,EADKV,KACMU,MACXtC,EAAUsC,EAAML,KAAKkD,SAFhBvD,KAE4BgB,OACjCW,EAAS0B,EAAQ1B,WACjB5D,EAAU2C,EAAM3C,QAChBmG,EAAiBnG,EAAQJ,SAASwC,KAClCqD,KAEAQ,GACA,kBACA,cACA,cACA,iBACA,aACA,mBACA,kBACA,OACA,0BAEJ,IAAKnE,EAAI,EAAGC,EAAOkE,EAAK3C,OAAQxB,EAAIC,IAAQD,EAExC2D,EADAF,EAAMU,EAAKnE,IACG/B,GACV6D,EAAO2B,GACPlF,EAAQkF,GACRY,EAAeZ,KAUvB,OAPAE,EAAO1E,SAAWjB,EAAeO,EAAQU,SAAUf,EAAQe,UAC3D0E,EAAO5C,QAAU/C,EAAeO,EAAQyC,YAAaqD,EAAetD,SACpE4C,EAAOL,YAAcrF,GACjB6D,EAAOwB,YACP/E,EAAQ+E,YACRe,EAAeC,UAEZX,GAEXlB,gBAAiB,SAAUT,EAAOb,EAAOY,GACrC,IAMI/B,EAAGuE,EAAIC,EALP3D,EADKV,KACMU,MACXT,EAFKD,KAEKE,UACV4B,EAHK9B,KAGOO,cAAcN,EAAKO,SAC/B8D,EAAS,EACTC,EAAS,EAEb,GAAIzC,EAAO/D,QAAQyG,QAAS,CACxB,IAAK3E,EAAI,EAAGA,EAAI+B,EAAc/B,IAG1B,GAFAuE,EAAK1D,EAAML,KAAKkD,SAAS1D,GAEL,UADpBwE,EAAS3D,EAAM+D,eAAe5E,IACnBV,MAAmBkF,EAAO7D,UAAYsB,EAAO1C,IAAMsB,EAAMgE,iBAAiB7E,GAAI,CACrF,IAAI8E,EAAoBC,OAAO9C,EAAO+C,cAAcT,EAAG/D,KAAKW,KACxD2D,EAAoB,EACpBJ,GAAUI,GAAqB,EAE/BL,GAAUK,GAAqB,EAI3C,IAAIG,EAAaF,OAAO9C,EAAO+C,cAAchD,IAC7C,OAAIiD,EAAa,EACNhD,EAAOK,iBAAiBoC,EAASO,GAErChD,EAAOK,iBAAiBmC,EAASQ,GAE5C,OAAOhD,EAAOK,iBAAiBN,IAEnCN,0BAA2B,WACvB,IAMI1B,EAAGC,EAAMiF,EAAOC,EALhBtE,EADKV,KACMU,MACXT,EAFKD,KAEKE,UACV+B,EAAYhC,EAAK7B,QAAQ8C,OACzB+D,EAAOvE,EAAMwE,UACb9E,EAASH,EAAKI,SAOlB,SAAS8E,EAAgBC,EAAIC,EAAKC,GAC9B,OAAOC,KAAKD,IAAIC,KAAKF,IAAID,EAAIE,GAAMD,GAEvC,GARIpD,EAAUnD,WACVsB,EAASA,EAAOoF,OAAO,SAAUJ,GAC7B,OAAQA,EAAGlE,OAAOyB,QAMe,aAArCV,EAAUwD,uBACV7H,EAAQ8H,oBAAoBtF,QAE5B,IAAKP,EAAI,EAAGC,EAAOM,EAAOiB,OAAQxB,EAAIC,IAAQD,EAC1CkF,EAAQ3E,EAAOP,GAAGqB,OAClB8D,EAAgBpH,EAAQ+H,YAAY/H,EAAQgI,aAAaxF,EAAQP,GAAGqB,OAAQ6D,EAAOnH,EAAQiI,SAASzF,EAAQP,GAAGqB,OAAQe,EAAUrB,SACjImE,EAAMe,sBAAwBd,EAAce,SAAStE,EACrDsD,EAAMiB,sBAAwBhB,EAAce,SAASrE,EACrDqD,EAAMkB,kBAAoBjB,EAAckB,KAAKzE,EAC7CsD,EAAMoB,kBAAoBnB,EAAckB,KAAKxE,EAGrD,GAAIhB,EAAM3C,QAAQJ,SAASwC,KAAKiG,gBAC5B,IAAKvG,EAAI,EAAGC,EAAOM,EAAOiB,OAAQxB,EAAIC,IAAQD,EAC1CkF,EAAQ3E,EAAOP,GAAGqB,OACdlD,EAAc+G,EAAOE,KACjBpF,EAAI,GAAK7B,EAAcoC,EAAOP,EAAI,GAAGqB,OAAQ+D,KAC7CF,EAAMe,sBAAwBX,EAAgBJ,EAAMe,sBAAuBb,EAAKoB,KAAMpB,EAAKqB,OAC3FvB,EAAMiB,sBAAwBb,EAAgBJ,EAAMiB,sBAAuBf,EAAKsB,IAAKtB,EAAKuB,SAE1F3G,EAAIO,EAAOiB,OAAS,GAAKrD,EAAcoC,EAAOP,EAAI,GAAGqB,OAAQ+D,KAC7DF,EAAMkB,kBAAoBd,EAAgBJ,EAAMkB,kBAAmBhB,EAAKoB,KAAMpB,EAAKqB,OACnFvB,EAAMoB,kBAAoBhB,EAAgBJ,EAAMoB,kBAAmBlB,EAAKsB,IAAKtB,EAAKuB,WAMtGC,KAAM,WACF,IAMIC,EALAhG,EADKV,KACMU,MACXT,EAFKD,KAEKE,UACVE,EAASH,EAAKI,SACd4E,EAAOvE,EAAMwE,UACbpF,EAAOM,EAAOiB,OAEdxB,EAAI,EAYR,IAXI1B,EARK6B,KAQUS,aAAcC,EAAM3C,WACnC2I,GAAmBzG,EAAK7B,QAAQ8C,OAAOgC,aAAe,GAAK,EAC3DtF,EAAQK,OAAO0I,SAASjG,EAAMkG,KAC1BP,KAAMpB,EAAKoB,KACXC,MAAOrB,EAAKqB,MACZC,IAAKtB,EAAKsB,IAAMG,EAChBF,OAAQvB,EAAKuB,OAASE,IAE1BzG,EAAK7B,QAAQqI,OACb7I,EAAQK,OAAO4I,WAAWnG,EAAMkG,MAE7B/G,EAAIC,IAAQD,EACfO,EAAOP,GAAG4G,KAAKxB,IAGvB6B,cAAe,SAAUtF,GACrB,IAAIuD,EAAQvD,EAAMN,OACdnD,EAAUyD,EAAMiB,SAChBsE,EAAgBnJ,EAAQmJ,cAC5BvF,EAAMwF,gBACFhE,gBAAiB+B,EAAM/B,gBACvBC,YAAa8B,EAAM9B,YACnBC,YAAa6B,EAAM7B,YACnBL,OAAQkC,EAAMlC,QAElBkC,EAAM/B,gBAAkBnF,EAAeE,EAAQ6F,qBAAsBmD,EAAchJ,EAAQiF,kBAC3F+B,EAAM9B,YAAcpF,EAAeE,EAAQ8F,iBAAkBkD,EAAchJ,EAAQkF,cACnF8B,EAAM7B,YAAcrF,EAAeE,EAAQ+F,iBAAkB/F,EAAQmF,aACrE6B,EAAMlC,OAAShF,EAAeE,EAAQgG,YAAahG,EAAQ8E,WAY/DtE,EAAkBf,OAAOD,SAClBC,OAAOD,QACTgB,EAAkBhB,SAChBA,aADN","file":"../../controllers/controller.line.js","sourcesContent":["define([\n    '../core/core.datasetController',\n    '../core/core.defaults',\n    '../elements/index',\n    '../helpers/index'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var DatasetController = __module__0;\n    var defaults = __module__1;\n    var elements = __module__2;\n    var helpers = __module__3;\n    var valueOrDefault = helpers.valueOrDefault;\n    var resolve = helpers.options.resolve;\n    var isPointInArea = helpers.canvas._isPointInArea;\n    defaults._set('line', {\n        showLines: true,\n        spanGaps: false,\n        hover: { mode: 'label' },\n        scales: {\n            xAxes: [{\n                    type: 'category',\n                    id: 'x-axis-0'\n                }],\n            yAxes: [{\n                    type: 'linear',\n                    id: 'y-axis-0'\n                }]\n        }\n    });\n    function lineEnabled(dataset, options) {\n        return valueOrDefault(dataset.showLine, options.showLines);\n    }\n    module.exports = DatasetController.extend({\n        datasetElementType: elements.Line,\n        dataElementType: elements.Point,\n        update: function (reset) {\n            var me = this;\n            var meta = me.getMeta();\n            var line = meta.dataset;\n            var points = meta.data || [];\n            var scale = me.getScaleForId(meta.yAxisID);\n            var dataset = me.getDataset();\n            var showLine = lineEnabled(dataset, me.chart.options);\n            var i, ilen;\n            if (showLine) {\n                if (dataset.tension !== undefined && dataset.lineTension === undefined) {\n                    dataset.lineTension = dataset.tension;\n                }\n                line._scale = scale;\n                line._datasetIndex = me.index;\n                line._children = points;\n                line._model = me._resolveLineOptions(line);\n                line.pivot();\n            }\n            for (i = 0, ilen = points.length; i < ilen; ++i) {\n                me.updateElement(points[i], i, reset);\n            }\n            if (showLine && line._model.tension !== 0) {\n                me.updateBezierControlPoints();\n            }\n            for (i = 0, ilen = points.length; i < ilen; ++i) {\n                points[i].pivot();\n            }\n        },\n        updateElement: function (point, index, reset) {\n            var me = this;\n            var meta = me.getMeta();\n            var custom = point.custom || {};\n            var dataset = me.getDataset();\n            var datasetIndex = me.index;\n            var value = dataset.data[index];\n            var yScale = me.getScaleForId(meta.yAxisID);\n            var xScale = me.getScaleForId(meta.xAxisID);\n            var lineModel = meta.dataset._model;\n            var x, y;\n            var options = me._resolvePointOptions(point, index);\n            x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n            y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n            point._xScale = xScale;\n            point._yScale = yScale;\n            point._options = options;\n            point._datasetIndex = datasetIndex;\n            point._index = index;\n            point._model = {\n                x: x,\n                y: y,\n                skip: custom.skip || isNaN(x) || isNaN(y),\n                radius: options.radius,\n                pointStyle: options.pointStyle,\n                rotation: options.rotation,\n                backgroundColor: options.backgroundColor,\n                borderColor: options.borderColor,\n                borderWidth: options.borderWidth,\n                tension: valueOrDefault(custom.tension, lineModel ? lineModel.tension : 0),\n                steppedLine: lineModel ? lineModel.steppedLine : false,\n                hitRadius: options.hitRadius\n            };\n        },\n        _resolvePointOptions: function (element, index) {\n            var me = this;\n            var chart = me.chart;\n            var dataset = chart.data.datasets[me.index];\n            var custom = element.custom || {};\n            var options = chart.options.elements.point;\n            var values = {};\n            var i, ilen, key;\n            var context = {\n                chart: chart,\n                dataIndex: index,\n                dataset: dataset,\n                datasetIndex: me.index\n            };\n            var ELEMENT_OPTIONS = {\n                backgroundColor: 'pointBackgroundColor',\n                borderColor: 'pointBorderColor',\n                borderWidth: 'pointBorderWidth',\n                hitRadius: 'pointHitRadius',\n                hoverBackgroundColor: 'pointHoverBackgroundColor',\n                hoverBorderColor: 'pointHoverBorderColor',\n                hoverBorderWidth: 'pointHoverBorderWidth',\n                hoverRadius: 'pointHoverRadius',\n                pointStyle: 'pointStyle',\n                radius: 'pointRadius',\n                rotation: 'pointRotation'\n            };\n            var keys = Object.keys(ELEMENT_OPTIONS);\n            for (i = 0, ilen = keys.length; i < ilen; ++i) {\n                key = keys[i];\n                values[key] = resolve([\n                    custom[key],\n                    dataset[ELEMENT_OPTIONS[key]],\n                    dataset[key],\n                    options[key]\n                ], context, index);\n            }\n            return values;\n        },\n        _resolveLineOptions: function (element) {\n            var me = this;\n            var chart = me.chart;\n            var dataset = chart.data.datasets[me.index];\n            var custom = element.custom || {};\n            var options = chart.options;\n            var elementOptions = options.elements.line;\n            var values = {};\n            var i, ilen, key;\n            var keys = [\n                'backgroundColor',\n                'borderWidth',\n                'borderColor',\n                'borderCapStyle',\n                'borderDash',\n                'borderDashOffset',\n                'borderJoinStyle',\n                'fill',\n                'cubicInterpolationMode'\n            ];\n            for (i = 0, ilen = keys.length; i < ilen; ++i) {\n                key = keys[i];\n                values[key] = resolve([\n                    custom[key],\n                    dataset[key],\n                    elementOptions[key]\n                ]);\n            }\n            values.spanGaps = valueOrDefault(dataset.spanGaps, options.spanGaps);\n            values.tension = valueOrDefault(dataset.lineTension, elementOptions.tension);\n            values.steppedLine = resolve([\n                custom.steppedLine,\n                dataset.steppedLine,\n                elementOptions.stepped\n            ]);\n            return values;\n        },\n        calculatePointY: function (value, index, datasetIndex) {\n            var me = this;\n            var chart = me.chart;\n            var meta = me.getMeta();\n            var yScale = me.getScaleForId(meta.yAxisID);\n            var sumPos = 0;\n            var sumNeg = 0;\n            var i, ds, dsMeta;\n            if (yScale.options.stacked) {\n                for (i = 0; i < datasetIndex; i++) {\n                    ds = chart.data.datasets[i];\n                    dsMeta = chart.getDatasetMeta(i);\n                    if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n                        var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n                        if (stackedRightValue < 0) {\n                            sumNeg += stackedRightValue || 0;\n                        } else {\n                            sumPos += stackedRightValue || 0;\n                        }\n                    }\n                }\n                var rightValue = Number(yScale.getRightValue(value));\n                if (rightValue < 0) {\n                    return yScale.getPixelForValue(sumNeg + rightValue);\n                }\n                return yScale.getPixelForValue(sumPos + rightValue);\n            }\n            return yScale.getPixelForValue(value);\n        },\n        updateBezierControlPoints: function () {\n            var me = this;\n            var chart = me.chart;\n            var meta = me.getMeta();\n            var lineModel = meta.dataset._model;\n            var area = chart.chartArea;\n            var points = meta.data || [];\n            var i, ilen, model, controlPoints;\n            if (lineModel.spanGaps) {\n                points = points.filter(function (pt) {\n                    return !pt._model.skip;\n                });\n            }\n            function capControlPoint(pt, min, max) {\n                return Math.max(Math.min(pt, max), min);\n            }\n            if (lineModel.cubicInterpolationMode === 'monotone') {\n                helpers.splineCurveMonotone(points);\n            } else {\n                for (i = 0, ilen = points.length; i < ilen; ++i) {\n                    model = points[i]._model;\n                    controlPoints = helpers.splineCurve(helpers.previousItem(points, i)._model, model, helpers.nextItem(points, i)._model, lineModel.tension);\n                    model.controlPointPreviousX = controlPoints.previous.x;\n                    model.controlPointPreviousY = controlPoints.previous.y;\n                    model.controlPointNextX = controlPoints.next.x;\n                    model.controlPointNextY = controlPoints.next.y;\n                }\n            }\n            if (chart.options.elements.line.capBezierPoints) {\n                for (i = 0, ilen = points.length; i < ilen; ++i) {\n                    model = points[i]._model;\n                    if (isPointInArea(model, area)) {\n                        if (i > 0 && isPointInArea(points[i - 1]._model, area)) {\n                            model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n                            model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n                        }\n                        if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {\n                            model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n                            model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n                        }\n                    }\n                }\n            }\n        },\n        draw: function () {\n            var me = this;\n            var chart = me.chart;\n            var meta = me.getMeta();\n            var points = meta.data || [];\n            var area = chart.chartArea;\n            var ilen = points.length;\n            var halfBorderWidth;\n            var i = 0;\n            if (lineEnabled(me.getDataset(), chart.options)) {\n                halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;\n                helpers.canvas.clipArea(chart.ctx, {\n                    left: area.left,\n                    right: area.right,\n                    top: area.top - halfBorderWidth,\n                    bottom: area.bottom + halfBorderWidth\n                });\n                meta.dataset.draw();\n                helpers.canvas.unclipArea(chart.ctx);\n            }\n            for (; i < ilen; ++i) {\n                points[i].draw(area);\n            }\n        },\n        setHoverStyle: function (point) {\n            var model = point._model;\n            var options = point._options;\n            var getHoverColor = helpers.getHoverColor;\n            point.$previousStyle = {\n                backgroundColor: model.backgroundColor,\n                borderColor: model.borderColor,\n                borderWidth: model.borderWidth,\n                radius: model.radius\n            };\n            model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n            model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));\n            model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n            model.radius = valueOrDefault(options.hoverRadius, options.radius);\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});"]}