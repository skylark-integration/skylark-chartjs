{"version":3,"sources":["colors/route.js"],"names":["define","conversions","deriveBFS","fromModel","graph","models","Object","keys","len","length","i","distance","parent","buildGraph","queue","current","pop","adjacents","adjacent","node","unshift","link","from","to","args","wrapConversion","toModel","path","fn","cur","conversion"],"mappings":";;;;;;;AAAAA,QACC,iBACC,SAASC,GAgCV,SAASC,EAAUC,GAClB,MAAMC,EAnBP,WACC,MAAMA,KAEAC,EAASC,OAAOC,KAAKN,GAE3B,IAAK,IAAIO,EAAMH,EAAOI,OAAQC,EAAI,EAAGA,EAAIF,EAAKE,IAC7CN,EAAMC,EAAOK,KAGZC,UAAW,EACXC,OAAQ,MAIV,OAAOR,EAKOS,GACRC,GAASX,GAIf,IAFAC,EAAMD,GAAWQ,SAAW,EAErBG,EAAML,QAAQ,CACpB,MAAMM,EAAUD,EAAME,MAChBC,EAAYX,OAAOC,KAAKN,EAAYc,IAE1C,IAAK,IAAIP,EAAMS,EAAUR,OAAQC,EAAI,EAAGA,EAAIF,EAAKE,IAAK,CACrD,MAAMQ,EAAWD,EAAUP,GACrBS,EAAOf,EAAMc,IAEI,IAAnBC,EAAKR,WACRQ,EAAKR,SAAWP,EAAMW,GAASJ,SAAW,EAC1CQ,EAAKP,OAASG,EACdD,EAAMM,QAAQF,KAKjB,OAAOd,EAGR,SAASiB,EAAKC,EAAMC,GACnB,OAAO,SAAUC,GAChB,OAAOD,EAAGD,EAAKE,KAIjB,SAASC,EAAeC,EAAStB,GAChC,MAAMuB,GAAQvB,EAAMsB,GAASd,OAAQc,GACrC,IAAIE,EAAK3B,EAAYG,EAAMsB,GAASd,QAAQc,GAExCG,EAAMzB,EAAMsB,GAASd,OACzB,KAAOR,EAAMyB,GAAKjB,QACjBe,EAAKP,QAAQhB,EAAMyB,GAAKjB,QACxBgB,EAAKP,EAAKpB,EAAYG,EAAMyB,GAAKjB,QAAQiB,GAAMD,GAC/CC,EAAMzB,EAAMyB,GAAKjB,OAIlB,OADAgB,EAAGE,WAAaH,EACTC,EAuBR,OApBA,SAAezB,GACd,MAAMC,EAAQF,EAAUC,GAClB2B,KAEAzB,EAASC,OAAOC,KAAKH,GAC3B,IAAK,IAAII,EAAMH,EAAOI,OAAQC,EAAI,EAAGA,EAAIF,EAAKE,IAAK,CAClD,MAAMgB,EAAUrB,EAAOK,GAGH,OAFPN,EAAMsB,GAEVd,SAKTkB,EAAWJ,GAAWD,EAAeC,EAAStB,IAG/C,OAAO0B","file":"../../colors/route.js","sourcesContent":["define([\r\n\t\"./conversions\"\r\n],function(conversions){\r\n\t//const conversions = require('./conversions');\r\n\r\n\t/*\r\n\t\tThis function routes a model to all other models.\r\n\r\n\t\tall functions that are routed have a property `.conversion` attached\r\n\t\tto the returned synthetic function. This property is an array\r\n\t\tof strings, each with the steps in between the 'from' and 'to'\r\n\t\tcolor models (inclusive).\r\n\r\n\t\tconversions that are not possible simply are not included.\r\n\t*/\r\n\r\n\tfunction buildGraph() {\r\n\t\tconst graph = {};\r\n\t\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\r\n\t\tconst models = Object.keys(conversions);\r\n\r\n\t\tfor (let len = models.length, i = 0; i < len; i++) {\r\n\t\t\tgraph[models[i]] = {\r\n\t\t\t\t// http://jsperf.com/1-vs-infinity\r\n\t\t\t\t// micro-opt, but this is simple.\r\n\t\t\t\tdistance: -1,\r\n\t\t\t\tparent: null\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn graph;\r\n\t}\r\n\r\n\t// https://en.wikipedia.org/wiki/Breadth-first_search\r\n\tfunction deriveBFS(fromModel) {\r\n\t\tconst graph = buildGraph();\r\n\t\tconst queue = [fromModel]; // Unshift -> queue -> pop\r\n\r\n\t\tgraph[fromModel].distance = 0;\r\n\r\n\t\twhile (queue.length) {\r\n\t\t\tconst current = queue.pop();\r\n\t\t\tconst adjacents = Object.keys(conversions[current]);\r\n\r\n\t\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\r\n\t\t\t\tconst adjacent = adjacents[i];\r\n\t\t\t\tconst node = graph[adjacent];\r\n\r\n\t\t\t\tif (node.distance === -1) {\r\n\t\t\t\t\tnode.distance = graph[current].distance + 1;\r\n\t\t\t\t\tnode.parent = current;\r\n\t\t\t\t\tqueue.unshift(adjacent);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn graph;\r\n\t}\r\n\r\n\tfunction link(from, to) {\r\n\t\treturn function (args) {\r\n\t\t\treturn to(from(args));\r\n\t\t};\r\n\t}\r\n\r\n\tfunction wrapConversion(toModel, graph) {\r\n\t\tconst path = [graph[toModel].parent, toModel];\r\n\t\tlet fn = conversions[graph[toModel].parent][toModel];\r\n\r\n\t\tlet cur = graph[toModel].parent;\r\n\t\twhile (graph[cur].parent) {\r\n\t\t\tpath.unshift(graph[cur].parent);\r\n\t\t\tfn = link(conversions[graph[cur].parent][cur], fn);\r\n\t\t\tcur = graph[cur].parent;\r\n\t\t}\r\n\r\n\t\tfn.conversion = path;\r\n\t\treturn fn;\r\n\t}\r\n\r\n\tfunction route(fromModel) {\r\n\t\tconst graph = deriveBFS(fromModel);\r\n\t\tconst conversion = {};\r\n\r\n\t\tconst models = Object.keys(graph);\r\n\t\tfor (let len = models.length, i = 0; i < len; i++) {\r\n\t\t\tconst toModel = models[i];\r\n\t\t\tconst node = graph[toModel];\r\n\r\n\t\t\tif (node.parent === null) {\r\n\t\t\t\t// No possible conversion, or this node is the source model.\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconversion[toModel] = wrapConversion(toModel, graph);\r\n\t\t}\r\n\r\n\t\treturn conversion;\r\n\t}\r\n\r\n\treturn route;\r\n});\r\n\r\n"]}