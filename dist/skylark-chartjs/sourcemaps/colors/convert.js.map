{"version":3,"sources":["colors/convert.js"],"names":["define","conversions","route","convert","Object","keys","forEach","fromModel","defineProperty","value","channels","labels","routes","toModel","fn","wrappedFn","args","arg0","undefined","length","result","len","i","Math","round","conversion","wrapRounded","raw","wrapRaw"],"mappings":";;;;;;;AAAAA,QACC,gBACA,WACC,SAASC,EAAYC,GAItB,MAAMC,KA6EN,OA3EeC,OAAOC,KAAKJ,GA0DpBK,QAAQC,IACdJ,EAAQI,MAERH,OAAOI,eAAeL,EAAQI,GAAY,YAAaE,MAAOR,EAAYM,GAAWG,WACrFN,OAAOI,eAAeL,EAAQI,GAAY,UAAWE,MAAOR,EAAYM,GAAWI,SAEnF,MAAMC,EAASV,EAAMK,GACDH,OAAOC,KAAKO,GAEpBN,QAAQO,IACnB,MAAMC,EAAKF,EAAOC,GAElBV,EAAQI,GAAWM,GA9CrB,SAAqBC,GACpB,MAAMC,EAAY,YAAaC,GAC9B,MAAMC,EAAOD,EAAK,GAElB,QAAaE,IAATD,GAA+B,OAATA,EACzB,OAAOA,EAGJA,EAAKE,OAAS,IACjBH,EAAOC,GAGR,MAAMG,EAASN,EAAGE,GAKlB,GAAsB,iBAAXI,EACV,IAAK,IAAIC,EAAMD,EAAOD,OAAQG,EAAI,EAAGA,EAAID,EAAKC,IAC7CF,EAAOE,GAAKC,KAAKC,MAAMJ,EAAOE,IAIhC,OAAOF,GAQR,MAJI,eAAgBN,IACnBC,EAAUU,WAAaX,EAAGW,YAGpBV,EAewBW,CAAYZ,GAC1CX,EAAQI,GAAWM,GAASc,IArE9B,SAAiBb,GAChB,MAAMC,EAAY,YAAaC,GAC9B,MAAMC,EAAOD,EAAK,GAClB,YAAaE,IAATD,GAA+B,OAATA,EAClBA,GAGJA,EAAKE,OAAS,IACjBH,EAAOC,GAGDH,EAAGE,KAQX,MAJI,eAAgBF,IACnBC,EAAUU,WAAaX,EAAGW,YAGpBV,EAkD4Ba,CAAQd,OAIrCX","file":"../../colors/convert.js","sourcesContent":["define([\r\n\t\"./conversions\",\r\n\t\"./route\"\r\n],function(conversions,route){\r\n\t//const conversions = require('./conversions');\r\n\t//const route = require('./route');\r\n\r\n\tconst convert = {};\r\n\r\n\tconst models = Object.keys(conversions);\r\n\r\n\tfunction wrapRaw(fn) {\r\n\t\tconst wrappedFn = function (...args) {\r\n\t\t\tconst arg0 = args[0];\r\n\t\t\tif (arg0 === undefined || arg0 === null) {\r\n\t\t\t\treturn arg0;\r\n\t\t\t}\r\n\r\n\t\t\tif (arg0.length > 1) {\r\n\t\t\t\targs = arg0;\r\n\t\t\t}\r\n\r\n\t\t\treturn fn(args);\r\n\t\t};\r\n\r\n\t\t// Preserve .conversion property if there is one\r\n\t\tif ('conversion' in fn) {\r\n\t\t\twrappedFn.conversion = fn.conversion;\r\n\t\t}\r\n\r\n\t\treturn wrappedFn;\r\n\t}\r\n\r\n\tfunction wrapRounded(fn) {\r\n\t\tconst wrappedFn = function (...args) {\r\n\t\t\tconst arg0 = args[0];\r\n\r\n\t\t\tif (arg0 === undefined || arg0 === null) {\r\n\t\t\t\treturn arg0;\r\n\t\t\t}\r\n\r\n\t\t\tif (arg0.length > 1) {\r\n\t\t\t\targs = arg0;\r\n\t\t\t}\r\n\r\n\t\t\tconst result = fn(args);\r\n\r\n\t\t\t// We're assuming the result is an array here.\r\n\t\t\t// see notice in conversions.js; don't use box types\r\n\t\t\t// in conversion functions.\r\n\t\t\tif (typeof result === 'object') {\r\n\t\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\r\n\t\t\t\t\tresult[i] = Math.round(result[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t};\r\n\r\n\t\t// Preserve .conversion property if there is one\r\n\t\tif ('conversion' in fn) {\r\n\t\t\twrappedFn.conversion = fn.conversion;\r\n\t\t}\r\n\r\n\t\treturn wrappedFn;\r\n\t}\r\n\r\n\tmodels.forEach(fromModel => {\r\n\t\tconvert[fromModel] = {};\r\n\r\n\t\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\r\n\t\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\r\n\r\n\t\tconst routes = route(fromModel);\r\n\t\tconst routeModels = Object.keys(routes);\r\n\r\n\t\trouteModels.forEach(toModel => {\r\n\t\t\tconst fn = routes[toModel];\r\n\r\n\t\t\tconvert[fromModel][toModel] = wrapRounded(fn);\r\n\t\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\r\n\t\t});\r\n\t});\r\n\r\n\treturn convert;\r\n});"]}