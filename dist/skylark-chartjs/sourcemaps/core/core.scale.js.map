{"version":3,"sources":["core/core.scale.js"],"names":["define","__module__0","__module__1","__module__2","__module__3","exports","module","defaults","Element","helpers","Ticks","valueOrDefault","valueAtIndexOrDefault","labelsFromTicks","ticks","i","ilen","labels","length","push","label","computeTextSize","context","tick","font","isArray","longestText","measureText","width","__isValidToReturn","obj","Array","attr","__isEmptyObject","_set","display","position","offset","gridLines","color","lineWidth","drawBorder","drawOnChartArea","drawTicks","tickMarkLength","zeroLineWidth","zeroLineColor","zeroLineBorderDash","zeroLineBorderDashOffset","offsetGridLines","borderDash","borderDashOffset","scaleLabel","labelString","padding","top","bottom","beginAtZero","minRotation","maxRotation","mirror","reverse","autoSkip","autoSkipPadding","labelOffset","callback","formatters","values","minor","major","extend","getPadding","left","this","paddingLeft","paddingTop","right","paddingRight","paddingBottom","getTicks","_ticks","mergeTicksOptions","options","key","beforeUpdate","update","maxWidth","maxHeight","margins","me","_maxLabelLines","longestLabelWidth","longestTextCache","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","beforeTickToLabelConversion","convertTicksToLabels","afterTickToLabelConversion","beforeCalculateTickRotation","calculateTickRotation","afterCalculateTickRotation","beforeFit","fit","afterFit","afterUpdate","minSize","isHorizontal","height","noop","tickOpts","map","userCallback","ctx","tickFont","_parseFont","string","labelRotation","cosRotation","originalLabelWidth","labelWidth","tickWidth","getPixelForTick","angleRadians","toRadians","Math","cos","sin","opts","scaleLabelOpts","gridLineOpts","_isVisible","parseFont","isFullWidth","scaleLabelFont","scaleLabelPadding","toPadding","deltaHeight","lineHeight","largestTextWidth","tallestLabelHeightInLines","numberOfLabelLines","lineSpace","size","tickPadding","labelHeight","min","firstLabelWidth","lastLabelWidth","offsetLeft","offsetRight","max","handleMargins","fullWidth","getRightValue","rawValue","isNullOrUndef","NaN","Number","isFinite","undefined","x","y","getLabelForIndex","getPixelForValue","getValueForPixel","index","pixel","finalVal","innerHeight","getPixelForDecimal","decimal","valueOffset","getBasePixel","getBaseValue","_autoSkip","optionTicks","tickCount","skipRatio","maxTicks","maxTicksLimit","ticksLength","_tickSize","axisLength","PaddingBottom","result","floor","rot","abs","w","h","meta","chart","data","datasets","isDatasetVisible","getDatasetMeta","xAxisID","id","yAxisID","draw","chartArea","borderValue","tickStart","tickEnd","defaultFontColor","global","optionMajorTicks","isRotated","isMirrored","tickFontColor","fontColor","majorTickFontColor","majorTickFont","tl","scaleLabelFontColor","labelRotationRadians","itemsToDraw","axisWidth","alignPixel","_alignPixel","each","lineColor","tx1","ty1","tx2","ty2","x1","y1","x2","y2","labelX","labelY","textOffset","textAlign","zeroLineIndex","labelCount","lineValue","scale","getPixelForGridLine","labelYOffset","labelXOffset","glWidth","glColor","glBorderDash","glBorderDashOffset","rotation","itemToDraw","save","strokeStyle","setLineDash","lineDashOffset","beginPath","moveTo","lineTo","stroke","restore","translate","rotate","fillStyle","textBaseline","fillText","scaleLabelX","scaleLabelY","halfLineHeight","isLeft","PI","firstLineWidth","lastLineWidth"],"mappings":"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","file":"../../core/core.scale.js","sourcesContent":["define([\n    './core.defaults',\n    './core.element',\n    '../helpers/index',\n    './core.ticks'\n], function (__module__0, __module__1, __module__2, __module__3) {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    var defaults = __module__0;\n    var Element = __module__1;\n    var helpers = __module__2;\n    var Ticks = __module__3;\n    var valueOrDefault = helpers.valueOrDefault;\n    var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n    defaults._set('scale', {\n        display: true,\n        position: 'left',\n        offset: false,\n        gridLines: {\n            display: true,\n            color: 'rgba(0, 0, 0, 0.1)',\n            lineWidth: 1,\n            drawBorder: true,\n            drawOnChartArea: true,\n            drawTicks: true,\n            tickMarkLength: 10,\n            zeroLineWidth: 1,\n            zeroLineColor: 'rgba(0,0,0,0.25)',\n            zeroLineBorderDash: [],\n            zeroLineBorderDashOffset: 0,\n            offsetGridLines: false,\n            borderDash: [],\n            borderDashOffset: 0\n        },\n        scaleLabel: {\n            display: false,\n            labelString: '',\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            beginAtZero: false,\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: false,\n            padding: 0,\n            reverse: false,\n            display: true,\n            autoSkip: true,\n            autoSkipPadding: 0,\n            labelOffset: 0,\n            callback: Ticks.formatters.values,\n            minor: {},\n            major: {}\n        }\n    });\n    function labelsFromTicks(ticks) {\n        var labels = [];\n        var i, ilen;\n        for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n            labels.push(ticks[i].label);\n        }\n        return labels;\n    }\n    function getPixelForGridLine(scale, index, offsetGridLines) {\n        var lineValue = scale.getPixelForTick(index);\n        if (offsetGridLines) {\n            if (scale.getTicks().length === 1) {\n                lineValue -= scale.isHorizontal() ? Math.max(lineValue - scale.left, scale.right - lineValue) : Math.max(lineValue - scale.top, scale.bottom - lineValue);\n            } else if (index === 0) {\n                lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n            } else {\n                lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n            }\n        }\n        return lineValue;\n    }\n    function computeTextSize(context, tick, font) {\n        return helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;\n    }\n    module.exports = Element.extend({\n        getPadding: function () {\n            var me = this;\n            return {\n                left: me.paddingLeft || 0,\n                top: me.paddingTop || 0,\n                right: me.paddingRight || 0,\n                bottom: me.paddingBottom || 0\n            };\n        },\n        getTicks: function () {\n            return this._ticks;\n        },\n        mergeTicksOptions: function () {\n            var ticks = this.options.ticks;\n            if (ticks.minor === false) {\n                ticks.minor = { display: false };\n            }\n            if (ticks.major === false) {\n                ticks.major = { display: false };\n            }\n            for (var key in ticks) {\n                if (key !== 'major' && key !== 'minor') {\n                    if (typeof ticks.minor[key] === 'undefined') {\n                        ticks.minor[key] = ticks[key];\n                    }\n                    if (typeof ticks.major[key] === 'undefined') {\n                        ticks.major[key] = ticks[key];\n                    }\n                }\n            }\n        },\n        beforeUpdate: function () {\n            helpers.callback(this.options.beforeUpdate, [this]);\n        },\n        update: function (maxWidth, maxHeight, margins) {\n            var me = this;\n            var i, ilen, labels, label, ticks, tick;\n            me.beforeUpdate();\n            me.maxWidth = maxWidth;\n            me.maxHeight = maxHeight;\n            me.margins = helpers.extend({\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, margins);\n            me._maxLabelLines = 0;\n            me.longestLabelWidth = 0;\n            me.longestTextCache = me.longestTextCache || {};\n            me.beforeSetDimensions();\n            me.setDimensions();\n            me.afterSetDimensions();\n            me.beforeDataLimits();\n            me.determineDataLimits();\n            me.afterDataLimits();\n            me.beforeBuildTicks();\n            ticks = me.buildTicks() || [];\n            ticks = me.afterBuildTicks(ticks) || ticks;\n            me.beforeTickToLabelConversion();\n            labels = me.convertTicksToLabels(ticks) || me.ticks;\n            me.afterTickToLabelConversion();\n            me.ticks = labels;\n            for (i = 0, ilen = labels.length; i < ilen; ++i) {\n                label = labels[i];\n                tick = ticks[i];\n                if (!tick) {\n                    ticks.push(tick = {\n                        label: label,\n                        major: false\n                    });\n                } else {\n                    tick.label = label;\n                }\n            }\n            me._ticks = ticks;\n            me.beforeCalculateTickRotation();\n            me.calculateTickRotation();\n            me.afterCalculateTickRotation();\n            me.beforeFit();\n            me.fit();\n            me.afterFit();\n            me.afterUpdate();\n            return me.minSize;\n        },\n        afterUpdate: function () {\n            helpers.callback(this.options.afterUpdate, [this]);\n        },\n        beforeSetDimensions: function () {\n            helpers.callback(this.options.beforeSetDimensions, [this]);\n        },\n        setDimensions: function () {\n            var me = this;\n            if (me.isHorizontal()) {\n                me.width = me.maxWidth;\n                me.left = 0;\n                me.right = me.width;\n            } else {\n                me.height = me.maxHeight;\n                me.top = 0;\n                me.bottom = me.height;\n            }\n            me.paddingLeft = 0;\n            me.paddingTop = 0;\n            me.paddingRight = 0;\n            me.paddingBottom = 0;\n        },\n        afterSetDimensions: function () {\n            helpers.callback(this.options.afterSetDimensions, [this]);\n        },\n        beforeDataLimits: function () {\n            helpers.callback(this.options.beforeDataLimits, [this]);\n        },\n        determineDataLimits: helpers.noop,\n        afterDataLimits: function () {\n            helpers.callback(this.options.afterDataLimits, [this]);\n        },\n        beforeBuildTicks: function () {\n            helpers.callback(this.options.beforeBuildTicks, [this]);\n        },\n        buildTicks: helpers.noop,\n        afterBuildTicks: function (ticks) {\n            var me = this;\n            if (helpers.isArray(ticks) && ticks.length) {\n                return helpers.callback(me.options.afterBuildTicks, [\n                    me,\n                    ticks\n                ]);\n            }\n            me.ticks = helpers.callback(me.options.afterBuildTicks, [\n                me,\n                me.ticks\n            ]) || me.ticks;\n            return ticks;\n        },\n        beforeTickToLabelConversion: function () {\n            helpers.callback(this.options.beforeTickToLabelConversion, [this]);\n        },\n        convertTicksToLabels: function () {\n            var me = this;\n            var tickOpts = me.options.ticks;\n            me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n        },\n        afterTickToLabelConversion: function () {\n            helpers.callback(this.options.afterTickToLabelConversion, [this]);\n        },\n        beforeCalculateTickRotation: function () {\n            helpers.callback(this.options.beforeCalculateTickRotation, [this]);\n        },\n        calculateTickRotation: function () {\n            var me = this;\n            var context = me.ctx;\n            var tickOpts = me.options.ticks;\n            var labels = labelsFromTicks(me._ticks);\n            var tickFont = helpers.options._parseFont(tickOpts);\n            context.font = tickFont.string;\n            var labelRotation = tickOpts.minRotation || 0;\n            if (labels.length && me.options.display && me.isHorizontal()) {\n                var originalLabelWidth = helpers.longestText(context, tickFont.string, labels, me.longestTextCache);\n                var labelWidth = originalLabelWidth;\n                var cosRotation, sinRotation;\n                var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n                while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n                    var angleRadians = helpers.toRadians(labelRotation);\n                    cosRotation = Math.cos(angleRadians);\n                    sinRotation = Math.sin(angleRadians);\n                    if (sinRotation * originalLabelWidth > me.maxHeight) {\n                        labelRotation--;\n                        break;\n                    }\n                    labelRotation++;\n                    labelWidth = cosRotation * originalLabelWidth;\n                }\n            }\n            me.labelRotation = labelRotation;\n        },\n        afterCalculateTickRotation: function () {\n            helpers.callback(this.options.afterCalculateTickRotation, [this]);\n        },\n        beforeFit: function () {\n            helpers.callback(this.options.beforeFit, [this]);\n        },\n        fit: function () {\n            var me = this;\n            var minSize = me.minSize = {\n                width: 0,\n                height: 0\n            };\n            var labels = labelsFromTicks(me._ticks);\n            var opts = me.options;\n            var tickOpts = opts.ticks;\n            var scaleLabelOpts = opts.scaleLabel;\n            var gridLineOpts = opts.gridLines;\n            var display = me._isVisible();\n            var position = opts.position;\n            var isHorizontal = me.isHorizontal();\n            var parseFont = helpers.options._parseFont;\n            var tickFont = parseFont(tickOpts);\n            var tickMarkLength = opts.gridLines.tickMarkLength;\n            if (isHorizontal) {\n                minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n            } else {\n                minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n            }\n            if (isHorizontal) {\n                minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n            } else {\n                minSize.height = me.maxHeight;\n            }\n            if (scaleLabelOpts.display && display) {\n                var scaleLabelFont = parseFont(scaleLabelOpts);\n                var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\n                var deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;\n                if (isHorizontal) {\n                    minSize.height += deltaHeight;\n                } else {\n                    minSize.width += deltaHeight;\n                }\n            }\n            if (tickOpts.display && display) {\n                var largestTextWidth = helpers.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);\n                var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\n                var lineSpace = tickFont.size * 0.5;\n                var tickPadding = me.options.ticks.padding;\n                me._maxLabelLines = tallestLabelHeightInLines;\n                me.longestLabelWidth = largestTextWidth;\n                if (isHorizontal) {\n                    var angleRadians = helpers.toRadians(me.labelRotation);\n                    var cosRotation = Math.cos(angleRadians);\n                    var sinRotation = Math.sin(angleRadians);\n                    var labelHeight = sinRotation * largestTextWidth + tickFont.lineHeight * tallestLabelHeightInLines + lineSpace;\n                    minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n                    me.ctx.font = tickFont.string;\n                    var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);\n                    var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);\n                    var offsetLeft = me.getPixelForTick(0) - me.left;\n                    var offsetRight = me.right - me.getPixelForTick(labels.length - 1);\n                    var paddingLeft, paddingRight;\n                    if (me.labelRotation !== 0) {\n                        paddingLeft = position === 'bottom' ? cosRotation * firstLabelWidth : cosRotation * lineSpace;\n                        paddingRight = position === 'bottom' ? cosRotation * lineSpace : cosRotation * lastLabelWidth;\n                    } else {\n                        paddingLeft = firstLabelWidth / 2;\n                        paddingRight = lastLabelWidth / 2;\n                    }\n                    me.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3;\n                    me.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;\n                } else {\n                    if (tickOpts.mirror) {\n                        largestTextWidth = 0;\n                    } else {\n                        largestTextWidth += tickPadding + lineSpace;\n                    }\n                    minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n                    me.paddingTop = tickFont.size / 2;\n                    me.paddingBottom = tickFont.size / 2;\n                }\n            }\n            me.handleMargins();\n            me.width = minSize.width;\n            me.height = minSize.height;\n        },\n        handleMargins: function () {\n            var me = this;\n            if (me.margins) {\n                me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n                me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n                me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n                me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n            }\n        },\n        afterFit: function () {\n            helpers.callback(this.options.afterFit, [this]);\n        },\n        isHorizontal: function () {\n            return this.options.position === 'top' || this.options.position === 'bottom';\n        },\n        isFullWidth: function () {\n            return this.options.fullWidth;\n        },\n        getRightValue: function (rawValue) {\n            if (helpers.isNullOrUndef(rawValue)) {\n                return NaN;\n            }\n            if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {\n                return NaN;\n            }\n            if (rawValue) {\n                if (this.isHorizontal()) {\n                    if (rawValue.x !== undefined) {\n                        return this.getRightValue(rawValue.x);\n                    }\n                } else if (rawValue.y !== undefined) {\n                    return this.getRightValue(rawValue.y);\n                }\n            }\n            return rawValue;\n        },\n        getLabelForIndex: helpers.noop,\n        getPixelForValue: helpers.noop,\n        getValueForPixel: helpers.noop,\n        getPixelForTick: function (index) {\n            var me = this;\n            var offset = me.options.offset;\n            if (me.isHorizontal()) {\n                var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n                var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);\n                var pixel = tickWidth * index + me.paddingLeft;\n                if (offset) {\n                    pixel += tickWidth / 2;\n                }\n                var finalVal = me.left + pixel;\n                finalVal += me.isFullWidth() ? me.margins.left : 0;\n                return finalVal;\n            }\n            var innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n            return me.top + index * (innerHeight / (me._ticks.length - 1));\n        },\n        getPixelForDecimal: function (decimal) {\n            var me = this;\n            if (me.isHorizontal()) {\n                var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n                var valueOffset = innerWidth * decimal + me.paddingLeft;\n                var finalVal = me.left + valueOffset;\n                finalVal += me.isFullWidth() ? me.margins.left : 0;\n                return finalVal;\n            }\n            return me.top + decimal * me.height;\n        },\n        getBasePixel: function () {\n            return this.getPixelForValue(this.getBaseValue());\n        },\n        getBaseValue: function () {\n            var me = this;\n            var min = me.min;\n            var max = me.max;\n            return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n        },\n        _autoSkip: function (ticks) {\n            var me = this;\n            var isHorizontal = me.isHorizontal();\n            var optionTicks = me.options.ticks.minor;\n            var tickCount = ticks.length;\n            var skipRatio = false;\n            var maxTicks = optionTicks.maxTicksLimit;\n            var ticksLength = me._tickSize() * (tickCount - 1);\n            var axisLength = isHorizontal ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.PaddingBottom);\n            var result = [];\n            var i, tick;\n            if (ticksLength > axisLength) {\n                skipRatio = 1 + Math.floor(ticksLength / axisLength);\n            }\n            if (tickCount > maxTicks) {\n                skipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));\n            }\n            for (i = 0; i < tickCount; i++) {\n                tick = ticks[i];\n                if (skipRatio > 1 && i % skipRatio > 0) {\n                    delete tick.label;\n                }\n                result.push(tick);\n            }\n            return result;\n        },\n        _tickSize: function () {\n            var me = this;\n            var isHorizontal = me.isHorizontal();\n            var optionTicks = me.options.ticks.minor;\n            var rot = helpers.toRadians(me.labelRotation);\n            var cos = Math.abs(Math.cos(rot));\n            var sin = Math.abs(Math.sin(rot));\n            var padding = optionTicks.autoSkipPadding || 0;\n            var w = me.longestLabelWidth + padding || 0;\n            var tickFont = helpers.options._parseFont(optionTicks);\n            var h = me._maxLabelLines * tickFont.lineHeight + padding || 0;\n            return isHorizontal ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n        },\n        _isVisible: function () {\n            var me = this;\n            var chart = me.chart;\n            var display = me.options.display;\n            var i, ilen, meta;\n            if (display !== 'auto') {\n                return !!display;\n            }\n            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    if (meta.xAxisID === me.id || meta.yAxisID === me.id) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        draw: function (chartArea) {\n            var me = this;\n            var options = me.options;\n            if (!me._isVisible()) {\n                return;\n            }\n            var chart = me.chart;\n            var context = me.ctx;\n            var globalDefaults = defaults.global;\n            var defaultFontColor = globalDefaults.defaultFontColor;\n            var optionTicks = options.ticks.minor;\n            var optionMajorTicks = options.ticks.major || optionTicks;\n            var gridLines = options.gridLines;\n            var scaleLabel = options.scaleLabel;\n            var position = options.position;\n            var isRotated = me.labelRotation !== 0;\n            var isMirrored = optionTicks.mirror;\n            var isHorizontal = me.isHorizontal();\n            var parseFont = helpers.options._parseFont;\n            var ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n            var tickFontColor = valueOrDefault(optionTicks.fontColor, defaultFontColor);\n            var tickFont = parseFont(optionTicks);\n            var lineHeight = tickFont.lineHeight;\n            var majorTickFontColor = valueOrDefault(optionMajorTicks.fontColor, defaultFontColor);\n            var majorTickFont = parseFont(optionMajorTicks);\n            var tickPadding = optionTicks.padding;\n            var labelOffset = optionTicks.labelOffset;\n            var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n            var scaleLabelFontColor = valueOrDefault(scaleLabel.fontColor, defaultFontColor);\n            var scaleLabelFont = parseFont(scaleLabel);\n            var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);\n            var labelRotationRadians = helpers.toRadians(me.labelRotation);\n            var itemsToDraw = [];\n            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\n            var alignPixel = helpers._alignPixel;\n            var borderValue, tickStart, tickEnd;\n            if (position === 'top') {\n                borderValue = alignPixel(chart, me.bottom, axisWidth);\n                tickStart = me.bottom - tl;\n                tickEnd = borderValue - axisWidth / 2;\n            } else if (position === 'bottom') {\n                borderValue = alignPixel(chart, me.top, axisWidth);\n                tickStart = borderValue + axisWidth / 2;\n                tickEnd = me.top + tl;\n            } else if (position === 'left') {\n                borderValue = alignPixel(chart, me.right, axisWidth);\n                tickStart = me.right - tl;\n                tickEnd = borderValue - axisWidth / 2;\n            } else {\n                borderValue = alignPixel(chart, me.left, axisWidth);\n                tickStart = borderValue + axisWidth / 2;\n                tickEnd = me.left + tl;\n            }\n            var epsilon = 1e-7;\n            helpers.each(ticks, function (tick, index) {\n                if (helpers.isNullOrUndef(tick.label)) {\n                    return;\n                }\n                var label = tick.label;\n                var lineWidth, lineColor, borderDash, borderDashOffset;\n                if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n                    lineWidth = gridLines.zeroLineWidth;\n                    lineColor = gridLines.zeroLineColor;\n                    borderDash = gridLines.zeroLineBorderDash || [];\n                    borderDashOffset = gridLines.zeroLineBorderDashOffset || 0;\n                } else {\n                    lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);\n                    lineColor = valueAtIndexOrDefault(gridLines.color, index);\n                    borderDash = gridLines.borderDash || [];\n                    borderDashOffset = gridLines.borderDashOffset || 0;\n                }\n                var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;\n                var labelCount = helpers.isArray(label) ? label.length : 1;\n                var lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);\n                if (isHorizontal) {\n                    var labelYOffset = tl + tickPadding;\n                    if (lineValue < me.left - epsilon) {\n                        lineColor = 'rgba(0,0,0,0)';\n                    }\n                    tx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);\n                    ty1 = tickStart;\n                    ty2 = tickEnd;\n                    labelX = me.getPixelForTick(index) + labelOffset;\n                    if (position === 'top') {\n                        y1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;\n                        y2 = chartArea.bottom;\n                        textOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;\n                        textAlign = !isRotated ? 'center' : 'left';\n                        labelY = me.bottom - labelYOffset;\n                    } else {\n                        y1 = chartArea.top;\n                        y2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;\n                        textOffset = (!isRotated ? 0.5 : 0) * lineHeight;\n                        textAlign = !isRotated ? 'center' : 'right';\n                        labelY = me.top + labelYOffset;\n                    }\n                } else {\n                    var labelXOffset = (isMirrored ? 0 : tl) + tickPadding;\n                    if (lineValue < me.top - epsilon) {\n                        lineColor = 'rgba(0,0,0,0)';\n                    }\n                    tx1 = tickStart;\n                    tx2 = tickEnd;\n                    ty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);\n                    labelY = me.getPixelForTick(index) + labelOffset;\n                    textOffset = (1 - labelCount) * lineHeight / 2;\n                    if (position === 'left') {\n                        x1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;\n                        x2 = chartArea.right;\n                        textAlign = isMirrored ? 'left' : 'right';\n                        labelX = me.right - labelXOffset;\n                    } else {\n                        x1 = chartArea.left;\n                        x2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;\n                        textAlign = isMirrored ? 'right' : 'left';\n                        labelX = me.left + labelXOffset;\n                    }\n                }\n                itemsToDraw.push({\n                    tx1: tx1,\n                    ty1: ty1,\n                    tx2: tx2,\n                    ty2: ty2,\n                    x1: x1,\n                    y1: y1,\n                    x2: x2,\n                    y2: y2,\n                    labelX: labelX,\n                    labelY: labelY,\n                    glWidth: lineWidth,\n                    glColor: lineColor,\n                    glBorderDash: borderDash,\n                    glBorderDashOffset: borderDashOffset,\n                    rotation: -1 * labelRotationRadians,\n                    label: label,\n                    major: tick.major,\n                    textOffset: textOffset,\n                    textAlign: textAlign\n                });\n            });\n            helpers.each(itemsToDraw, function (itemToDraw) {\n                var glWidth = itemToDraw.glWidth;\n                var glColor = itemToDraw.glColor;\n                if (gridLines.display && glWidth && glColor) {\n                    context.save();\n                    context.lineWidth = glWidth;\n                    context.strokeStyle = glColor;\n                    if (context.setLineDash) {\n                        context.setLineDash(itemToDraw.glBorderDash);\n                        context.lineDashOffset = itemToDraw.glBorderDashOffset;\n                    }\n                    context.beginPath();\n                    if (gridLines.drawTicks) {\n                        context.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n                        context.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n                    }\n                    if (gridLines.drawOnChartArea) {\n                        context.moveTo(itemToDraw.x1, itemToDraw.y1);\n                        context.lineTo(itemToDraw.x2, itemToDraw.y2);\n                    }\n                    context.stroke();\n                    context.restore();\n                }\n                if (optionTicks.display) {\n                    context.save();\n                    context.translate(itemToDraw.labelX, itemToDraw.labelY);\n                    context.rotate(itemToDraw.rotation);\n                    context.font = itemToDraw.major ? majorTickFont.string : tickFont.string;\n                    context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n                    context.textBaseline = 'middle';\n                    context.textAlign = itemToDraw.textAlign;\n                    var label = itemToDraw.label;\n                    var y = itemToDraw.textOffset;\n                    if (helpers.isArray(label)) {\n                        for (var i = 0; i < label.length; ++i) {\n                            context.fillText('' + label[i], 0, y);\n                            y += lineHeight;\n                        }\n                    } else {\n                        context.fillText(label, 0, y);\n                    }\n                    context.restore();\n                }\n            });\n            if (scaleLabel.display) {\n                var scaleLabelX;\n                var scaleLabelY;\n                var rotation = 0;\n                var halfLineHeight = scaleLabelFont.lineHeight / 2;\n                if (isHorizontal) {\n                    scaleLabelX = me.left + (me.right - me.left) / 2;\n                    scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;\n                } else {\n                    var isLeft = position === 'left';\n                    scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;\n                    scaleLabelY = me.top + (me.bottom - me.top) / 2;\n                    rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n                }\n                context.save();\n                context.translate(scaleLabelX, scaleLabelY);\n                context.rotate(rotation);\n                context.textAlign = 'center';\n                context.textBaseline = 'middle';\n                context.fillStyle = scaleLabelFontColor;\n                context.font = scaleLabelFont.string;\n                context.fillText(scaleLabel.labelString, 0, 0);\n                context.restore();\n            }\n            if (axisWidth) {\n                var firstLineWidth = axisWidth;\n                var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);\n                var x1, x2, y1, y2;\n                if (isHorizontal) {\n                    x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;\n                    x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;\n                    y1 = y2 = borderValue;\n                } else {\n                    y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;\n                    y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\n                    x1 = x2 = borderValue;\n                }\n                context.lineWidth = axisWidth;\n                context.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);\n                context.beginPath();\n                context.moveTo(x1, y1);\n                context.lineTo(x2, y2);\n                context.stroke();\n            }\n        }\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});"]}